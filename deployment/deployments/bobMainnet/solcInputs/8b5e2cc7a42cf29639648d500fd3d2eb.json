{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../../access/Ownable.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"UpgradeableBeacon: implementation is not a contract\");\n        _implementation = newImplementation;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "contracts/callpaths/BootPath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport '../libraries/ProtocolCmd.sol';\nimport '../mixins/StorageLayout.sol';\nimport '../SdexEvents.sol';\n\n/* @title Booth path callpath sidecar.\n * \n * @notice Simple proxy with the sole function of upgrading other proxy contracts. For safety\n *         this proxy cannot upgrade itself, since that would risk permenately locking out the\n *         ability to ever upgrade.\n *         \n * @dev    This is a special proxy sidecar which should only be installed once at construction\n *         time at slot 0 (BOOT_PROXY_IDX). No other proxy contract should include upgrade \n *         functionality. If both of these conditions are true, this proxy can never be overwritten\n *         and upgrade functionality can never be broken for the life of the main contract. */\ncontract BootPath is StorageLayout {\n    using ProtocolCmd for bytes;\n\n    /* @notice Consolidated method for protocol control related commands. */\n    function protocolCmd (bytes calldata cmd) virtual public {\n        require(sudoMode_, \"Sudo\");\n        \n        uint8 cmdCode = uint8(cmd[31]);\n        if (cmdCode == ProtocolCmd.UPGRADE_DEX_CODE) {\n            upgradeProxy(cmd);\n        } else {\n            revert(\"Invalid command\");\n        }\n    }\n    \n    function userCmd (bytes calldata) virtual public payable { \n        revert(\"Invalid command\");\n    }\n    \n    /* @notice Upgrades one of the existing proxy sidecar contracts.\n     * @dev    Be extremely careful calling this, particularly when upgrading the\n     *         cold path contract, since that contains the upgrade code itself.\n     * @param proxy The address of the new proxy smart contract\n     * @param proxyIdx Determines which proxy is upgraded on this call */\n    function upgradeProxy (bytes calldata cmd) private {\n        (, address proxy, uint16 proxyIdx) =\n            abi.decode(cmd, (uint8, address, uint16));\n\n        require(proxyIdx != SdexSlots.BOOT_PROXY_IDX, \"Cannot overwrite boot path\");\n        require(proxy == address(0) || proxy.code.length > 0, \"Proxy address is not a contract\");\n\n        emit SdexEvents.UpgradeProxy(proxy, proxyIdx);\n        proxyPaths_[proxyIdx] = proxy;        \n\n        if (proxy != address(0)) {\n            bool doesAccept = BootPath(proxy).acceptSdexProxyRole(address(this), proxyIdx);\n            require(doesAccept, \"Proxy does not accept role\");\n        }\n    }\n\n    /* @notice Conforms to the standard call, but should always reject role because this contract\n     *         should only ever be installled once at construction time and never upgraded after */\n    function acceptSdexProxyRole (address, uint16) public pure virtual returns (bool) {\n        return false;\n    }\n}\n\n"
    },
    "contracts/callpaths/ColdPath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport '../libraries/Directives.sol';\nimport '../libraries/Encoding.sol';\nimport '../libraries/TokenFlow.sol';\nimport '../libraries/PriceGrid.sol';\nimport '../libraries/ProtocolCmd.sol';\nimport '../mixins/SettleLayer.sol';\nimport '../mixins/PoolRegistry.sol';\nimport '../mixins/MarketSequencer.sol';\nimport '../mixins/StorageLayout.sol';\nimport '../mixins/ProtocolAccount.sol';\nimport '../mixins/DepositDesk.sol';\nimport '../interfaces/ISdexMinion.sol';\nimport '../SdexEvents.sol';\n\n/* @title Cold path callpath sidecar.\n * @notice Defines a proxy sidecar contract that's used to move code outside the \n *         main contract to avoid Ethereum's contract code size limit. Contains\n *         top-level logic for non trade related logic, including protocol control,\n *         pool initialization, and surplus collateral payment. \n * \n * @dev    This exists as a standalone contract but will only ever contain proxy code,\n *         not state. As such it should never be called directly or externally, and should\n *         only be invoked with DELEGATECALL so that it operates on the contract state\n *         within the primary SdexSwap contract. */\ncontract ColdPath is MarketSequencer, DepositDesk, ProtocolAccount {\n    using SafeCast for uint128;\n    using TokenFlow for TokenFlow.PairSeq;\n    using CurveMath for CurveMath.CurveState;\n    using Chaining for Chaining.PairFlow;\n    using ProtocolCmd for bytes;\n\n    /* @notice Consolidated method for protocol control related commands. */\n    function protocolCmd (bytes calldata cmd) virtual public {\n        uint8 code = uint8(cmd[31]);\n\n        if (code == ProtocolCmd.DISABLE_TEMPLATE_CODE) {\n            disableTemplate(cmd);\n        } else if (code == ProtocolCmd.POOL_TEMPLATE_CODE) {\n            setTemplate(cmd);\n        } else if (code == ProtocolCmd.POOL_REVISE_CODE) {\n            revisePool(cmd);\n        } else if (code == ProtocolCmd.SET_TAKE_CODE) {\n            setTakeRate(cmd);\n        } else if (code == ProtocolCmd.RELAYER_TAKE_CODE) {\n            setRelayerTakeRate(cmd);\n        } else if (code == ProtocolCmd.RESYNC_TAKE_CODE) {\n            resyncTakeRate(cmd);\n        } else if (code == ProtocolCmd.INIT_POOL_LIQ_CODE) {\n            setNewPoolLiq(cmd);\n        } else if (code == ProtocolCmd.OFF_GRID_CODE) {\n            pegPriceImprove(cmd);\n        } else {\n            sudoCmd(cmd);\n        }\n\n        emit SdexEvents.SdexColdProtocolCmd(cmd);\n    }\n\n    /* @notice Subset of highly privileged commands that are only allowed to run in sudo\n     *         mode. */\n    function sudoCmd (bytes calldata cmd) internal {\n        require(sudoMode_, \"Sudo\");\n        uint8 cmdCode = uint8(cmd[31]);\n        \n        if (cmdCode == ProtocolCmd.COLLECT_TREASURY_CODE) {\n            collectProtocol(cmd);\n        } else if (cmdCode == ProtocolCmd.SET_TREASURY_CODE) {\n            setTreasury(cmd);\n        } else if (cmdCode == ProtocolCmd.AUTHORITY_TRANSFER_CODE) {\n            transferAuthority(cmd);\n        } else if (cmdCode == ProtocolCmd.HOT_OPEN_CODE) {\n            setHotPathOpen(cmd);\n        } else if (cmdCode == ProtocolCmd.SAFE_MODE_CODE) {\n            setSafeMode(cmd);\n        } else {\n            revert(\"Invalid command\");\n        }\n\n    }\n    \n    function userCmd (bytes calldata cmd) virtual public payable {\n        uint8 cmdCode = uint8(cmd[31]);\n        \n        if (cmdCode == UserCmd.INIT_POOL_CODE) {\n            initPool(cmd);\n        } else if (cmdCode == UserCmd.APPROVE_ROUTER_CODE) {\n            approveRouter(cmd);\n        } else if (cmdCode == UserCmd.DEPOSIT_SURPLUS_CODE) {\n            depositSurplus(cmd);\n        } else if (cmdCode == UserCmd.DEPOSIT_PERMIT_CODE) {\n            depositPermit(cmd);\n        } else if (cmdCode == UserCmd.DISBURSE_SURPLUS_CODE) {\n            disburseSurplus(cmd);\n        } else if (cmdCode == UserCmd.TRANSFER_SURPLUS_CODE) {\n            transferSurplus(cmd);\n        } else if (cmdCode == UserCmd.SIDE_POCKET_CODE) {\n            sidePocketSurplus(cmd);\n        } else if (cmdCode == UserCmd.RESET_NONCE) {\n            resetNonce(cmd);\n        } else if (cmdCode == UserCmd.RESET_NONCE_COND) {\n            resetNonceCond(cmd);\n        } else if (cmdCode == UserCmd.GATE_ORACLE_COND) {\n            checkGateOracle(cmd);\n        } else {\n            revert(\"Invalid command\");\n        }\n\n        emit SdexEvents.SdexColdCmd(cmd);\n    }\n    \n    /* @notice Initializes the pool type for the pair.\n     * @param base The base token in the pair.\n     * @param quote The quote token in the pair.\n     * @param poolIdx The index of the pool type to initialize.\n     * @param price The price to initialize the pool. Represented as square root price in\n     *              Q64.64 notation. */\n    function initPool (bytes calldata cmd) private {\n        (, address base, address quote, uint256 poolIdx, uint128 price) =\n            abi.decode(cmd, (uint8, address,address,uint256,uint128));\n\n        (PoolSpecs.PoolCursor memory pool, uint128 initLiq) =\n            registerPool(base, quote, poolIdx);\n                                                   \n        verifyPermitInit(pool, base, quote, poolIdx);\n        \n        (int128 baseFlow, int128 quoteFlow) = initCurve(pool, price, initLiq);\n        settleInitFlow(lockHolder_, base, baseFlow, quote, quoteFlow);\n    }\n\n    /* @notice Disables an existing pool template. Any previously instantiated pools on\n     *         this template will continue exist, but calling this will prevent any new\n     *         pools from being created on this template. */\n    function disableTemplate (bytes calldata input) private {\n        (, uint256 poolIdx) = abi.decode(input, (uint8, uint256));\n        emit SdexEvents.DisablePoolTemplate(poolIdx);\n        disablePoolTemplate(poolIdx);\n    }\n    \n    /* @notice Sets template parameters for a pool type index.\n     * @param poolIdx The index of the pool type.\n     * @param feeRate The pool's swap fee rate in multiples of 0.0001%\n     * @param tickSize The pool's grid size in ticks.\n     * @param jitThresh The minimum resting time (in seconds) for concentrated LPs.\n     * @param knockout The knockout bits for the pool template.\n     @ @param oracleFlags The oracle bit flags if a permissioned pool. */\n    function setTemplate (bytes calldata input) private {\n        (, uint256 poolIdx, uint16 feeRate, uint16 tickSize, uint8 jitThresh,\n         uint8 knockout, uint8 oracleFlags) =\n            abi.decode(input, (uint8, uint256, uint16, uint16, uint8, uint8, uint8));\n        \n        emit SdexEvents.SetPoolTemplate(poolIdx, feeRate, tickSize, jitThresh, knockout,\n                                        oracleFlags);\n        setPoolTemplate(poolIdx, feeRate, tickSize, jitThresh, knockout, oracleFlags);\n    }\n\n    function setTakeRate (bytes calldata input) private {\n        (, uint8 takeRate) = \n            abi.decode(input, (uint8, uint8));\n        \n        emit SdexEvents.SetTakeRate(takeRate);\n        setProtocolTakeRate(takeRate);\n    }\n\n    function setRelayerTakeRate (bytes calldata input) private {\n        (, uint8 takeRate) = \n            abi.decode(input, (uint8, uint8));\n\n        emit SdexEvents.SetRelayerTakeRate(takeRate);\n        setRelayerTakeRate(takeRate);\n    }\n\n    function setNewPoolLiq (bytes calldata input) private {\n        (, uint128 liq) = \n            abi.decode(input, (uint8, uint128));\n        \n        emit SdexEvents.SetNewPoolLiq(liq);\n        setNewPoolLiq(liq);\n    }\n\n    function resyncTakeRate (bytes calldata input) private {\n        (, address base, address quote, uint256 poolIdx) = \n            abi.decode(input, (uint8, address, address, uint256));\n        \n        emit SdexEvents.ResyncTakeRate(base, quote, poolIdx, protocolTakeRate_);\n        resyncProtocolTake(base, quote, poolIdx);\n    }\n\n    /* @notice Update parameters for a pre-existing pool.\n     * @param base The base-side token defining the pool's pair.\n     * @param quote The quote-side token defining the pool's pair.\n     * @param poolIdx The index of the pool type.\n     * @param feeRate The pool's swap fee rate in multiples of 0.0001%\n     * @param tickSize The pool's grid size in ticks.\n     * @param jitThresh The minimum resting time (in seconds) for concentrated LPs in\n     *                  in the pool.\n     * @param knockout The knockout bit flags for the pool. */\n    function revisePool (bytes calldata cmd) private {\n        (, address base, address quote, uint256 poolIdx,\n         uint16 feeRate, uint16 tickSize, uint8 jitThresh, uint8 knockout) =\n            abi.decode(cmd, (uint8,address,address,uint256,uint16,uint16,uint8,uint8));\n        setPoolSpecs(base, quote, poolIdx, feeRate, tickSize, jitThresh, knockout);\n    }\n\n    /* @notice Set off-grid price improvement.\n     * @param token The token the settings apply to.\n     * @param unitTickCollateral The collateral threshold for off-grid price improvement.\n     * @param awayTickTol The maximum tick distance from current price that off-grid\n     *                    quotes are allowed for. */\n    function pegPriceImprove (bytes calldata cmd) private {\n        (, address token, uint128 unitTickCollateral, uint16 awayTickTol) =\n            abi.decode(cmd, (uint8, address, uint128, uint16));\n        emit SdexEvents.PriceImproveThresh(token, unitTickCollateral, awayTickTol);\n        setPriceImprove(token, unitTickCollateral, awayTickTol);\n    }\n\n    function setHotPathOpen (bytes calldata cmd) private {\n        (, bool open) = abi.decode(cmd, (uint8, bool));\n        emit SdexEvents.HotPathOpen(open);\n        hotPathOpen_ = open;        \n    }\n\n    function setSafeMode (bytes calldata cmd) private {\n        (, bool inSafeMode) = abi.decode(cmd, (uint8, bool));\n        emit SdexEvents.SafeMode(inSafeMode);\n        inSafeMode_ = inSafeMode;        \n    }\n\n    /* @notice Pays out the the protocol fees.\n     * @param token The token for which the accumulated fees are being paid out. \n     *              (Or if 0x0 pays out native Ethereum.) */\n    function collectProtocol (bytes calldata cmd) private {\n        (, address token) = abi.decode(cmd, (uint8, address));\n\n        require(block.timestamp >= treasuryStartTime_, \"Treasury start\");\n        emit SdexEvents.ProtocolDividend(token, treasury_);\n        disburseProtocolFees(treasury_, token);\n    }\n\n    /* @notice Sets the treasury address to receive protocol fees. Once set, the treasury cannot\n     *         receive fees until 7 days after. */\n    function setTreasury (bytes calldata cmd) private {\n        (, address treasury) = abi.decode(cmd, (uint8, address));\n\n        require(treasury != address(0) && treasury.code.length != 0, \"Treasury invalid\");\n        treasury_ = treasury;\n        treasuryStartTime_ = uint64(block.timestamp + 7 days);\n        emit SdexEvents.TreasurySet(treasury_, treasuryStartTime_);\n    }\n\n    function transferAuthority (bytes calldata cmd) private {\n        (, address auth) =\n            abi.decode(cmd, (uint8, address));\n\n        require(auth != address(0) && auth.code.length > 0 && \n            ISdexMaster(auth).acceptsSdexAuthority(), \"Invalid Authority\");\n        \n        emit SdexEvents.AuthorityTransfer(authority_);\n        authority_ = auth;\n    }\n\n    /* @notice Used to directly pay out or pay in surplus collateral.\n     * @param recv The address where the funds are paid to (only applies if surplus was\n     *             paid out.)\n     * @param value The amount of surplus collateral being paid or received. If negative\n     *              paid from the user into the pool, increasing their balance.\n     * @param token The token to which the surplus collateral is applied. (If 0x0, then\n     *              native Ethereum) */\n    function depositSurplus (bytes calldata cmd) private {\n        (, address recv, uint128 value, address token) =\n            abi.decode(cmd, (uint8, address, uint128, address));\n        depositSurplus(recv, value, token);\n    }\n\n    function depositPermit (bytes calldata cmd) private {\n        (, address recv, uint128 value, address token, uint256 deadline,\n         uint8 v, bytes32 r, bytes32 s) =\n            abi.decode(cmd, (uint8, address, uint128, address, uint256,\n                             uint8, bytes32, bytes32));\n        depositSurplusPermit(recv, value, token, deadline, v, r, s);\n    }\n\n    function disburseSurplus (bytes calldata cmd) private {\n        (, address recv, int128 value, address token) =\n            abi.decode(cmd, (uint8, address, int128, address));\n        disburseSurplus(recv, value, token);\n    }\n\n    function transferSurplus (bytes calldata cmd) private {\n        (, address recv, int128 size, address token) =\n            abi.decode(cmd, (uint8, address, int128, address));\n        transferSurplus(recv, size, token);\n    }\n\n    function sidePocketSurplus (bytes calldata cmd) private {\n        (, uint256 fromSalt, uint256 toSalt, int128 value, address token) =\n            abi.decode(cmd, (uint8, uint256, uint256, int128, address));\n        sidePocketSurplus(fromSalt, toSalt, value, token);\n    }\n\n    function resetNonce (bytes calldata cmd) private {\n        (, bytes32 salt, uint32 nonce) = \n            abi.decode(cmd, (uint8, bytes32, uint32));\n        resetNonce(salt, nonce);\n    }\n    \n    function resetNonceCond (bytes calldata cmd) private {\n        (, bytes32 salt, uint32 nonce, address oracle, bytes memory args) = \n            abi.decode(cmd, (uint8,bytes32,uint32,address,bytes));\n        resetNonceCond(salt, nonce, oracle, args);\n    }\n\n    function checkGateOracle (bytes calldata cmd) private {\n        (, address oracle, bytes memory args) = \n            abi.decode(cmd, (uint8,address,bytes));\n        checkGateOracle(oracle, args);\n    }\n\n    /* @notice Called by a user to give permissions to an external smart contract router.\n     * @param router The address of the external smart contract that the user is giving\n     *                permission to.\n     * @param nCalls The number of calls the router agent is approved for.\n     * @param callpaths The proxy sidecar indexes the router is approved for */\n    function approveRouter (bytes calldata cmd) private {\n        (, address router, uint32 nCalls, uint16[] memory callpaths) =\n            abi.decode(cmd, (uint8, address, uint32, uint16[]));\n\n        for (uint i = 0; i < callpaths.length; ++i) {\n            require(callpaths[i] != SdexSlots.COLD_PROXY_IDX, \"Invalid Router Approve\");\n            approveAgent(router, nCalls, callpaths[i]);\n        }\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Sdex sidecar proxy and used\n     *         in the correct slot. */\n    function acceptSdexProxyRole (address, uint16 slot) public virtual returns (bool) {\n        return slot == SdexSlots.COLD_PROXY_IDX;\n    }\n}\n\n"
    },
    "contracts/callpaths/HotPath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport '../libraries/Directives.sol';\nimport '../libraries/Encoding.sol';\nimport '../libraries/TokenFlow.sol';\nimport '../libraries/PriceGrid.sol';\nimport '../mixins/MarketSequencer.sol';\nimport '../mixins/SettleLayer.sol';\nimport '../mixins/PoolRegistry.sol';\nimport '../mixins/MarketSequencer.sol';\nimport '../mixins/ProtocolAccount.sol';\nimport '../SdexEvents.sol';\n\n/* @title Hot path mixin.\n * @notice Provides the top-level function for the most common operation: simple one-hop\n *         swap on a single pool in the most gas optimized way. Unlike the other call \n *         paths this should be imported directly into the main contract.\n * \n * @dev    Unlike the other callpath sidecars this contains the most gas sensitive and\n *         common operation: a simple swap. We want to keep this the lowest gas spend\n *         possible, and therefore avoid an external DELEGATECALL. Therefore this logic\n *         is inherited both directly by the main contract (allowing for low gas calls)\n *         as well as an explicit proxy contract (allowing for future upgradeability)\n *         which can be utilized through a different call path. */\ncontract HotPath is MarketSequencer, SettleLayer, ProtocolAccount {\n    using SafeCast for uint128;\n    using TokenFlow for TokenFlow.PairSeq;\n    using CurveMath for CurveMath.CurveState;\n    using Chaining for Chaining.PairFlow;\n\n\n    /* @notice Executes a swap on an arbitrary pool. */\n    function swapExecute (address base, address quote,\n                          uint256 poolIdx, bool isBuy, bool inBaseQty, uint128 qty,\n                          uint16 poolTip, uint128 limitPrice, uint128 minOutput,\n                          uint8 reserveFlags) internal\n        returns (int128 baseFlow, int128 quoteFlow) {\n        \n        PoolSpecs.PoolCursor memory pool = preparePoolCntx\n            (base, quote, poolIdx, poolTip, isBuy, inBaseQty, qty);\n\n        Chaining.PairFlow memory flow = swapDir(pool, isBuy, inBaseQty, qty, limitPrice);\n        (baseFlow, quoteFlow) = (flow.baseFlow_, flow.quoteFlow_);\n\n        pivotOutFlow(flow, minOutput, isBuy, inBaseQty);        \n        settleFlows(base, quote, flow.baseFlow_, flow.quoteFlow_, reserveFlags);\n        accumProtocolFees(flow, base, quote);\n    }\n\n    /* @notice Final check at swap completion to verify that the non-fixed side of the \n     *         swap meets the user's minimum execution standards: minimum floor if output,\n     *         maximum ceiling if input. \n     * @param flow The resulting final token flows from the swap\n     * @param minOutput The minimum output (if sell-side token is fixed) *or* maximum inout\n     *                  (if buy-side token is fixed)\n     * @param isBuy  If true indicates the swap was a buy, i.e. paid base tokens to receive\n     *               quote tokens\n     * @param inBaseQty If true indicates the base-side was the fixed leg of the swap.\n     * @return outFlow Returns the non-fixed side of the swap flow. */\n    function pivotOutFlow (Chaining.PairFlow memory flow, uint128 minOutput,\n                           bool isBuy, bool inBaseQty) private pure\n        returns (int128 outFlow) {\n        outFlow = inBaseQty ? flow.quoteFlow_ : flow.baseFlow_;\n        bool isOutPaid = (isBuy == inBaseQty);\n        int128 thresh = isOutPaid ? -int128(minOutput) : int128(minOutput);\n        require(outFlow <= thresh || minOutput == 0, \"SL\");\n    }\n\n    /* @notice Wrapper call to setup the swap directive object and call the swap logic in\n     *         the MarketSequencer mixin. */\n    function swapDir (PoolSpecs.PoolCursor memory pool, bool isBuy,\n                      bool inBaseQty, uint128 qty, uint128 limitPrice) private\n        returns (Chaining.PairFlow memory) {\n        Directives.SwapDirective memory dir;\n        dir.isBuy_ = isBuy;\n        dir.inBaseQty_ = inBaseQty;\n        dir.qty_ = qty;\n        dir.limitPrice_ = limitPrice;\n        dir.rollType_ = 0;\n        return swapOverPool(dir, pool);\n        \n    }\n\n    /* @notice Given a pair and pool type index queries and returns the current specs for\n     *         that pool. And if permissioned pool, checks against the permit oracle, \n     *         adjusting fee if necessary. */\n    function preparePoolCntx (address base, address quote,\n                              uint256 poolIdx, uint16 poolTip,\n                              bool isBuy, bool inBaseQty, uint128 qty) private\n        returns (PoolSpecs.PoolCursor memory) {\n        PoolSpecs.PoolCursor memory pool = queryPool(base, quote, poolIdx);\n        if (poolTip > pool.head_.feeRate_) {\n            pool.head_.feeRate_ = poolTip;\n        }\n        verifyPermitSwap(pool, base, quote, isBuy, inBaseQty, qty);\n        return pool;\n    }\n\n    /* @notice Syntatic sugar that wraps a swapExecute call with an ABI encoded version of\n     *         the arguments. */\n    function swapEncoded (bytes calldata input) internal returns\n        (int128 baseFlow, int128 quoteFlow) {\n        (address base, address quote,\n         uint256 poolIdx, bool isBuy, bool inBaseQty, uint128 qty, uint16 poolTip,\n         uint128 limitPrice, uint128 minOutput, uint8 reserveFlags) =\n            abi.decode(input, (address, address, uint256, bool, bool,\n                               uint128, uint16, uint128, uint128, uint8));\n        \n        return swapExecuteLogged(base, quote, poolIdx, isBuy, inBaseQty, qty, poolTip,\n            limitPrice, minOutput, reserveFlags);\n    }\n\n    /* @notice Wraps a swap call with a log event. */\n    function swapExecuteLogged (address base, address quote,\n                          uint256 poolIdx, bool isBuy, bool inBaseQty, uint128 qty,\n                          uint16 poolTip, uint128 limitPrice, uint128 minOutput,\n                          uint8 reserveFlags) internal\n        returns (int128 baseFlow, int128 quoteFlow) {\n\n        (baseFlow, quoteFlow) = swapExecute(base, quote, poolIdx, isBuy, inBaseQty, qty, poolTip, \n            limitPrice, minOutput, reserveFlags);\n\n        emit SdexEvents.SdexSwap(base, quote, poolIdx, isBuy, inBaseQty, qty, poolTip, limitPrice, \n            minOutput, reserveFlags, baseFlow, quoteFlow);\n    }\n}\n\n/* @title Hot path proxy contract\n * @notice The version of the HotPath in a standalone sidecar proxy contract. If used\n *         this contract would be attached to hotProxy_ in the main dex contract. */\ncontract HotProxy is HotPath {\n\n    function userCmd (bytes calldata input) public payable\n        returns (int128 baseFlow, int128 quoteFlow) {\n        return swapEncoded(input);\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Sdex sidecar proxy and used\n     *         in the correct slot. */\n    function acceptSdexProxyRole (address, uint16 slot) public pure returns (bool) {\n        return slot == SdexSlots.SWAP_PROXY_IDX;\n    }\n\n}\n\n\n"
    },
    "contracts/callpaths/KnockoutPath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport '../libraries/Directives.sol';\nimport '../libraries/Encoding.sol';\nimport '../libraries/TokenFlow.sol';\nimport '../libraries/PriceGrid.sol';\nimport '../libraries/ProtocolCmd.sol';\nimport '../mixins/SettleLayer.sol';\nimport '../mixins/PoolRegistry.sol';\nimport '../mixins/TradeMatcher.sol';\nimport '../SdexEvents.sol';\n\n/* @title Knockout Flag Proxy\n * @notice This is an internal library callpath that's called when a swap triggers a \n *         knockout liquidity event by crossing a given bump point. \n * @dev It exists as a separate callpath from the normal swap() code path because crossing\n *      a knockout pivot is a relatively rare event and the code won't fully fit into the\n *      hot path contract. */\ncontract KnockoutFlagPath is KnockoutCounter {\n\n    /* @notice Called when a knockout pivot is crossed.\n     *\n     * @dev Since this contract is a proxy sidecar, this method needs to be marked\n     *      payable even though it doesn't directly handle msg.value. Otherwise it will\n     *      fail on any. Because of this, this contract should never be used in any other\n     *      context besides a proxy sidecar to SdexSwapDex.\n     *\n     * @param pool The hash index of the pool.\n     * @param tick The 24-bit index of the tick where the knockout pivot exists.\n     * @param isBuy If true indicates that the swap direction is a buy.\n     * @param feeGlobal The global fee odometer for 1 hypothetical unit of liquidity fully\n     *                  in range since the inception of the pool.\n     *\n     * @return Returns the net additional amount the curve liquidity should be adjusted by.\n     *         Currently this always returns zero, because a liquidity knockout will never change\n     *         active liquidity on a curve. But by leaving this function return type it leaves open\n     *         the possibility in future upgrades of alternative types of dynamic liquidity that \n     *         do change active curve liquidity when crossed */\n    function crossCurveFlag (bytes32 pool, int24 tick, bool isBuy, uint64 feeGlobal)\n        public payable returns (int128) {\n        // If swap is a sell, then implies we're crossing a resting bid and vice versa\n        bool bidCross = !isBuy;\n        crossKnockout(pool, bidCross, tick, feeGlobal);\n        return 0;\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Sdex sidecar proxy and used\n     *         in the correct slot. */\n    function acceptSdexProxyRole (address, uint16 slot) public pure returns (bool) {\n        return slot == SdexSlots.FLAG_CROSS_PROXY_IDX;\n    }\n\n}\n\n/* @title Knockout Liquidity Proxy\n * @notice This callpath is a single point of entry for all LP operations related to \n *         resting knockout liquidity. Including minting, burning, claiming, and \n *         recovering a user's posted knockout liquidity. */\ncontract KnockoutLiqPath is TradeMatcher, SettleLayer {\n    using SafeCast for uint128;\n    using TickMath for uint128;\n    using TokenFlow for TokenFlow.PairSeq;\n    using CurveMath for CurveMath.CurveState;\n    using Chaining for Chaining.PairFlow;\n    using KnockoutLiq for KnockoutLiq.KnockoutPosLoc;\n\n    function userCmd (bytes calldata cmd) public payable returns\n        (int128 baseFlow, int128 quoteFlow) {\n        (baseFlow, quoteFlow) = innerCmd(cmd);\n        emit SdexEvents.SdexKnockoutCmd(cmd, baseFlow, quoteFlow);\n    }\n\n    function innerCmd (bytes calldata cmd) private returns (int128, int128) {\n        (uint8 code, address base, address quote, uint256 poolIdx,\n         int24 bidTick, int24 askTick, bool isBid, uint8 reserveFlags,\n         bytes memory args) = abi.decode\n            (cmd, (uint8, address, address, uint256, int24, int24, bool, uint8, bytes));\n\n        PoolSpecs.PoolCursor memory pool = queryPool(base, quote, poolIdx);\n        CurveMath.CurveState memory curve = snapCurve(pool.hash_);\n\n        KnockoutLiq.KnockoutPosLoc memory loc;\n        loc.isBid_ = isBid;\n        loc.lowerTick_ = bidTick;\n        loc.upperTick_ = askTick;\n\n        return overCurve(code, base, quote, pool, curve, loc, reserveFlags, args);\n    }\n\n    /* @notice Converts a call code, pool address, curvedata and knockout position \n     *         location to execute a knockout LP command. */\n    function overCurve (uint8 code, address base, address quote,\n                        PoolSpecs.PoolCursor memory pool,\n                        CurveMath.CurveState memory curve,\n                        KnockoutLiq.KnockoutPosLoc memory loc,\n                        uint8 reserveFlags, bytes memory args)\n        private returns (int128 baseFlow, int128 quoteFlow) {        \n        if (code == UserCmd.MINT_KNOCKOUT) {\n            (baseFlow, quoteFlow) = mintCmd(base, quote, pool, curve, loc, args);\n        } else if (code == UserCmd.BURN_KNOCKOUT) {\n            (baseFlow, quoteFlow) = burnCmd(base, quote, pool, curve, loc, args);\n        } else if (code == UserCmd.CLAIM_KNOCKOUT) {\n            (baseFlow, quoteFlow) = claimCmd(pool.hash_, curve, loc, args);\n        } else if (code == UserCmd.RECOVER_KNOCKOUT) {\n            (baseFlow, quoteFlow) = recoverCmd(pool.hash_, loc, args);\n        } else {\n            revert(\"Invalid command\");\n        }\n\n        settleFlows(base, quote, baseFlow, quoteFlow, reserveFlags);\n    }\n\n    /* @notice Mints new passive knockout liquidity. */\n    function mintCmd (address base, address quote, PoolSpecs.PoolCursor memory pool,\n                      CurveMath.CurveState memory curve,\n                      KnockoutLiq.KnockoutPosLoc memory loc,\n                      bytes memory args) private returns\n        (int128 baseFlow, int128 quoteFlow) {\n        (uint128 qty, bool insideMid) = abi.decode(args, (uint128,bool));\n        \n        int24 priceTick = curve.priceRoot_.getTickAtSqrtRatio();\n        require(loc.spreadOkay(priceTick, insideMid), \"KL\");\n\n        uint128 liq = Chaining.sizeConcLiq(qty, true, curve.priceRoot_,\n                                           loc.lowerTick_, loc.upperTick_, loc.isBid_);\n        verifyPermitMint(pool, base, quote, loc.lowerTick_, loc.upperTick_, liq);\n\n        (baseFlow, quoteFlow) = mintKnockout(curve, priceTick, loc, liq, pool.hash_,\n                                             pool.head_.knockoutBits_);\n        commitCurve(pool.hash_, curve);\n        (baseFlow, quoteFlow) = Chaining.pinFlow(baseFlow, quoteFlow, qty, loc.isBid_);\n    }\n\n    /* @notice Burns previously minted knockout liquidity, but only applicable to the\n     *         extent that the position hasn't been fully knocked out. */\n    function burnCmd (address base, address quote, PoolSpecs.PoolCursor memory pool,\n                      CurveMath.CurveState memory curve,\n                      KnockoutLiq.KnockoutPosLoc memory loc,\n                      bytes memory args) private returns\n        (int128 baseFlow, int128 quoteFlow) {\n        (uint128 qty, bool inLiqQty, bool insideMid) =\n            abi.decode(args, (uint128,bool,bool));\n\n        int24 priceTick = curve.priceRoot_.getTickAtSqrtRatio();\n        require(loc.spreadOkay(priceTick, insideMid), \"KL\");\n\n        uint128 liq = inLiqQty ? qty :\n            Chaining.sizeConcLiq(qty, false, curve.priceRoot_,\n                                 loc.lowerTick_, loc.upperTick_, loc.isBid_);        \n        verifyPermitBurn(pool, base, quote, loc.lowerTick_, loc.upperTick_, liq);\n\n        (baseFlow, quoteFlow) = burnKnockout(curve, priceTick, loc, liq, pool.hash_);\n        commitCurve(pool.hash_, curve);\n    }\n\n    /* @notice Claims a knockout liquidity position that has been fully knocked out, \n     *         including the earned liquidity fees. \n     * @param pool The pool index.\n     * @param curve The current state of the AMM curve.\n     * @param loc The location the knockout liquidity is being claimed from\n     * @params args Corresponds to the Merkle proof for the knockout point ABI encoded\n     *              into two components:\n     *                 root - The current root of the Merkle chain for the pivot location\n     *                 proof - The accumulated links in the Merkle chain going back to the\n     *                         point the user's pivot was knocked out. */\n    function claimCmd (bytes32 pool, CurveMath.CurveState memory curve,\n                       KnockoutLiq.KnockoutPosLoc memory loc,\n                       bytes memory args) private returns\n        (int128 baseFlow, int128 quoteFlow) {\n        (uint160 root, uint256[] memory proof) = abi.decode(args, (uint160,uint256[]));\n\n        // No permit check because permit oracles do not control knockout claims\n        // (See ISdexPermitOracle for more information)\n        (baseFlow, quoteFlow) = claimKnockout(curve, loc, root, proof, pool);\n        commitCurve(pool, curve);\n    }\n    \n    /* @notice Like claim, but ignores the Merkle proof (either because the user wants to\n     *         avoid the gas cost or isn't bothered to recover the history). This results\n     *         in the earned liquidity fees being forfeit, but the user still recovers the\n     *         full principal of the underlying order.\n     *\n     * @param pool The pool index.\n     * @param loc The location the knockout liquidity is being claimed from\n     * @params args Corresponds to a flat ABI encoding of the pivot's origin in block \n     *              time. \n     * @return baseFlow The total base token flow from the pool to the user\n     * @return quoteFlow The total base token flow from the pool to the user */\n    function recoverCmd (bytes32 pool, KnockoutLiq.KnockoutPosLoc memory loc,\n                         bytes memory args) private returns\n        (int128 baseFlow, int128 quoteFlow) {\n        (uint32 pivotTime) = abi.decode(args, (uint32));\n        \n        // No permit check because permit oracles do not control knockout claims\n        // (See ISdexPermitOracle for more information)\n\n        (baseFlow, quoteFlow) = recoverKnockout(loc, pivotTime, pool);\n        // No need to commit curve because recover doesn't touch curve.\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Sdex sidecar proxy and used\n     *         in the correct slot. */\n    function acceptSdexProxyRole (address, uint16 slot) public pure returns (bool) {\n        return slot == SdexSlots.KNOCKOUT_LP_PROXY_IDX;\n    }\n\n}\n"
    },
    "contracts/callpaths/LongPath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport '../libraries/Directives.sol';\nimport '../libraries/Encoding.sol';\nimport '../libraries/TokenFlow.sol';\nimport '../libraries/PriceGrid.sol';\nimport '../mixins/MarketSequencer.sol';\nimport '../mixins/SettleLayer.sol';\nimport '../mixins/PoolRegistry.sol';\nimport '../mixins/ProtocolAccount.sol';\nimport '../mixins/StorageLayout.sol';\n\n/* @title Long path callpath sidecar.\n * @notice Defines a proxy sidecar contract that's used to move code outside the \n *         main contract to avoid Ethereum's contract code size limit. Contains\n *         top-level logic for parsing and executing arbitrarily long compound orders.\n * \n * @dev    This exists as a standalone contract but will only ever contain proxy code,\n *         not state. As such it should never be called directly or externally, and should\n *         only be invoked with DELEGATECALL so that it operates on the contract state\n *         within the primary SdexSwap contract. */\ncontract LongPath is MarketSequencer, SettleLayer, ProtocolAccount {\n    \n    using SafeCast for uint128;\n    using TokenFlow for TokenFlow.PairSeq;\n    using CurveMath for CurveMath.CurveState;\n    using Chaining for Chaining.PairFlow;\n\n    /* @notice Executes the user-defined compound order, constitutiin an arbitrary\n     *         combination of mints, burns and swaps across an arbitrary set of pools\n     *         across an arbitrary set of pairs.\n     *\n     * @param input  The encoded byte data associated with the user's order directive. See\n     *               Encoding.sol and Directives.sol library for information on how to encode\n     *               order directives as byte data. \n     * @return The signed token flows associated with each successive token leg in the flows.\n     *         Negative indicates pool is paying user, positive pool is collecting from user. */\n    function userCmd (bytes calldata input) public payable returns (int128[] memory) {\n        Directives.OrderDirective memory order = OrderEncoding.decodeOrder(input);\n        Directives.SettlementChannel memory settleChannel = order.open_;\n        TokenFlow.PairSeq memory pairs;\n        Chaining.ExecCntx memory cntx;\n        int128[] memory flows = new int128[](order.hops_.length+1); \n\n        for (uint i = 0; i < order.hops_.length; ++i) {\n            pairs.nextHop(settleChannel.token_, order.hops_[i].settle_.token_);\n            cntx.improve_ = queryPriceImprove(order.hops_[i].improve_,\n                                              pairs.baseToken_, pairs.quoteToken_);\n\n            for (uint j = 0; j < order.hops_[i].pools_.length; ++j) {\n                Directives.PoolDirective memory dir = order.hops_[i].pools_[j];\n                cntx.pool_ = queryPool(pairs.baseToken_, pairs.quoteToken_,\n                                       dir.poolIdx_);\n\n                verifyPermit(cntx.pool_, pairs.baseToken_, pairs.quoteToken_,\n                             dir.ambient_, dir.swap_, dir.conc_);\n                cntx.roll_ = targetRoll(dir.chain_, pairs);\n\n                tradeOverPool(pairs.flow_, dir, cntx);\n            }\n\n            accumProtocolFees(pairs); // Make sure to call before clipping              \n            flows[i] = pairs.clipFlow();\n            settleChannel = order.hops_[i].settle_;\n        }\n\n        flows[order.hops_.length] = pairs.closeFlow();\n        settleFlows(order, flows);\n        return flows;\n    }\n\n    function settleFlows (Directives.OrderDirective memory order, int128[] memory flows) internal {\n        Directives.SettlementChannel memory settleChannel = order.open_;\n        int128 ethFlow = 0;\n\n        for (uint i = 0; i < order.hops_.length; ++i) {\n            ethFlow += settleLeg(flows[i], settleChannel);\n            settleChannel = order.hops_[i].settle_;\n        }\n        settleFinal(flows[order.hops_.length], settleChannel, ethFlow);\n    }\n\n    /* @notice Sets the roll target parameters based on the user's directive and the\n     *         previously accumulated flow on the pair.\n     * @param flags The user specified chaining directive for this pair.\n     * @param pair The hitherto accumulated flows on the pair. \n     * @return roll The rolling back fill context to be used in any back-fill quantity. */\n    function targetRoll (Directives.ChainingFlags memory flags,\n                         TokenFlow.PairSeq memory pair) view private\n        returns (Chaining.RollTarget memory roll) {\n        if (flags.rollExit_) {\n            roll.inBaseQty_ = !pair.isBaseFront_;\n            roll.prePairBal_ = 0;\n        } else {\n            roll.inBaseQty_ = pair.isBaseFront_;\n            roll.prePairBal_ = pair.legFlow_;\n        }\n\n        if (flags.offsetSurplus_) {\n            address token = flags.rollExit_ ?\n                pair.backToken() : pair.frontToken();\n            roll.prePairBal_ -= querySurplus(lockHolder_, token).toInt128Sign();\n        }\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Sdex sidecar proxy and used\n     *         in the correct slot. */\n    function acceptSdexProxyRole (address, uint16 slot) public pure returns (bool) {\n        return slot == SdexSlots.LONG_PROXY_IDX;\n    }\n}\n"
    },
    "contracts/callpaths/MicroPaths.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport '../libraries/Directives.sol';\nimport '../libraries/Encoding.sol';\nimport '../libraries/TokenFlow.sol';\nimport '../libraries/PriceGrid.sol';\nimport '../libraries/Chaining.sol';\nimport '../mixins/SettleLayer.sol';\nimport '../mixins/PoolRegistry.sol';\nimport '../mixins/MarketSequencer.sol';\nimport '../mixins/StorageLayout.sol';\nimport '../SdexEvents.sol';\n\n/* @title Micro paths callpath sidecar.\n * @notice Defines a proxy sidecar contract that's used to move code outside the \n *         main contract to avoid Ethereum's contract code size limit. Contains\n *         mid-level components related to single atomic actions to be called within the\n *         context of a longer compound action on a pre-loaded pool's liquidity curve.\n * \n * @dev    This exists as a standalone contract but will only ever contain proxy code,\n *         not state. As such it should never be called directly or externally, and should\n *         only be invoked with DELEGATECALL so that it operates on the contract state\n *         within the primary SdexSwap contract. */\ncontract MicroPaths is MarketSequencer {\n\n    /* @notice Burns liquidity on a concentrated range position within a single curve.\n     *\n     * @param price The price of the curve. Represented as the square root of the exchange\n     *              rate in Q64.64 fixed point\n     * @param priceTick The price tick index of the current price of the curve\n     * @param seed The ambient liquidity seeds in the current curve.\n     * @param conc The active in-range concentrated liquidity in the current curve.\n     * @param seedGrowth The cumulative ambient seed deflator in the current curve.\n     * @param concGrowth The cumulative concentrated reward growth on the current curve.\n     * @param lowTick The price tick index of the lower barrier.\n     * @param highTick The price tick index of the upper barrier.\n     * @param liq The amount of liquidity to burn.\n     * @param poolHash The key hash of the pool the curve belongs to.\n     *\n     * @return baseFlow The user<->pool flow on the base-side token associated with the \n     *                  action. Negative implies flow from the pool to the user. Positive\n     *                  vice versa.\n     * @return quoteFlow The user<->pool flow on the quote-side token associated with the \n     *                   action. \n     * @return seedOut The updated ambient seed liquidity on the curve.\n     * @return concOut The updated concentrated liquidity on the curve. */     \n    function burnRange (uint128 price, int24 priceTick, uint128 seed, uint128 conc,\n                        uint64 seedGrowth, uint64 concGrowth,\n                        int24 lowTick, int24 highTick, uint128 liq, bytes32 poolHash)\n        public payable returns (int128 baseFlow, int128 quoteFlow,\n                        uint128 seedOut, uint128 concOut) {\n        CurveMath.CurveState memory curve;\n        curve.priceRoot_ = price;\n        curve.ambientSeeds_ = seed;\n        curve.concLiq_ = conc;\n        curve.seedDeflator_ = seedGrowth;\n        curve.concGrowth_ = concGrowth;\n        \n        (baseFlow, quoteFlow) = burnRange(curve, priceTick, lowTick, highTick,\n                                          liq, poolHash, lockHolder_);\n\n        concOut = curve.concLiq_;\n        seedOut = curve.ambientSeeds_;\n\n        emit SdexEvents.SdexMicroBurnRange\n            (abi.encode(price, priceTick, seed, conc, seedGrowth, concGrowth,\n                        lowTick, highTick, liq, poolHash), \n            abi.encode(baseFlow, quoteFlow, concOut, seedOut));\n    }\n\n    /* @notice Mints liquidity on a concentrated range position within a single curve.\n     *\n     * @param price The price of the curve. Represented as the square root of the exchange\n     *              rate in Q64.64 fixed point\n     * @param priceTick The price tick index of the current price of the curve\n     * @param seed The ambient liquidity seeds in the current curve.\n     * @param conc The active in-range concentrated liquidity in the current curve.\n     * @param seedGrowth The cumulative ambient seed deflator in the current curve.\n     * @param concGrowth The cumulative concentrated reward growth on the current curve.\n     * @param lowTick The price tick index of the lower barrier.\n     * @param highTick The price tick index of the upper barrier.\n     * @param liq The amount of liquidity to mint.\n     * @param poolHash The key hash of the pool the curve belongs to.\n     *\n     * @return baseFlow The user<->pool flow on the base-side token associated with the \n     *                  action. Negative implies flow from the pool to the user. Positive\n     *                  vice versa.\n     * @return quoteFlow The user<->pool flow on the quote-side token associated with the \n     *                   action. \n     * @return seedOut The updated ambient seed liquidity on the curve.\n     * @return concOut The updated concentrated liquidity on the curve. */         \n    function mintRange (uint128 price, int24 priceTick, uint128 seed, uint128 conc,\n                        uint64 seedGrowth, uint64 concGrowth,\n                        int24 lowTick, int24 highTick, uint128 liq, bytes32 poolHash)\n        public payable returns (int128 baseFlow, int128 quoteFlow,\n                        uint128 seedOut, uint128 concOut) {\n        CurveMath.CurveState memory curve;\n        curve.priceRoot_ = price;\n        curve.ambientSeeds_ = seed;\n        curve.concLiq_ = conc;\n        curve.seedDeflator_ = seedGrowth;\n        curve.concGrowth_ = concGrowth;\n        \n        (baseFlow, quoteFlow) = mintRange(curve, priceTick, lowTick, highTick, liq,\n                                          poolHash, lockHolder_);\n\n        concOut = curve.concLiq_;\n        seedOut = curve.ambientSeeds_;\n\n        emit SdexEvents.SdexMicroMintRange\n            (abi.encode(price, priceTick, seed, conc, seedGrowth, concGrowth,\n                        lowTick, highTick, liq, poolHash), \n            abi.encode(baseFlow, quoteFlow, concOut, seedOut));\n    }\n    \n    /* @notice Burns liquidity from an ambient liquidity position on a single curve.\n     *\n     * @param price The price of the curve. Represented as the square root of the exchange\n     *              rate in Q64.64 fixed point\n     * @param seed The ambient liquidity seeds in the current curve.\n     * @param conc The active in-range concentrated liquidity in the current curve.\n     * @param seedGrowth The cumulative ambient seed deflator in the current curve.\n     * @param concGrowth The cumulative concentrated reward growth on the current curve.\n     * @param liq The amount of liquidity to burn.\n     * @param poolHash The key hash of the pool the curve belongs to.\n     *\n     * @return baseFlow The user<->pool flow on the base-side token associated with the \n     *                  action. Negative implies flow from the pool to the user. Positive\n     *                  vice versa.\n     * @return quoteFlow The user<->pool flow on the quote-side token associated with the \n     *                   action. \n     * @return seedOut The updated ambient seed liquidity on the curve. */     \n    function burnAmbient (uint128 price, uint128 seed, uint128 conc,\n                          uint64 seedGrowth, uint64 concGrowth,\n                          uint128 liq, bytes32 poolHash)\n        public payable returns (int128 baseFlow, int128 quoteFlow, uint128 seedOut) {\n        CurveMath.CurveState memory curve;\n        curve.priceRoot_ = price;\n        curve.ambientSeeds_ = seed;\n        curve.concLiq_ = conc;\n        curve.seedDeflator_ = seedGrowth;\n        curve.concGrowth_ = concGrowth;\n        \n        (baseFlow, quoteFlow) = burnAmbient(curve, liq, poolHash, lockHolder_);\n        \n        seedOut = curve.ambientSeeds_;\n\n        emit SdexEvents.SdexMicroBurnAmbient\n            (abi.encode(price, seed, conc, seedGrowth, concGrowth,\n                        liq, poolHash), \n            abi.encode(baseFlow, quoteFlow, seedOut));\n    }\n\n    /* @notice Mints liquidity from an ambient liquidity position on a single curve.\n     *\n     * @param price The price of the curve. Represented as the square root of the exchange\n     *              rate in Q64.64 fixed point\n     * @param seed The ambient liquidity seeds in the current curve.\n     * @param conc The active in-range concentrated liquidity in the current curve.\n     * @param seedGrowth The cumulative ambient seed deflator in the current curve.\n     * @param concGrowth The cumulative concentrated reward growth on the current curve.\n     * @param liq The amount of liquidity to mint.\n     * @param poolHash The key hash of the pool the curve belongs to.\n     *\n     * @return baseFlow The user<->pool flow on the base-side token associated with the \n     *                  action. Negative implies flow from the pool to the user. Positive\n     *                  vice versa.\n     * @return quoteFlow The user<->pool flow on the quote-side token associated with the \n     *                   action. \n     * @return seedOut The updated ambient seed liquidity on the curve. */         \n    function mintAmbient (uint128 price, uint128 seed, uint128 conc,\n                          uint64 seedGrowth, uint64 concGrowth,\n                          uint128 liq, bytes32 poolHash)\n        public payable returns (int128 baseFlow, int128 quoteFlow, uint128 seedOut) {\n        CurveMath.CurveState memory curve;\n        curve.priceRoot_ = price;\n        curve.ambientSeeds_ = seed;\n        curve.concLiq_ = conc;\n        curve.seedDeflator_ = seedGrowth;\n        curve.concGrowth_ = concGrowth;\n        \n        (baseFlow, quoteFlow) = mintAmbient(curve, liq, poolHash, lockHolder_);\n\n        seedOut = curve.ambientSeeds_;\n\n        emit SdexEvents.SdexMicroMintAmbient\n            (abi.encode(price, seed, conc, seedGrowth, concGrowth,\n                        liq, poolHash), \n            abi.encode(baseFlow, quoteFlow, seedOut));\n    }\n\n    /* @notice Executes a user-directed swap through a single liquidity curve.\n     * \n     * @param curve The current state of the liquidity curve.\n     * @param midTick The tick index of the current price of the curve.\n     * @param swap The parameters of the swap to be executed.\n     * @param pool The pre-loaded specification and hash key of the liquidity curve's\n     *             pool.\n     *\n     * @return accum The accumulated flows on the pair associated with the swap.\n     * @return priceOut The price of the curve after the swap completes. Represented as\n     *                  the square root of the price in Q64.64 fixed point.\n     * @return seedOut The ambient liquidity seeds in the curve after the swap completes\n     * @return concOut The active in-range concentrated liquidity in the curve post-swap\n     * @return ambientOut The cumulative ambient seed deflator on the curve post-swap.\n     * @return concGrowthOut The cumulative concentrated rewards growth on the curve \n     *                       post-swap. */\n    function sweepSwap (CurveMath.CurveState memory curve, int24 midTick,\n                        Directives.SwapDirective memory swap,\n                        PoolSpecs.PoolCursor memory pool)\n        public payable returns (Chaining.PairFlow memory accum,\n                                uint128 priceOut, uint128 seedOut, uint128 concOut,\n                                uint64 ambientOut, uint64 concGrowthOut) {\n        sweepSwapLiq(accum, curve, midTick, swap, pool);\n        \n        priceOut = curve.priceRoot_;\n        seedOut = curve.ambientSeeds_;\n        concOut = curve.concLiq_;\n        ambientOut = curve.seedDeflator_;\n        concGrowthOut = curve.concGrowth_;\n\n        emit SdexEvents.SdexMicroSwap(\n            abi.encode(curve, midTick, swap, pool),\n            abi.encode(accum, priceOut, seedOut, concOut, ambientOut, concGrowthOut));\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Sdex sidecar proxy and used\n     *         in the correct slot. */\n    function acceptSdexProxyRole (address, uint16 slot) public pure returns (bool) {\n        return slot == SdexSlots.MICRO_PROXY_IDX;\n    }\n}\n\n"
    },
    "contracts/callpaths/SafeModePath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport './ColdPath.sol';\n\n/* @title Safe Mode Call Path.\n *\n * @notice Highly restricted callpath meant to be the sole point of entry when the dex\n *         contract has been forced into emergency safe mode. Essentially this retricts \n *         all calls besides sudo mode admin actions. */\ncontract SafeModePath is ColdPath {\n\n    function protocolCmd (bytes calldata cmd) override public {\n        sudoCmd(cmd);\n    }\n\n    function userCmd (bytes calldata) override public payable {\n        revert(\"Emergency Safe Mode\");\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Sdex sidecar proxy and used\n     *         in the correct slot. */\n    function acceptSdexProxyRole (address, uint16 slot) public pure override returns (bool) {\n        return slot == SdexSlots.SAFE_MODE_PROXY_PATH;\n    }\n}\n\n"
    },
    "contracts/callpaths/WarmPath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport '../libraries/Directives.sol';\nimport '../libraries/Encoding.sol';\nimport '../libraries/TokenFlow.sol';\nimport '../libraries/PriceGrid.sol';\nimport '../libraries/ProtocolCmd.sol';\nimport '../mixins/MarketSequencer.sol';\nimport '../mixins/SettleLayer.sol';\nimport '../mixins/PoolRegistry.sol';\nimport '../mixins/MarketSequencer.sol';\nimport '../mixins/ProtocolAccount.sol';\nimport '../SdexEvents.sol';\n\n/* @title Warm path callpath sidecar.\n * @notice Defines a proxy sidecar contract that's used to move code outside the \n *         main contract to avoid Ethereum's contract code size limit. Contains top-\n *         level logic for the core liquidity provider actions:\n *              * Mint ambient liquidity\n *              * Mint concentrated range liquidity\n *              * Burn ambient liquidity\n *              * Burn concentrated range liquidity\n *         These methods are exposed as atomic single-action calls. Useful for traders\n *         who only need to execute a single action, and want to get the lowest gas fee\n *         possible. Compound calls are available in LongPath, but the overhead with\n *         parsing a longer OrderDirective makes the gas cost higher.\n * \n * @dev    This exists as a standalone contract but will only ever contain proxy code,\n *         not state. As such it should never be called directly or externally, and should\n *         only be invoked with DELEGATECALL so that it operates on the contract state\n *         within the primary SdexSwap contract. */\ncontract WarmPath is MarketSequencer, SettleLayer, ProtocolAccount {\n\n    using SafeCast for uint128;\n    using TokenFlow for TokenFlow.PairSeq;\n    using CurveMath for CurveMath.CurveState;\n    using Chaining for Chaining.PairFlow;\n\n    /* @notice Consolidated method for all atomic liquidity provider actions.\n     * @dev    We consolidate multiple call types into a single method to reduce the \n     *         contract size in the main contract by paring down methods.\n     * \n     * @param code The command code corresponding to the actual method being called. */\n    function userCmd (bytes calldata input) public payable returns\n        (int128 baseFlow, int128 quoteFlow) {\n        \n        (uint8 code, address base, address quote, uint256 poolIdx,\n         int24 bidTick, int24 askTick, uint128 liq,\n         uint128 limitLower, uint128 limitHigher,\n         uint8 reserveFlags, address lpConduit) =\n            abi.decode(input, (uint8,address,address,uint256,int24,int24,\n                               uint128,uint128,uint128,uint8,address));\n\n        if (lpConduit == address(0)) { lpConduit = lockHolder_; }\n        \n        (baseFlow, quoteFlow) =\n            commitLP(code, base, quote, poolIdx, bidTick, askTick,\n                     liq, limitLower, limitHigher, lpConduit);\n        settleFlows(base, quote, baseFlow, quoteFlow, reserveFlags);\n\n        emit SdexEvents.SdexWarmCmd(input, baseFlow, quoteFlow);\n    }\n\n    \n    function commitLP (uint8 code, address base, address quote, uint256 poolIdx,\n                       int24 bidTick, int24 askTick, uint128 liq,\n                       uint128 limitLower, uint128 limitHigher,\n                       address lpConduit)\n        private returns (int128, int128) {\n        if (code == UserCmd.MINT_RANGE_LIQ_LP) {\n            return mintConcentratedLiq(base, quote, poolIdx, bidTick, askTick, liq, lpConduit,\n                        limitLower, limitHigher);\n        } else if (code == UserCmd.MINT_RANGE_BASE_LP) {\n            return mintConcentratedQty(base, quote, poolIdx, bidTick, askTick, true, liq, lpConduit,\n                           limitLower, limitHigher);\n        } else if (code == UserCmd.MINT_RANGE_QUOTE_LP) {\n            return mintConcentratedQty(base, quote, poolIdx, bidTick, askTick, false, liq, lpConduit,\n                           limitLower, limitHigher);\n            \n        } else if (code == UserCmd.BURN_RANGE_LIQ_LP) {\n            return burnConcentratedLiq(base, quote, poolIdx, bidTick, askTick, liq, lpConduit,\n                        limitLower, limitHigher);\n        } else if (code == UserCmd.BURN_RANGE_BASE_LP) {\n            return burnConcentratedQty(base, quote, poolIdx, bidTick, askTick, true, liq, lpConduit,\n                           limitLower, limitHigher);\n        } else if (code == UserCmd.BURN_RANGE_QUOTE_LP) {\n            return burnConcentratedQty(base, quote, poolIdx, bidTick, askTick, false, liq, lpConduit,\n                           limitLower, limitHigher);\n            \n        } else if (code == UserCmd.MINT_AMBIENT_LIQ_LP) {\n            return mintAmbientLiq(base, quote, poolIdx, liq, lpConduit, limitLower, limitHigher);\n        } else if (code == UserCmd.MINT_AMBIENT_BASE_LP) {\n            return mintAmbientQty(base, quote, poolIdx, true, liq, lpConduit,\n                           limitLower, limitHigher);\n        } else if (code == UserCmd.MINT_AMBIENT_QUOTE_LP) {\n            return mintAmbientQty(base, quote, poolIdx, false, liq, lpConduit,\n                           limitLower, limitHigher);\n            \n        } else if (code == UserCmd.BURN_AMBIENT_LIQ_LP) {\n            return burnAmbientLiq(base, quote, poolIdx, liq, lpConduit, limitLower, limitHigher);\n        } else if (code == UserCmd.BURN_AMBIENT_BASE_LP) {\n            return burnAmbientQty(base, quote, poolIdx, true, liq, lpConduit,\n                           limitLower, limitHigher);\n        } else if (code == UserCmd.BURN_AMBIENT_QUOTE_LP) {\n            return burnAmbientQty(base, quote, poolIdx, false, liq, lpConduit,\n                           limitLower, limitHigher);\n            \n        } else if (code == UserCmd.HARVEST_LP) {\n            return harvest(base, quote, poolIdx, bidTick, askTick, lpConduit,\n                           limitLower, limitHigher);\n        } else {\n            revert(\"Invalid command\");\n        }\n    }\n\n    /* @notice Mints liquidity as a concentrated liquidity range order.\n     * @param base The base-side token in the pair.\n     * @param quote The quote-side token in the par.\n     * @param poolIdx The index of the pool type being minted on.\n     * @param bidTick The price tick index of the lower boundary of the range order.\n     * @param askTick The price tick index of the upper boundary of the range order.\n     * @param liq The total amount of liquidity being minted. Represented as sqrt(X*Y)\n     *            for the equivalent constant-product AMM.\n     * @param lpConduit The address of the LP conduit to deposit the minted position at\n     *                  (direct owned liquidity if 0)\n     * @param limitLower Exists to make sure the user is happy with the price the \n     *                   liquidity is minted at. Transaction fails if the curve price\n     *                   at call time is below this value.\n     * @param limitUpper Transaction fails if the curve price at call time is above this\n     *                   threshold.  */    \n    function mintConcentratedLiq (address base, address quote, uint256 poolIdx,\n                   int24 bidTick, int24 askTick, uint128 liq, address lpConduit, \n                   uint128 limitLower, uint128 limitHigher) internal returns\n        (int128, int128) {\n        PoolSpecs.PoolCursor memory pool = queryPool(base, quote, poolIdx);\n        verifyPermitMint(pool, base, quote, bidTick, askTick, liq);\n\n        return mintOverPool(bidTick, askTick, liq, pool, limitLower, limitHigher,\n                            lpConduit);\n    }\n    \n    /* @notice Burns liquidity as a concentrated liquidity range order.\n     * @param base The base-side token in the pair.\n     * @param quote The quote-side token in the par.\n     * @param poolIdx The index of the pool type being burned on.\n     * @param bidTick The price tick index of the lower boundary of the range order.\n     * @param askTick The price tick index of the upper boundary of the range order.\n     * @param liq The total amount of liquidity being burned. Represented as sqrt(X*Y)\n     *            for the equivalent constant-product AMM.\n     * @param lpConduit The address of the LP conduit to deposit the minted position at\n     *                  (direct owned liquidity if 0)\n     * @param limitLower Exists to make sure the user is happy with the price the \n     *                   liquidity is burned at. Transaction fails if the curve price\n     *                   at call time is below this value.\n     * @param limitUpper Transaction fails if the curve price at call time is above this\n     *                   threshold. */\n    function burnConcentratedLiq (address base, address quote, uint256 poolIdx,\n                   int24 bidTick, int24 askTick, uint128 liq, address lpConduit, \n                   uint128 limitLower, uint128 limitHigher)\n        internal returns (int128, int128) {\n        PoolSpecs.PoolCursor memory pool = queryPool(base, quote, poolIdx);\n        verifyPermitBurn(pool, base, quote, bidTick, askTick, liq);\n        \n        return burnOverPool(bidTick, askTick, liq, pool, limitLower, limitHigher,\n                            lpConduit);\n    }\n\n    /* @notice Harvests the rewards for a concentrated liquidity position.\n     * @param base The base-side token in the pair.\n     * @param quote The quote-side token in the par.\n     * @param poolIdx The index of the pool type being burned on.\n     * @param bidTick The price tick index of the lower boundary of the range order.\n     * @param askTick The price tick index of the upper boundary of the range order.\n     * @param lpConduit The address of the LP conduit to deposit the minted position at\n     *                  (direct owned liquidity if 0)\n     * @param limitLower Exists to make sure the user is happy with the price the \n     *                   liquidity is burned at. Transaction fails if the curve price\n     *                   at call time is below this value.\n     * @param limitUpper Transaction fails if the curve price at call time is above this\n     *                   threshold. */\n    function harvest (address base, address quote, uint256 poolIdx,\n                      int24 bidTick, int24 askTick, address lpConduit,\n                      uint128 limitLower, uint128 limitHigher)\n        internal returns (int128, int128) {\n        PoolSpecs.PoolCursor memory pool = queryPool(base, quote, poolIdx);\n        \n        // On permissioned pools harvests are treated like a special case burn\n        // with 0 liquidity. Note that unlike a true 0 burn, ambient liquidity will still\n        // be returned, so oracles should handle 0 as special case if that's an issue. \n        verifyPermitBurn(pool, base, quote, bidTick, askTick, 0);\n        \n        return harvestOverPool(bidTick, askTick, pool, limitLower, limitHigher,\n                               lpConduit);\n    }\n\n    /* @notice Mints ambient liquidity that's active at every price.\n     * @param base The base-side token in the pair.\n     * @param quote The quote-side token in the par.\n     * @param poolIdx The index of the pool type being minted on.\n     * @param liq The total amount of liquidity being minted. Represented as sqrt(X*Y)\n     *            for the equivalent constant-product AMM.\n     @ @param lpConduit The address of the LP conduit to deposit the minted position at\n     *                  (direct owned liquidity if 0)\n     * @param limitLower Exists to make sure the user is happy with the price the \n     *                   liquidity is minted at. Transaction fails if the curve price\n     *                   at call time is below this value.\n     * @param limitUpper Transaction fails if the curve price at call time is above this\n     *                   threshold.  */\n    function mintAmbientLiq (address base, address quote, uint256 poolIdx, uint128 liq,\n                   address lpConduit, uint128 limitLower, uint128 limitHigher) internal\n        returns (int128, int128) {\n        PoolSpecs.PoolCursor memory pool = queryPool(base, quote, poolIdx);\n        verifyPermitMint(pool, base, quote, 0, 0, liq);\n        return mintOverPool(liq, pool, limitLower, limitHigher, lpConduit);\n    }\n\n    function mintAmbientQty (address base, address quote, uint256 poolIdx, bool inBase,\n                      uint128 qty, address lpConduit, uint128 limitLower,\n                      uint128 limitHigher) internal\n        returns (int128, int128) {\n        bytes32 poolKey = PoolSpecs.encodeKey(base, quote, poolIdx);\n        CurveMath.CurveState memory curve = snapCurve(poolKey);\n        uint128 liq = Chaining.sizeAmbientLiq(qty, true, curve.priceRoot_, inBase);\n        \n        (int128 baseFlow, int128 quoteFlow) =\n            mintAmbientLiq(base, quote, poolIdx, liq, lpConduit, limitLower, limitHigher);\n        return Chaining.pinFlow(baseFlow, quoteFlow, qty, inBase);\n    }\n\n    function mintConcentratedQty (address base, address quote, uint256 poolIdx,\n                      int24 bidTick, int24 askTick, bool inBase,\n                      uint128 qty, address lpConduit, uint128 limitLower,\n                      uint128 limitHigher) internal\n        returns (int128, int128) {\n        uint128 liq = sizeAddLiq(base, quote, poolIdx, qty, bidTick, askTick, inBase);\n        (int128 baseFlow, int128 quoteFlow) =\n            mintConcentratedLiq(base, quote, poolIdx, bidTick, askTick, liq, lpConduit,\n                 limitLower, limitHigher);\n        return Chaining.pinFlow(baseFlow, quoteFlow, qty, inBase);\n            \n    }\n\n    function sizeAddLiq (address base, address quote, uint256 poolIdx, uint128 qty,\n                         int24 bidTick, int24 askTick, bool inBase)\n        internal view returns (uint128) {\n        bytes32 poolKey = PoolSpecs.encodeKey(base, quote, poolIdx);\n        CurveMath.CurveState memory curve = snapCurve(poolKey);\n        return Chaining.sizeConcLiq(qty, true, curve.priceRoot_,\n                                    bidTick, askTick, inBase);\n    }\n\n    \n    /* @notice Burns ambient liquidity that's active at every price.\n     * @param base The base-side token in the pair.\n     * @param quote The quote-side token in the par.\n     * @param poolIdx The index of the pool type being burned on.\n     * @param liq The total amount of liquidity being burned. Represented as sqrt(X*Y)\n     *            for the equivalent constant-product AMM.\n     * @param limitLower Exists to make sure the user is happy with the price the \n     *                   liquidity is burned at. Transaction fails if the curve price\n     *                   at call time is below this value.\n     * @param limitUpper Transaction fails if the curve price at call time is above this\n     *                   threshold. */\n    function burnAmbientLiq (address base, address quote, uint256 poolIdx, uint128 liq,\n                   address lpConduit, uint128 limitLower, uint128 limitHigher) internal\n        returns (int128, int128) {\n        PoolSpecs.PoolCursor memory pool = queryPool(base, quote, poolIdx);\n        verifyPermitBurn(pool, base, quote, 0, 0, liq);\n        return burnOverPool(liq, pool, limitLower, limitHigher, lpConduit);\n    }\n\n    function burnAmbientQty (address base, address quote, uint256 poolIdx, bool inBase,\n                      uint128 qty, address lpConduit,\n                      uint128 limitLower, uint128 limitHigher) internal\n        returns (int128, int128) {\n        bytes32 poolKey = PoolSpecs.encodeKey(base, quote, poolIdx);\n        CurveMath.CurveState memory curve = snapCurve(poolKey);\n        uint128 liq = Chaining.sizeAmbientLiq(qty, false, curve.priceRoot_, inBase);\n        return burnAmbientLiq(base, quote, poolIdx, liq, lpConduit,\n                    limitLower, limitHigher);\n    }\n\n    function burnConcentratedQty (address base, address quote, uint256 poolIdx,\n                      int24 bidTick, int24 askTick, bool inBase,\n                      uint128 qty, address lpConduit,\n                      uint128 limitLower, uint128 limitHigher)\n        internal returns (int128, int128) {\n        bytes32 poolKey = PoolSpecs.encodeKey(base, quote, poolIdx);\n        CurveMath.CurveState memory curve = snapCurve(poolKey);\n        uint128 liq = Chaining.sizeConcLiq(qty, false, curve.priceRoot_,\n                                           bidTick, askTick, inBase);\n        return burnConcentratedLiq(base, quote, poolIdx, bidTick, askTick,\n                    liq, lpConduit, limitLower, limitHigher);\n    }\n    \n    /* @notice Used at upgrade time to verify that the contract is a valid Sdex sidecar proxy and used\n     *         in the correct slot. */\n    function acceptSdexProxyRole (address, uint16 slot) public pure returns (bool) {\n        return slot == SdexSlots.LP_PROXY_IDX;\n    }\n}\n"
    },
    "contracts/governance/SdexPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3                                                    \npragma solidity 0.8.19;\n\nimport '../libraries/ProtocolCmd.sol';\nimport '../interfaces/ISdexMinion.sol';\nimport '../mixins/StorageLayout.sol';\nimport '../vendor/compound/Timelock.sol';\nimport '../SdexSwapDex.sol';\n\n/* @title SdexPolicy\n * @notice Intermediates between the dex mechanism inside SdexSwapDex and the top-level\n *         protocol governance. Governance sets policy, which controls the parameters\n *         inside the dex mechanism. All policy routes through calls to protocolCmd() \n *         method in SdexSwapDex. Policy can be either through governance resolutions, \n *         which directly call protocolCmd() with a preset command. Or policy can be\n *         set based on rules, which allow arbitrary oracles to independently invoke \n *         protocolCmd() for some restricted subset of command types. */\ncontract SdexPolicy is ISdexMaster {\n    using ProtocolCmd for bytes;\n\n\n    /* @notie Emitted whenever the governance authority is set on this contract (either\n     *        at construction time or by later call). */\n    event SdexGovernAuthority (address ops, address treasury, address emergency);\n\n    /* @notice Emitted whenever ops authority runs a protocol command. \n     * @param minion The underlying receiver of the protocol command (i.e. the \n     *               SdexSwapDex contract).\n     * @param cmd The command being called on the minion's protocolCmd() function. */\n    event SdexResolutionOps (address minion, bytes cmd);\n\n    /* @notice Emitted whenever treasury authority runs a protocol command. \n     * @param minion The underlying receiver of the protocol command (i.e. the \n     *               SdexSwapDex contract).\n     * @param sudo If true, calls the command on SdexSwapDex with elevated privilege\n     * @param cmd The command being called on the minion's protocolCmd() function. */\n    event SdexResolutionTreasury (address minion, bool sudo, bytes cmd);\n\n    /* @notice Emitted when an emergency halt is invoked.\n     * @param minion The underlying receiver of the protocol commands to disable the\n     *               proxy contracts (see emergencyHalt() below)\n     * @param reason The stated reason for invoking the emergencyHalt() with details. */\n    event SdexEmergencyHalt (address minion, string reason);\n\n    /* @notice Emitted when a new policy rule is set or updated.\n     * @param conduit The policy conduit the rule applies to\n     * @param proxyPath The proxy sidecar index the policy can call\n     * @param PolicyRule The policy rules set for this conduit (see PolicyRule comments\n     *                   below). */\n    event SdexPolicySet (address conduit, uint16 proxyPath, PolicyRule);\n\n    /* @notice Emitted when a new policy rule is force updated. This has the same outcome\n     *         but can override a policy mandate time. Should not be called in normal\n     *         course of operations.\n     * @param conduit The policy conduit the rule applies to\n     * @param proxyPath The proxy sidecar index the policy can call\n     * @param PolicyRule The policy rules set for this conduit (see PolicyRule comments\n     *                   below). */\n    event SdexPolicyForce (address conduit, uint16 proxyPath, PolicyRule);\n\n    /* @notice Invoked by emergency authority to revoke all authority vested to a policy\n     *         conduit oracle. \n     * @param conduit The policy conduit being reset.\n     * @param reason The stated reason for invoking the emergency policy update with \n     *               details. */\n    event SdexPolicyEmergency (address conduit, string reason);\n\n    \n    /* @notice Operations authority has the ability to set policy rules for external\n     *         oracle conduits and to directly invoke non-privileged protocol commands\n     *         (i.e. anything but authority transfers, proxy upgrades or protocol \n     *          treasury collection.) */\n    address public opsAuthority_;\n\n    /* @notice Treasury authority is a superset of operations authority, with the \n     *         additional power to call privileged protocol commands on the dex (i.e. \n     *         authority transfer, proxy upgrades and treasury disbursement.). In \n     *         addition the treasury authority can transfer the authority of the policy\n     *         contract. */\n    address public treasuryAuthority_;\n\n    /* @notice Emergency is a special purpose authority with the following powers:\n     *            1) Invoke partial halt on the underlying SdexSwapDex\n     *            2) Force reset policy rules.\n     *            3) Issue any resolutions that ops is authorized to. */\n    address public emergencyAuthority_;\n\n    address public immutable dex_;\n\n    bool public ownedByGovernance;\n\n    modifier whenNotOwnedByGovernance() {\n        require(!ownedByGovernance, \"Owned by governance already\");\n        _;\n    }\n\n    \n    /* @param dex Underlying SdexSwapDex contract */\n    constructor (address dex) {\n        require(dex != address(0) && SdexSwapDex(dex).acceptSdexDex(), \"Invalid SdexSwapDex\");\n        dex_ = dex;\n        opsAuthority_ = msg.sender;\n        treasuryAuthority_ = msg.sender;\n        emergencyAuthority_ = msg.sender;  \n    }\n\n    /**\n     * @dev transfer ownership auths to any addresses\n     * @dev can only execute this function if the transferGovernance function has been executed\n     * @dev can only be executed by treasuryAuth\n     */\n    function transferOwnership (address ops, address treasury, address emergency) whenNotOwnedByGovernance\n        treasuryAuth public {\n        require(ops != address(0), \"non-zero address\");\n        require(treasury != address(0), \"non-zero address\");\n        require(emergency != address(0), \"non-zero address\");\n        opsAuthority_ = ops;\n        treasuryAuthority_ = treasury;\n        emergencyAuthority_ = emergency;\n    }\n\n    /* @notice Transfers the existing governance authorities to new addresses. Can only\n     *         be invoked by the treasury authority.\n     * @dev    One or more of the authority addresses can be kept the same if the caller\n     *         only wants to transfer one or two of the authorities. */\n    function transferGovernance (address ops, address treasury, address emergency)\n        treasuryAuth public {\n        opsAuthority_ = ops;\n        treasuryAuthority_ = treasury;\n        emergencyAuthority_ = emergency;  \n        Timelock(payable(treasury)).acceptAdmin();\n        Timelock(payable(ops)).acceptAdmin();\n        Timelock(payable(emergency)).acceptAdmin();\n\n        ownedByGovernance = true;\n    }\n\n    /* @notice Resolution from the ops authority which calls protocolCmd() on the \n     *         underlying SdexSwapDex contract. \n     *\n     * @param minion The address of the underlying SdexSwapDex contract the command is\n     *               called on.\n     * @param proxyPath The proxy sidecar index the policy calls\n     * @param cmd    The content of the command passed to the protocolCmd() method. */\n    function opsResolution (address minion, uint16 proxyPath,\n                            bytes calldata cmd) opsAuth public {\n        emit SdexResolutionOps(minion, cmd);\n        ISdexMinion(minion).protocolCmd(proxyPath, cmd, false);\n    }\n\n    /* @notice Resolution from the treasury authority which calls protocolCmd() on the \n     *         underlying SdexSwapDex contract. \n     *\n     * @param minion The address of the underlying SdexSwapDex contract the command is\n     *               called on.\n     * @param proxyPath The proxy sidecar index the policy calls\n     * @param sudo   If true, runs the call on SdexSwapDex with elevated privilege\n     * @param cmd    The content of the command passed to the protocolCmd() method. */\n    function treasuryResolution (address minion, uint16 proxyPath,\n                                 bytes calldata cmd, bool sudo)\n        treasuryAuth public {\n        emit SdexResolutionTreasury(minion, sudo, cmd);\n        ISdexMinion(minion).protocolCmd(proxyPath, cmd, sudo);\n    }\n\n    /* @notice An out-of-band emergency measure to protect funds in the SdexSwapDex \n     *         contract in case of a security issue. It works by disabling all the proxy\n     *         contracts in SdexSwapDex (and disabling swap()'s in the hotpath), besides\n     *         the \"warm path\" proxy. The warm path only includes functionality for flat\n     *         mint, burn and harvest calls. An emergency halt would therefore allow LPs\n     *         to withdraw their at-rest capital, while reducing the attack radius by \n     *         disabling swaps and more complex long-form orders.\n     *\n     * @param minion The address of the underlying SdexSwapDex contract.\n     * @param reason The stated reason for invoking the emergency policy update with \n     *               details. */\n    function emergencyHalt (address minion, string calldata reason)\n        emergencyAuth public {\n        emit SdexEmergencyHalt(minion, reason);\n\n        bytes memory cmd = ProtocolCmd.encodeHotPath(false);\n        ISdexMinion(minion).protocolCmd(SdexSlots.COLD_PROXY_IDX, cmd, true);\n        \n        cmd = ProtocolCmd.encodeSafeMode(true);\n        ISdexMinion(minion).protocolCmd(SdexSlots.COLD_PROXY_IDX, cmd, true);\n    }\n\n    /* @notice Sdex policy rules are set on a per address basis. Each address \n     *         corresponds to a smart contract, which is authorized to invoke one or \n     *         more protocol commands on the underlying SdexSwapDex contract. \n     * \n     * @param cmdFlags_ A vector of boolean flags. true entry at index X indicates\n     *                  that the policy conduit is authorized to invoke protocol\n     *                  command code X (192 possible codes).\n     * @param mandateTime_ A pre-committed time that the policy will remain in place. Zero\n     *                     indicates no mandate and can be changed by ops governance at\n     *                     any time. Policy can be strengthened in a mandate, but only\n     *                     weakened by treasury governance. \n     * @param expiryOffset_ A maximum TTL for the policy to be in place relative to \n     *                      mandateTime. (If mandateTime is zero then this is just block\n     *                      time.) Beyond this time the policy will be considered expired\n     *                      and the conduit will have no protocolCmd powers until \n     *                      refreshed by governance. */\n    struct PolicyRule {\n        bytes32 cmdFlags_;\n        uint32 mandateTime_;\n        uint32 expiryOffset_;\n    }\n\n    /* @notice The set of extant policy rules mapped by originating policy conduit oracle\n     *         address. */\n    mapping(bytes32 => PolicyRule) public rules_;\n\n    /* @notice Called by policy oracle to invoke protocolCmd on the underlying \n     *         SdexSwapDex. Authority for the specific protocol command is checked \n     *         against the policy rule (if any) for the conduit oracle's address in the \n     *         policy rules set.\n     *\n     * @param minion The address of the underlying SdexSwapDex contract\n     * @param proxyPath The proxy sidecar index for the policy being invoked\n     * @param cmd    The content of the command passed to protocolCmd() */\n    function invokePolicy (address minion, uint16 proxyPath, bytes calldata cmd) public {\n        bytes32 ruleKey = keccak256(abi.encode(msg.sender, proxyPath));\n        PolicyRule memory policy = rules_[ruleKey];\n        require(passesPolicy(policy, cmd), \"Policy authority\");\n        ISdexMinion(minion).protocolCmd(proxyPath, cmd, false);\n    }\n\n    /* @notice Called by ops authority to set or update a new policy rules. The only\n     *         restriction is that authority to set a protocol command type cannot be\n     *         revoked before the mandate time.\n     *\n     * @param conduit The address of the conduit oracle this policy rule applies to.\n     * @param proxyPath The proxy sidecar index the policy calls\n     * @param policy  The content of the updated policy rule. This will fully overwrite\n     *                the previous policy rule (if any), assuming the transition is legal\n     *                relative to the mandate. */    \n    function setPolicy (address conduit, uint16 proxyPath,\n                        PolicyRule calldata policy) opsAuth public {\n        bytes32 key = rulesKey(conduit, proxyPath);\n        \n        PolicyRule storage prev = rules_[key];\n        require(isLegal(prev, policy), \"Illegal policy update\");\n\n        rules_[key] = policy;\n        emit SdexPolicySet(conduit, proxyPath, policy);\n    }\n\n    function rulesKey (address conduit, uint16 proxyPath)\n        private pure returns (bytes32) {\n        return keccak256(abi.encode(conduit, proxyPath));\n    }\n\n    /* @notice Called by treasury authority to set or update a new policy rules. Only\n     *         difference with setPolicy is this can revoke policies even inside the \n     *         mandate time. As such this should only be called in unusual circumstances.\n     *\n     * @param conduit The address of the conduit oracle this policy rule applies to.\n     * @param proxyPath The proxy sidecar index the policy calls\n     * @param policy  The content of the updated policy rule. This will fully overwrite\n     *                the previous policy rule. */\n    function forcePolicy (address conduit, uint16 proxyPath, PolicyRule calldata policy)\n        treasuryAuth public {\n        bytes32 key = rulesKey(conduit, proxyPath);\n        rules_[key] = policy;\n        emit SdexPolicyForce(conduit, proxyPath, policy);\n    }\n\n    /* @notice Called by emergency authority to set or update a new policy rules. Only\n     *         difference with setPolicy is this can revoke policies even inside the \n     *         mandate time. As such this should only be called in unusual circumstances.\n     *\n     * @param conduit The address of the conduit oracle this policy rule applies to.\n     * @param proxyPath The proxy sidecar index the policy calls\n     * @param policy  The content of the updated policy rule. This will fully overwrite\n     *                the previous policy rule. */\n    function emergencyReset (address conduit, uint16 proxyPath,\n                             string calldata reason) emergencyAuth public {\n        bytes32 key = rulesKey(conduit, proxyPath);\n        rules_[key].cmdFlags_ = bytes32(0);\n        rules_[key].mandateTime_ = 0;\n        rules_[key].expiryOffset_ = 0;\n        emit SdexPolicyEmergency(conduit, reason);\n    }\n\n    /* @notice Determines if the Policy transition for this conduit is legal given the\n     *         pre-existing policy state.\n     * @return Returns true if the policy iteration either 1) occurs outside the mandate\n     *         or 2) the new policy does not revoke any pre-existing command flags. */\n    function isLegal (PolicyRule memory prev, PolicyRule memory next)\n        private view returns (bool) {\n        if (weakensPolicy(prev, next)) {\n            return isPostMandate(prev);\n            \n        }\n        return true;\n    }\n\n    /* @notice Determines if we're operating inside an existing mandate window. */\n    function isPostMandate (PolicyRule memory prev) private view returns (bool) {\n        return SafeCast.timeUint32() > prev.mandateTime_;\n    }\n\n    /* @notice Returns true if the proposed policy weakens any of the guarantees\n     *         of the existing policy. This would occur either by revoking an existing\n     *         flag or shortening the mandate window. */\n    function weakensPolicy (PolicyRule memory prev, PolicyRule memory next)\n        private pure returns (bool) {\n        bool weakensCmd = prev.cmdFlags_ & ~next.cmdFlags_ > 0;\n        bool weakensMandate = next.mandateTime_ < prev.mandateTime_;\n        return weakensCmd || weakensMandate;\n    }\n\n    /* @notice Determines if the proposed protocolCmd conforms to an existing policy.\n     * @param policy The current policy in place for the conduit invoking the command\n     * @param protocolCmd The proposed command to be invoked on the underlying \n     *                    SdexSwapDex contract.\n     * @return Returns true if the proposed protocolCmd message is authorized by the \n     *         policy object. */\n    function passesPolicy (PolicyRule memory policy, bytes calldata protocolCmd)\n        public view returns (bool) {\n        if (SafeCast.timeUint32() >= expireTime(policy)) {\n            return false;\n        }\n        uint8 flagIdx = uint8(protocolCmd[31]);\n        return isFlagSet(policy.cmdFlags_, flagIdx);\n    }\n\n    function expireTime (PolicyRule memory policy) private pure returns (uint32) {\n        return policy.mandateTime_ + policy.expiryOffset_;\n    }\n\n    /* @notice Returns true if the flag at index is set on the policy command flag \n     *         vector  */\n    function isFlagSet (bytes32 cmdFlags, uint8 flagIdx) private pure returns (bool) {\n        return (bytes32(uint256(1)) << flagIdx) & cmdFlags > 0;         \n    }\n\n    function acceptsSdexAuthority() public override pure returns (bool) { return true; }\n\n    /* @notice Permissions gate for normal day-to-day operations. */\n    modifier opsAuth() {\n        require(msg.sender == opsAuthority_ ||\n                msg.sender == treasuryAuthority_ ||\n                msg.sender == emergencyAuthority_, \"Ops Authority\");\n        _;\n    }\n\n    /* @notice Permissions gate for more serious operations. Treasury authority should\n     *         require more governance controls (e.g. larger multisig, longer timelock)\n     *         than operations. */\n    modifier treasuryAuth() {\n        require(msg.sender == treasuryAuthority_, \"Treasury Authority\");\n        _;\n    }\n\n    /* @notice Permissions gate for emergency operations that should only be called\n     *         during periods when the security of the protocol is in threat. */\n    modifier emergencyAuth() {\n        require(msg.sender == emergencyAuthority_, \"Emergency Authority\");\n        _;\n    }\n\n\n}\n"
    },
    "contracts/interfaces/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns the balance of a token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Permit is IERC20Minimal {\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n        ) external;\n}\n"
    },
    "contracts/interfaces/ISdexCondOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3 \n\npragma solidity 0.8.19;\n\n/* @title Sdex conditional oracle interface\n * @notice Defines a generalized interface for checking an arbitrary condition. Used in\n *         an off-chain relayer context. User can gate specific order on a runtime \n *         condition by calling to the oracle. */\ninterface ISdexNonceOracle {\n\n    /* @notice Oracle function that tests a condition.\n     *\n     * @param user The address of the underlying call.\n     * @param nonceSalt The salt of the nonce being reset on this call. Implementations\n     *                  can either ignore, or use it to check call-specific conditions.\n     * @param nonce The new nonce value that will be set for the user at the salt, if the\n     *              oracle returns true. Presumably this nonce will open a secondary order\n     *              executes some desired action.\n     * @param args Arbitrary args supplied to oracle check call.\n     *\n     * @return True if the condition is met. If false, SdexSwap will revert the \n     *         transaction, and the nonce will not be reset. */\n    function checkSdexNonceSet (address user, bytes32 nonceSalt, uint32 nonce,\n                                bytes calldata args) external returns (bool);\n}\n\ninterface ISdexCondOracle {\n    function checkSdexCond (address user, bytes calldata args) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ISdexLpConduit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3 \n\npragma solidity 0.8.19;\n\nimport '../libraries/Directives.sol';\n\n/* @title LP conduit interface\n * @notice Standard interface for contracts that accept and manage LP positions on behalf\n *         of end users. Typical example would be an ERC20 tracker for LP tokens. */\ninterface ISdexLpConduit {\n\n    /* @notice Called anytime a user mints liquidity against the conduit instance. To \n     *         utilize the user would call a mint operation on the dex with the address\n     *         of the LP conduit they want to use. This method will be called to notify\n     *         conduit contract (e.g. to perform tracking), and the LP position will be\n     *         held in the name of the conduit.\n     *\n     * @param sender The address of the user that owns the newly minted position.\n     * @param poolHash The hash (see PoolRegistry.sol) of the AMM pool the liquidity is\n     *                 minted on.\n     * @param lowerTick The tick index of the lower range (0 if ambient liquidity)\n     * @param upperTick The tick index of the upper range (0 if ambient liquidity)\n     * @param liq       The amount of liquidity being minted. If ambient liquidity this\n     *                  is denominated as ambient seeds. If concentrated this is flat\n     *                  sqrt(X*Y) liquidity of the liquidity minted.\n     * @param mileage   The accumulated fee mileage (see PositionRegistrar.sol) of the \n     *                  concentrated liquidity at mint time. If ambient, this is zero.\n     *\n     * @return   Return false if the conduit implementation does not accept the liquidity\n     *           deposit. Reverts the transaction. */\n    function depositSdexLiq (address sender, bytes32 poolHash,\n                             int24 lowerTick, int24 upperTick,\n                             uint128 liq, uint72 mileage) external returns (bool);\n\n    function withdrawSdexLiq (address sender, bytes32 poolHash,\n                              int24 lowerTick, int24 upperTick,\n                              uint128 liq, uint72 mileage) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ISdexMinion.sol": {
      "content": "// SPDX-License-Identifier: GPL-3 \n\npragma solidity 0.8.19;\n\nimport '../libraries/CurveCache.sol';\n\n/* @notice Simple interface that defines the surface between the SdexSwapDex\n *         itself and protocol governance and policy. All governance actions are\n *         are executed through the single protocolCmd() method. */\ninterface ISdexMinion {\n\n    /* @notice Calls a general governance authorized command on the SdexSwapDex contract.\n     *\n     * @param proxyPath The proxy callpath sidecar to execute the command within. (Will\n     *                  call protocolCmd\n     * @param cmd       The underlying command content to pass to the proxy sidecar call.\n     *                  Will DELEGATECALL (protocolCmd(cmd) on the sidecar proxy.\n     * @param sudo      Set to true for commands that require escalated privilege (e.g. \n     *                  authority transfers or upgrades.) The ability to call with sudo \n     *                  true should be reserved for privileged callpaths in the governance\n     *                  controller contract. */\n    function protocolCmd (uint16 proxyPath, bytes calldata cmd, bool sudo)\n        payable external;\n}\n\n/* @notice Interface for a contract that directly governs a SdexSwap dex contract. */\ninterface ISdexMaster {\n    /* @notice Used to validate governance contract to prevent authority transfer to an\n     *         an invalid address or contract. */\n    function acceptsSdexAuthority() external returns (bool);\n}"
    },
    "contracts/interfaces/ISdexPermitOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3 \n\npragma solidity 0.8.19;\n\nimport '../libraries/Directives.sol';\n\n/* @notice Standard interface for a permit oracle to be used by a permissioned pool. \n * \n * @dev For pools under their control permit oracles have the ability to approve or deny\n *      pool initialization, swaps, mints and burns for all liquidity types (ambient,\n *      concentrated and knockout). \n * \n *      Note that permit oracles do *not* have the ability to restrict claims or recovers \n *      on post-knockout liquidity. An order is eligible to be claimed/recovered only after\n *      its liquidity has been knocked out of the curve, and is no longer active. Since a\n *      no longer active order does not affect the liquidity or state of the curve, permit\n *      oracles have no economic reason to restrict knockout claims/recovers. */\ninterface ISdexPermitOracle {\n\n    /* @notice Verifies whether a given user is permissioned to perform an arbitrary \n     *          action on the pool.\n     *\n     * @param user The address of the caller to the contract.\n     * @param sender The value of msg.sender for the caller of the action. Will either\n     *               be same as user, the calling router, or the off-chain relayer.\n     * @param base  The base-side token in the pair.\n     * @param quote The quote-side token in the pair.\n     * @param ambient The ambient liquidity directive for the pool action (possibly zero)\n     * @param swap    The swap directive for the pool (possibly zero)\n     * @param concs   The concentrated liquidity directives for the pool (possibly empty)\n     * @param poolFee The effective pool fee set for the swap (either the base fee or the\n     *                base fee plus user tip).\n     *\n     * @returns discount    Either returns 0, indicating the action is not approved at all.\n     *                      Or returns the discount (in units of 0.0001%) that should be applied\n     *                      to the pool's pre-existing swap fee on this call. Be aware that this value\n     *                      is defined in terms of N-1 (because 0 is already used to indicate failure).\n     *                      Hence return value of 1 indicates a discount of 0, return value of 2 \n     *                      indicates discount of 0.0001%, return value of 3 is 0.0002%, and so on */\n    function checkApprovedForSdexPool (address user, address sender,\n                                       address base, address quote,\n                                       Directives.AmbientDirective calldata ambient,\n                                       Directives.SwapDirective calldata swap,\n                                       Directives.ConcentratedDirective[] calldata concs,\n                                       uint16 poolFee)\n        external returns (uint16 discount);\n\n    /* @notice Verifies whether a given user is permissioned to perform a swap on the pool\n     *\n     * @param user The address of the caller to the contract.\n     * @param sender The value of msg.sender for the caller of the action. Will either\n     *               be same as user, the calling router, or the off-chain relayer.\n     * @param base The base-side token in the pair.\n     * @param quote The quote-side token in the pair.\n     * @param isBuy  If true, the swapper is paying base and receiving quote\n     * @param inBaseQty  If true, the qty is denominated in the base token side.\n     * @param qty        The full qty on the swap request (could possibly be lower if user\n     *                   hits limit price.\n     * @param poolFee The effective pool fee set for the swap (either the base fee or the\n     *                base fee plus user tip).\n\n     * @returns discount    Either returns 0, indicating the action is not approved at all.\n     *                      Or returns the discount (in units of 0.0001%) that should be applied\n     *                      to the pool's pre-existing swap fee on this call. Be aware that this value\n     *                      is defined in terms of N-1 (because 0 is already used to indicate failure).\n     *                      Hence return value of 1 indicates a discount of 0, return value of 2 \n     *                      indicates discount of 0.0001%, return value of 3 is 0.0002%, and so on */\n    function checkApprovedForSdexSwap (address user, address sender,\n                                       address base, address quote,\n                                       bool isBuy, bool inBaseQty, uint128 qty,\n                                       uint16 poolFee)\n        external returns (uint16 discount);\n\n    /* @notice Verifies whether a given user is permissioned to mint liquidity\n     *         on the pool.\n     *\n     * @param user The address of the caller to the contract.\n     * @param sender The value of msg.sender for the caller of the action. Will either\n     *               be same as user, the calling router, or the off-chain relayer.\n     * @param base The base-side token in the pair.\n     * @param quote The quote-side token in the pair.\n     * @param bidTick  The tick index of the lower side of the range (0 if ambient)\n     * @param askTick  The tick index of the upper side of the range (0 if ambient)\n     * @param liq      The total amount of liquidity being minted. Denominated as \n     *                 sqrt(X*Y)\n     *\n     * @returns       Returns true if action is permitted. If false, SdexSwap will revert\n     *                the transaction. */\n    function checkApprovedForSdexMint (address user, address sender,\n                                       address base, address quote,\n                                       int24 bidTick, int24 askTick, uint128 liq)\n        external returns (bool);\n\n    /* @notice Verifies whether a given user is permissioned to burn liquidity\n     *         on the pool.\n     *\n     * @param user The address of the caller to the contract.\n     * @param sender The value of msg.sender for the caller of the action. Will either\n     *               be same as user, the calling router, or the off-chain relayer.\n     * @param base The base-side token in the pair.\n     * @param quote The quote-side token in the pair.\n     * @param bidTick  The tick index of the lower side of the range (0 if ambient)\n     * @param askTick  The tick index of the upper side of the range (0 if ambient)\n     * @param liq      The total amount of liquidity being minted. Denominated as \n     *                 sqrt(X*Y)\n     *\n     * @returns       Returns true if action is permitted. If false, SdexSwap will revert\n     *                the transaction. */\n    function checkApprovedForSdexBurn (address user, address sender,\n                                       address base, address quote,\n                                       int24 bidTick, int24 askTick, uint128 liq)\n        external returns (bool);\n\n    /* @notice Verifies whether a given user is permissioned to initialize a pool\n     *         attached to this oracle.\n     *\n     * @param user The address of the caller to the contract.\n     * @param sender The value of msg.sender for the caller of the action. Will either\n     *               be same as user, the calling router, or the off-chain relayer.\n     * @param base The base-side token in the pair.\n     * @param quote The quote-side token in the pair.\n     * @param poolIdx The Sdex-specific pool type index the pool is being created on.\n     *\n     * @returns       Returns true if action is permitted. If false, SdexSwap will revert\n     *                the transaction, and pool will not be initialized. */\n    function checkApprovedForSdexInit (address user, address sender,\n                                       address base, address quote, uint256 poolIdx)\n        external returns (bool);\n\n    /* @notice Just used to validate the contract address at pool creation time. */\n    function acceptsPermitOracle() external returns (bool);\n}\n"
    },
    "contracts/lens/SdexImpact.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\nimport \"../SdexSwapDex.sol\";\n\n/* @notice Stateless read only contract that calculates the price impact of a hypothetical\n *         swap on the current state of a given SdexSwapDex pool. Useful for calculating\n *         impact without actually executing a swap, or needing the underlying tokens. \n *\n * @dev Nothing in this contract can't be done by directly accessing readSlot() on the \n *      SdexSwapDex contrct. However this provides a more convienent interface with ergonomic\n *      that parse the raw data. */\ncontract SdexImpact {\n    using CurveMath for CurveMath.CurveState;\n    using CurveRoll for CurveMath.CurveState;\n    using SwapCurve for CurveMath.CurveState;\n    using SafeCast for uint144;\n    using TickMath for uint128;\n    using LiquidityMath for uint128;\n    using Chaining for Chaining.PairFlow;\n    using Bitmaps for uint256;\n    using Bitmaps for int24;\n    \n    address immutable public dex_;\n    \n    /* @param dex The address of the SdexSwapDex contract. */    \n    constructor (address dex) {\n        require(dex != address(0) && SdexSwapDex(dex).acceptSdexDex(), \"Invalid SdexSwapDex\");\n        dex_ = dex;\n    }\n\n    /* @notice Calculates the impact of a hypothetical swap.\n     *\n     * @param base The base token address of the pair\n     * @param quote The quote token address of the pair\n     * @param poolIdx The pool index\n     * @param isBuy True if the swap is paying base side tokens and receiving quote side\n     *              tokens.\n     * @param inBaseQty True if the fixed quantity side of the swap is base tokens, false\n     *                  quote side tokens.\n     * @param qty The total fixed number of tokens being paid or received in the swap.\n     * @param poolTip Any additional liquidity fee, in units of basis points\n     * @param limitPrice The limit price, in Q64.64 square root representation, that the swap\n     *                   should not execute beyond even if the fixed quantity is not reached\n     *\n     * @return baseFlow The base side tokens transacted in the swap.\n     * @return quoteFlow The base side tokens transacted in the swap.\n     * @return finalPrice The final price the pool would reach after the swap has executed.\n     *                    Represented in Q64.64 square root representation. */\n    function calcImpact (address base, address quote,\n                         uint256 poolIdx, bool isBuy, bool inBaseQty, uint128 qty,\n                        uint16 poolTip, uint128 limitPrice) public view  \n        returns (int128 baseFlow, int128 quoteFlow, uint128 finalPrice) {\n\n        PoolSpecs.PoolCursor memory pool = queryPoolCntx\n            (base, quote, poolIdx, poolTip);\n        CurveMath.CurveState memory curve = queryCurve(base, quote, poolIdx);\n\n        Directives.SwapDirective memory dir;\n        dir.isBuy_ = isBuy;\n        dir.inBaseQty_ = inBaseQty;\n        dir.qty_ = qty;\n        dir.limitPrice_ = limitPrice;\n\n        (baseFlow, quoteFlow) = sweepSwap(pool, curve, dir);\n        finalPrice = curve.priceRoot_;\n    }\n\n    /* @notice Retrieves the pool context object. */\n    function queryPoolCntx (address base, address quote,\n                            uint256 poolIdx, uint16 poolTip) private view \n        returns (PoolSpecs.PoolCursor memory cursor) {\n        uint256 POOL_SLOT = 65545;\n\n        bytes32 poolHash = PoolSpecs.encodeKey(base, quote, poolIdx);\n        bytes32 slot = keccak256(abi.encodePacked(poolHash, POOL_SLOT));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n\n        cursor.hash_ = poolHash;\n        cursor.head_.feeRate_ = uint16((val & uint256(0xFFFF00)) >> 8);\n        cursor.head_.protocolTake_ = uint8((val & uint256(0xFF000000)) >> 24);\n        \n        if (poolTip > cursor.head_.feeRate_) {\n            cursor.head_.feeRate_ = poolTip;\n        }\n    }\n\n    /* @notice Retrieves the liquidity curve state for the pool. */\n    function queryCurve (address base, address quote, uint256 poolIdx) private view \n        returns (CurveMath.CurveState memory curve) {\n        bytes32 key = PoolSpecs.encodeKey(base, quote, poolIdx);\n        bytes32 slot = keccak256(abi.encode(key, SdexSlots.CURVE_MAP_SLOT));\n        uint256 valOne = SdexSwapDex(dex_).readSlot(uint256(slot));\n        uint256 valTwo = SdexSwapDex(dex_).readSlot(uint256(slot)+1);\n        \n        curve.priceRoot_ = uint128((valOne << 128) >> 128);\n        curve.ambientSeeds_ = uint128(valOne >> 128);\n        curve.concLiq_ = uint128((valTwo << 128) >> 128);\n        curve.seedDeflator_ = uint64((valTwo << 64) >> 192);\n        curve.concGrowth_ = uint64(valTwo >> 192);\n    }\n\n    /* @notice Retrieves the level liquidity state for the tick in the pool. */\n    function queryLevel (bytes32 poolHash, int24 tick) private view \n        returns (uint96 bidLots, uint96 askLots) {   \n        bytes32 key = keccak256(abi.encodePacked(poolHash, tick));\n        bytes32 slot = keccak256(abi.encode(key, SdexSlots.LVL_MAP_SLOT));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n\n        askLots = uint96((val << 64) >> 160);\n        bidLots = uint96((val << 160) >> 160);\n    }\n\n    /* @notice Retrieves the terminus level bitmap at the location. */\n    function queryTerminus (bytes32 key) private view returns (uint256) {\n        uint256 TERMINUS_SLOT = 65543;\n        bytes32 slot = keccak256(abi.encode(key, TERMINUS_SLOT));\n        return SdexSwapDex(dex_).readSlot(uint256(slot));\n    }\n\n    /* @notice Retrieves the mezzanine level bitmap at the location. */\n    function queryMezz (bytes32 key) private view returns (uint256) {\n        uint256 MEZZ_SLOT = 65542;\n        bytes32 slot = keccak256(abi.encode(key, MEZZ_SLOT));\n        return SdexSwapDex(dex_).readSlot(uint256(slot));\n        \n    }\n\n    /* @notice Calculates the swap flow and applies the change to the liquidity curve\n     *         object */\n    function sweepSwap (PoolSpecs.PoolCursor memory pool, \n                        CurveMath.CurveState memory curve,\n                        Directives.SwapDirective memory swap) private view \n        returns (int128 baseFlow, int128 quoteFlow) {\n\n        if (swap.isBuy_ == (curve.priceRoot_ >= swap.limitPrice_)) {\n            return (0, 0);\n        }\n\n        Chaining.PairFlow memory accum;\n        int24 midTick = curve.priceRoot_.getTickAtSqrtRatio();\n        \n        // Keep iteratively executing more quantity until we either reach our limit price\n        // or have zero quantity left to execute.\n        bool doMore = true;\n        while (doMore) {\n            // Swap to furthest point we can based on the local bitmap. Don't bother\n            // seeking a bump outside the local neighborhood yet, because we're not sure\n            // if the swap will exhaust the bitmap.\n            (int24 bumpTick, bool spillsOver) = pinBitmap\n                (pool.hash_, swap.isBuy_, midTick);\n            curve.swapToLimit(accum, swap, pool.head_, bumpTick);\n            \n            // The swap can be in one of four states at this point: 1) qty exhausted,\n            // 2) limit price reached, 3) bump or barrier point reached on the curve.\n            // The former two indicate the swap is complete. The latter means we have to\n            // find the next bump point and possibly adjust AMM liquidity.\n            doMore = hasSwapLeft(curve, swap);\n            if (doMore) {\n\n                // The spillsOver variable indicates that we reached stopped because we\n                // reached the end of the local bitmap, rather than actually hitting a\n                // level bump. Therefore we should query the global bitmap, find the next\n                // bump point, and keep swapping across the constant-product curve until\n                // if/when we hit that point.\n                if (spillsOver) {\n                    int24 liqTick = seekMezzSpill(pool.hash_, bumpTick, swap.isBuy_);\n                    bool tightSpill = (bumpTick == liqTick);\n                    bumpTick = liqTick;\n                    \n                    // In some corner cases the local bitmap border also happens to\n                    // be the next bump point. If so, we're done with this inner section.\n                    // Otherwise, we keep swapping since we still have some distance on\n                    // the curve to cover until we reach a bump point.\n                    if (!tightSpill) {\n                        curve.swapToLimit(accum, swap, pool.head_, bumpTick);\n                        doMore = hasSwapLeft(curve, swap);\n                    }\n                }\n                \n                // Perform book-keeping related to crossing the level bump, update\n                // the locally tracked tick of the curve price (rather than wastefully\n                // we calculating it since we already know it), then begin the swap\n                // loop again.\n                if (doMore) {\n                    midTick = adjTickLiq(accum, bumpTick, curve, swap, pool.hash_);\n                }\n            }\n            \n        }\n        return (accum.baseFlow_, accum.quoteFlow_);\n    }\n\n    /* @notice Adjusts the liquidity when crossing over a concentrated liquidity bump at\n     *         a given tick. */\n    function adjTickLiq (Chaining.PairFlow memory accum, int24 bumpTick,\n                         CurveMath.CurveState memory curve,\n                         Directives.SwapDirective memory swap,\n                         bytes32 poolHash) private view returns (int24) {\n        unchecked {\n        if (!Bitmaps.isTickFinite(bumpTick)) { return bumpTick; }\n\n        (uint96 bidLots, uint96 askLots) = queryLevel(poolHash, bumpTick);\n        int128 crossDelta = LiquidityMath.netLotsOnLiquidity(bidLots, askLots);\n        int128 liqDelta = swap.isBuy_ ? crossDelta : -crossDelta;\n        curve.concLiq_ = curve.concLiq_.addDelta(liqDelta);\n\n        (int128 paidBase, int128 paidQuote, uint128 burnSwap) =\n            curve.shaveAtBump(swap.inBaseQty_, swap.isBuy_, swap.qty_);\n        accum.accumFlow(paidBase, paidQuote);\n        swap.qty_ -= burnSwap;\n\n        // When selling down, the next tick leg actually occurs *below* the bump tick\n        // because the bump barrier is the first price on a tick.\n        return swap.isBuy_ ?\n            bumpTick :\n            bumpTick - 1; // Valid ticks are well above {min(int128)-1}\n        }\n    }\n\n    /* @notice Calculates the next tick to seek in the curve bump tick map. */\n    function pinBitmap (bytes32 poolHash, bool isUpper, int24 startTick) \n        private view returns (int24 boundTick, bool isSpill) {\n        uint256 termBitmap = queryTerminus(encodeTerm(poolHash, startTick));\n        uint16 shiftTerm = startTick.termBump(isUpper);\n        int16 tickMezz = startTick.mezzKey();\n        (boundTick, isSpill) = pinTermMezz\n            (isUpper, shiftTerm, tickMezz, termBitmap);\n    }\n\n    /* @notice Calculates the next mezznine tick to seek in the curve bump tick map. */\n    function pinTermMezz (bool isUpper, uint16 shiftTerm, int16 tickMezz,\n                          uint256 termBitmap)\n        private pure returns (int24 nextTick, bool spillBit) {\n        (uint8 nextTerm, bool spillTrunc) =\n            termBitmap.bitAfterTrunc(shiftTerm, isUpper);\n        spillBit = doesSpillBit(isUpper, spillTrunc, termBitmap);\n        nextTick = spillBit ?\n            spillOverPin(isUpper, tickMezz) :\n            Bitmaps.weldMezzTerm(tickMezz, nextTerm);\n    }\n\n    /* @notice Moves to next tick when reaching the end of a terminus in bitmap */\n    function spillOverPin (bool isUpper, int16 tickMezz) private pure returns (int24) {\n        if (isUpper) {\n            return tickMezz == Bitmaps.zeroMezz(isUpper) ?\n                Bitmaps.zeroTick(isUpper) :\n                Bitmaps.weldMezzTerm(tickMezz + 1, Bitmaps.zeroTerm(!isUpper));\n        } else {\n            return Bitmaps.weldMezzTerm(tickMezz, 0);\n        }\n    }\n\n    /* @notice Determines if the seek would spill over the outside of the bitmap terminus. */\n    function doesSpillBit (bool isUpper, bool spillTrunc, uint256 termBitmap)\n        private pure returns (bool spillBit) {\n        if (isUpper) {\n            spillBit = spillTrunc;\n        } else {\n            bool bumpAtFloor = termBitmap.isBitSet(0);\n            spillBit = bumpAtFloor ? false :\n                spillTrunc;\n        }\n    }\n\n    /* @notice Seeks the next liquidity bump in tick bitmap at the mezzanine level. */\n    function seekMezzSpill (bytes32 poolIdx, int24 borderTick, bool isUpper)\n        internal view returns (int24) {\n        (uint8 lobbyBorder, uint8 mezzBorder) = rootsForBorder(borderTick, isUpper);\n\n        // Most common case is that the next neighboring bitmap on the border has\n        // an active tick. So first check here to save gas in the hotpath.\n        (int24 pin, bool spills) =\n            seekAtTerm(poolIdx, lobbyBorder, mezzBorder, isUpper);\n        if (!spills) { return pin; }                                      \n\n        // Next check to see if we can find a neighbor in the mezzanine. This almost\n        // always happens except for very sparse pools. \n        (pin, spills) =\n            seekAtMezz(poolIdx, lobbyBorder, mezzBorder, isUpper);\n        if (!spills) { return pin; }\n\n        // Finally iterate through the lobby layer.\n        return seekOverLobby(poolIdx, lobbyBorder, isUpper);\n    }\n\n    /* @notice Seeks the next tick bitmap by searching in the adjacent neighborhood. */\n    function seekAtTerm (bytes32 poolIdx, uint8 lobbyBit, uint8 mezzBit, bool isUpper)\n        private view returns (int24, bool) {\n        uint256 neighborBitmap = queryTerminus(encodeTermWord(poolIdx, lobbyBit, mezzBit));\n        (uint8 termBit, bool spills) = neighborBitmap.bitAfterTrunc(0, isUpper);\n        if (spills) { return (0, true); }\n        return (Bitmaps.weldLobbyPosMezzTerm(lobbyBit, mezzBit, termBit), false);\n    }\n\n    /* @notice Seeks the next tick bitmap by searching in the current mezzanine \n     *         neighborhood.\n     * @dev This covers a span of 65 thousand ticks, so should capture most cases. */\n    function seekAtMezz (bytes32 poolIdx, uint8 lobbyBit,\n                         uint8 mezzBorder, bool isUpper)\n        private view returns (int24, bool) {\n        uint256 neighborMezz = queryMezz(encodeMezzWord(poolIdx, lobbyBit));\n        uint8 mezzShift = Bitmaps.bitRelate(mezzBorder, isUpper);\n        (uint8 mezzBit, bool spills) = neighborMezz.bitAfterTrunc(mezzShift, isUpper);\n        if (spills) { return (0, true); }\n        return seekAtTerm(poolIdx, lobbyBit, mezzBit, isUpper);\n    }\n\n    /* @notice Used when the tick is not contained in the mezzanine. We walk through the\n     *         the mezzanine tick bitmaps one by one until we find an active tick bit. */\n    function seekOverLobby (bytes32 poolIdx, uint8 lobbyBit, bool isUpper)\n        private view returns (int24) {\n        return isUpper ?\n            seekLobbyUp(poolIdx, lobbyBit) :\n            seekLobbyDown(poolIdx, lobbyBit);\n    }\n\n    /* Unlike the terminus and mezzanine layer, we don't store a bitmap at the lobby\n     * layer. Instead we iterate through the top-level bits until we find an active\n     * mezzanine. This requires a maximum of 256 iterations, and can be gas intensive.\n     * However moves at this level represent 65,000% price changes and are very rare. */\n    function seekLobbyUp (bytes32 poolIdx, uint8 lobbyBit)\n        private view returns (int24) {\n        uint8 MAX_MEZZ = 0;\n        unchecked {\n            // Because it's unchecked idx will wrap around to 0 when it checks all bits\n            for (uint8 i = lobbyBit + 1; i > 0; ++i) {\n                (int24 tick, bool spills) = seekAtMezz(poolIdx, i, MAX_MEZZ, true);\n                if (!spills) { return tick; }\n            }\n        }\n        return Bitmaps.zeroTick(true);\n    }\n\n    /* Same logic as seekLobbyUp(), but the inverse direction. */\n    function seekLobbyDown (bytes32 poolIdx, uint8 lobbyBit)\n        private view returns (int24) {\n        uint8 MIN_MEZZ = 255;\n        unchecked {\n            // Because it's unchecked idx will wrap around to 255 when it checks all bits\n            for (uint8 i = lobbyBit - 1; i < 255; --i) {\n                (int24 tick, bool spills) = seekAtMezz(poolIdx, i, MIN_MEZZ, false);\n                if (!spills) { return tick; }\n            }\n        }\n        return Bitmaps.zeroTick(false);\n    }\n\n    /* @notice Splits out the lobby bits and the mezzanine bits from the 24-bit price\n     *         tick index associated with the type of border tick used in seekMezzSpill()\n     *         call */\n    function rootsForBorder (int24 borderTick, bool isUpper) private pure\n        returns (uint8 lobbyBit, uint8 mezzBit) {\n        // Because pinTermMezz returns a border *on* the previous bitmap, we need to\n        // decrement by one to get the seek starting point.\n        int24 pinTick = isUpper ? borderTick : (borderTick - 1);\n        lobbyBit = pinTick.lobbyBit();\n        mezzBit = pinTick.mezzBit();\n    }\n\n    /* @notice Encodes the hash key for the mezzanine neighborhood of the tick. */\n    function encodeMezz (bytes32 poolIdx, int24 tick) private pure returns (bytes32) {\n        int8 wordPos = tick.lobbyKey();\n        return keccak256(abi.encodePacked(poolIdx, wordPos)); \n    }\n\n    /* @notice Encodes the hash key for the terminus neighborhood of the tick. */\n    function encodeTerm (bytes32 poolIdx, int24 tick) private pure returns (bytes32) {\n        int16 wordPos = tick.mezzKey();\n        return keccak256(abi.encodePacked(poolIdx, wordPos)); \n    }\n\n    /* @notice Encodes the hash key for the mezzanine neighborhood of the first 8-bits\n     *         of a tick index. (This is all that's needed to determine mezzanine.) */\n    function encodeMezzWord (bytes32 poolIdx, int8 lobbyPos)\n        private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(poolIdx, lobbyPos));  \n    }\n\n    /* @notice Encodes the hash key for the mezzanine neighborhood of the first 8-bits\n     *         of a tick index. (This is all that's needed to determine mezzanine.) */\n    function encodeMezzWord (bytes32 poolIdx, uint8 lobbyPos)\n        private pure returns (bytes32) {\n        return encodeMezzWord(poolIdx, Bitmaps.uncastBitmapIndex(lobbyPos));\n    }\n\n    /* @notice Encodes the hash key for the terminus neighborhood of the first 16-bits\n     *         of a tick index. (This is all that's needed to determine terminus.) */\n    function encodeTermWord (bytes32 poolIdx, uint8 lobbyPos, uint8 mezzPos)\n        private pure returns (bytes32) {\n        int16 mezzIdx = Bitmaps.weldLobbyMezz\n            (Bitmaps.uncastBitmapIndex(lobbyPos), mezzPos);\n        return keccak256(abi.encodePacked(poolIdx, mezzIdx)); \n    }\n\n    /* @notice If true, indicates there is still more quantity to execute in the swap. */\n    function hasSwapLeft (CurveMath.CurveState memory curve,\n                          Directives.SwapDirective memory swap)\n        private pure returns (bool) {\n        bool inLimit = swap.isBuy_ ?\n            curve.priceRoot_ < swap.limitPrice_ :\n            curve.priceRoot_ > swap.limitPrice_;\n        return inLimit && (swap.qty_ > 0);\n    }\n}\n"
    },
    "contracts/lens/SdexQuery.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\nimport \"../SdexSwapDex.sol\";\n\n/* @notice Stateless read only contract that provides functions for convienetly reading and\n *         parsing the internal state of a SdexSwapDex contract. \n *\n * @dev Nothing in this contract can't be done by directly accessing readSlot() on the \n *      SdexSwapDex contract. However this provides a more convienent interface with ergonomic\n *      that parse the raw data. */\ncontract SdexQuery {\n    using CurveMath for CurveMath.CurveState;\n    using SafeCast for uint144;\n    \n    address immutable public dex_;\n\n    /* @param dex The address of the SdexSwapDex contract. */    \n    constructor (address dex) {\n        require(dex != address(0) && SdexSwapDex(dex).acceptSdexDex(), \"Invalid SdexSwapDex\");\n        dex_ = dex;\n    }\n    \n    /* @notice Queries and returns the current state of a liquidity curve for a given pool.\n     * \n     * @param base The base token address\n     * @param quote The quote token address\n     * @param poolIdx The pool index\n     *\n     * @return The CurveState struct of the underlying pool. */\n    function queryCurve (address base, address quote, uint256 poolIdx)\n        public view returns (CurveMath.CurveState memory curve) {\n        bytes32 key = PoolSpecs.encodeKey(base, quote, poolIdx);\n        bytes32 slot = keccak256(abi.encode(key, SdexSlots.CURVE_MAP_SLOT));\n        uint256 valOne = SdexSwapDex(dex_).readSlot(uint256(slot));\n        uint256 valTwo = SdexSwapDex(dex_).readSlot(uint256(slot)+1);\n        \n        curve.priceRoot_ = uint128((valOne << 128) >> 128);\n        curve.ambientSeeds_ = uint128(valOne >> 128);\n        curve.concLiq_ = uint128((valTwo << 128) >> 128);\n        curve.seedDeflator_ = uint64((valTwo << 64) >> 192);\n        curve.concGrowth_ = uint64(valTwo >> 192);\n    }\n\n    function queryPoolParams (address base, address quote, uint256 poolIdx)\n        public view returns (PoolSpecs.Pool memory pool) {\n        bytes32 key = PoolSpecs.encodeKey(base, quote, poolIdx);\n        bytes32 slot = keccak256(abi.encode(key, SdexSlots.POOL_PARAM_SLOT));\n        uint256 valOne = SdexSwapDex(dex_).readSlot(uint256(slot));\n\n        pool.schema_ = uint8(valOne);\n        pool.feeRate_ = uint16(valOne >> 8);\n        pool.protocolTake_ = uint8(valOne >> 24);\n        pool.tickSize_ = uint16(valOne >> 32);\n        pool.jitThresh_ = uint8(valOne >> 48);\n        pool.knockoutBits_ = uint8(valOne >> 56);\n        pool.oracleFlags_ = uint8(valOne >> 64);\n    }\n\n    function queryPoolTemplate (uint256 poolIdx)\n        public view returns (PoolSpecs.Pool memory pool) {\n        bytes32 slot = keccak256(abi.encode(poolIdx, SdexSlots.POOL_TEMPL_SLOT));\n        uint256 valOne = SdexSwapDex(dex_).readSlot(uint256(slot));\n\n        pool.schema_ = uint8(valOne);\n        pool.feeRate_ = uint16(valOne >> 8);\n        pool.protocolTake_ = uint8(valOne >> 24);\n        pool.tickSize_ = uint16(valOne >> 32);\n        pool.jitThresh_ = uint8(valOne >> 48);\n        pool.knockoutBits_ = uint8(valOne >> 56);\n        pool.oracleFlags_ = uint8(valOne >> 64);\n    }\n\n    /* @notice Queries and returns the 24-bit price tick for a given pool curve.\n     * \n     * @param base The base token address of the pair\n     * @param quote The quote token address of the pair\n     * @param poolIdx The pool index\n     *\n     * @return The 24-bit price for the pool's curve's price */\n    function queryCurveTick (address base, address quote, uint256 poolIdx) \n        public view returns (int24) {\n        bytes32 key = PoolSpecs.encodeKey(base, quote, poolIdx);\n        bytes32 slot = keccak256(abi.encode(key, SdexSlots.CURVE_MAP_SLOT));\n        uint256 valOne = SdexSwapDex(dex_).readSlot(uint256(slot));\n        \n        uint128 curvePrice = uint128((valOne << 128) >> 128);\n        return TickMath.getTickAtSqrtRatio(curvePrice);\n    }\n\n    /* @notice Queries and returns the total liquidity currently active on the pool's curve\n     * \n     * @param base The base token address\n     * @param quote The quote token address\n     * @param poolIdx The pool index\n     *\n     * @return The total sqrt(X*Y) liquidity currently active in the pool */\n    function queryLiquidity (address base, address quote, uint256 poolIdx)\n        public view returns (uint128) {        \n        return queryCurve(base, quote, poolIdx).activeLiquidity();\n    }\n\n    /* @notice Queries and returns the current price of the pool's curve\n     * \n     * @param base The base token address\n     * @param quote The quote token address\n     * @param poolIdx The pool index\n     *\n     * @return Q64.64 square root price of the pool */\n    function queryPrice (address base, address quote, uint256 poolIdx)\n        public view returns (uint128) {\n        return queryCurve(base, quote, poolIdx).priceRoot_;\n    }\n\n    /* @notice Queries and returns the surplus collateral of a specific token held by\n     *         a specific address.\n     *\n     * @param owner The address of the owner of the surplus collateral\n     * @param token The address of the token balance being queried.\n     *\n     * @return The total amount of surplus collateral held by this owner in this token.\n     *         0 if none. */\n    function querySurplus (address owner, address token)\n        public view returns (uint128 surplus) {\n        bytes32 key = keccak256(abi.encode(owner, token));\n        bytes32 slot = keccak256(abi.encode(key, SdexSlots.BAL_MAP_SLOT));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n        surplus = uint128((val << 128) >> 128);\n    }\n\n    /* @notice Queries and returns the surplus collateral of a virtual token\n     *\n     * @param owner The address of the owner of the surplus collateral\n     * @param tracker The address of the virtual token tracker\n     * @param salt The virtual token salt for the query\n     *\n     * @return The total amount of surplus collateral held by this owner in this token.\n     *         0 if none. */\n    function queryVirtual (address owner, address tracker, uint256 salt)\n        public view returns (uint128 surplus) {\n        address token = PoolSpecs.virtualizeAddress(tracker, salt);\n        surplus = querySurplus(owner, token);\n    }\n\n    /* @notice Queries and returns the current protocol fees accumulated for a given token. */\n    function queryProtocolAccum (address token) public view returns (uint128) {\n        bytes32 key = bytes32(uint256(uint160(token)));\n        bytes32 slot = keccak256(abi.encode(key, SdexSlots.FEE_MAP_SLOT));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n        return uint128(val);\n    }\n\n    /* @notice Queries and returns the state of a given concentrated liquidity tick level\n     *         for a liquidity curve.\n     *\n     * @param base The base token address of the pair\n     * @param quote The quote token address of the pair\n     * @param poolIdx The index of the pool type\n     * @param tick The 24-bit price tick location of the level.\n     *\n     * @return bidLots The amount of concentrated liquidity that becomes active if the pool\n     *                 price falls below the level tick (and vice versa). Represented in units\n     *                 of 1024 lots of sqrt(X*Y) liquidity.\n     * @return bidLots The amount of concentrated liquidity that becomes active if the pool\n     *                 price rises below the level (and vice versa). Represented in units\n     *                 of 1024 lots of sqrt(X*Y) liquidity.\n     * @return odometer The currnet fee odomter snapshotted at the current tick boundary. */\n    function queryLevel (address base, address quote, uint256 poolIdx, int24 tick)\n        public view returns (uint96 bidLots, uint96 askLots, uint64 odometer) {\n        bytes32 poolHash = PoolSpecs.encodeKey(base, quote, poolIdx);\n        bytes32 key = keccak256(abi.encodePacked(poolHash, tick));\n        bytes32 slot = keccak256(abi.encode(key, SdexSlots.LVL_MAP_SLOT));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n\n        odometer = uint64(val >> 192);\n        askLots = uint96((val << 64) >> 160);\n        bidLots = uint96((val << 160) >> 160);\n    }\n\n    /* @notice Queries and returns the state of the aggregated knockout liquidity at the tick\n     *         location in a given pool's curve.\n     *\n     * @param base The base token address of the pair\n     * @param quote The quote token address of the pair\n     * @param poolIdx The index of the pool type\n     * @param isBid If true, represents liquidity pivot that gets knocked out when the curve\n     *              price falls below the tick. And vice versa, if false.\n     * @param tick The 24-bit price tick location of the level.\n     *\n     * @return lots The amount of aggregated liquidity active at the pivot. In units of 1024\n     *              lots of sqrt(X*Y) liquidity.\n     * @return pivot The block time that the pivot was first created. Equivalent to the block\n     *               time of the first position to be minted at the pivot.\n     * @return range The total with, in ticks, of the range liquidity in the knockout pivot. */\n    function queryKnockoutPivot (address base, address quote, uint256 poolIdx,\n                                 bool isBid, int24 tick)\n        public view returns (uint96 lots, uint32 pivot, uint16 range) {\n        bytes32 poolHash = PoolSpecs.encodeKey(base, quote, poolIdx);\n        bytes32 key = KnockoutLiq.encodePivotKey(poolHash, isBid, tick);\n        bytes32 slot = keccak256(abi.encodePacked(key, SdexSlots.KO_PIVOT_SLOT));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n\n        lots = uint96((val << 160) >> 160);\n        pivot = uint32((val << 128) >> 224);\n        range = uint16(val >> 128);\n    }\n\n    /* @notice Queries and returns the latest posted Merkle root for the sequence of knockout\n     *         events at a given tick pivot in a given pool\n     *\n     * @param base The base token address of the pair\n     * @param quote The quote token address of the pair\n     * @param poolIdx The index of the pool type\n     * @param isBid If true, represents liquidity pivot that gets knocked out when the curve\n     *              price falls below the tick. And vice versa, if false.\n     * @param tick The 24-bit price tick location of the level.\n     *\n     * @return root The random Merkle root of the last knockout pivot. Any claimed knockout\n     *              position for previously knocked out positions at this tick location must\n     *              post a Merkle proof that resolves to this root.\n     * @return pivot The block time of the last pivot to be knocked out at this tick location.\n     * @return fee The accumulated range order fee at the knockout time (in units of ambient \n     *             liquidity seeds per unit of concentrated liqudidity) */\n    function queryKnockoutMerkle (address base, address quote, uint256 poolIdx,\n                                  bool isBid, int24 tick)\n        public view returns (uint160 root, uint32 pivot, uint64 fee) {\n        bytes32 poolHash = PoolSpecs.encodeKey(base, quote, poolIdx);\n        bytes32 key = KnockoutLiq.encodePivotKey(poolHash, isBid, tick);\n        bytes32 slot = keccak256(abi.encodePacked(key, SdexSlots.KO_MERKLE_SLOT));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n\n        root = uint160((val << 96) >> 96);\n        pivot = uint32((val << 64) >> 224);\n        fee = uint64(val >> 192);\n    }\n\n    /* @notice Queries and returns the state of a single knockout liquidity position.\n     *\n     * @param base The base token address of the pair\n     * @param quote The quote token address of the pair\n     * @param poolIdx The index of the pool type\n     * @param pivot The time associated with the pivot the position was created on\n     * @param isBid If true, represents liquidity pivot that gets knocked out when the curve\n     *              price falls below the tick. And vice versa, if false.\n     * @param lowerTick The 24-bit price tick the lower end of the liquidity range\n     * @param upperTick The 24-bit price tick the lower end of the liquidity range\n     *\n     * @return lots The total amount of liquidity in the position, in units of 1024 lots of\n     *              sqrt(X*Y) liquidity\n     * @return mileage The in-range curve fee mileage assigned to the liquidity. Used to\n     *                 calculate accumulated rewards based on the curve.\n     * @return timestamp The block time that the liquidity is stamped with from latest mint */\n    function queryKnockoutPos (address owner, address base, address quote,\n                               uint256 poolIdx, uint32 pivot, bool isBid,\n                               int24 lowerTick, int24 upperTick) public view\n        returns (uint96 lots, uint64 mileage, uint32 timestamp) {\n        bytes32 poolHash = PoolSpecs.encodeKey(base, quote, poolIdx);\n        KnockoutLiq.KnockoutPosLoc memory loc;\n        loc.isBid_ = isBid;\n        loc.lowerTick_ = lowerTick;\n        loc.upperTick_ = upperTick;\n\n        return queryKnockoutPos(loc, poolHash, owner, pivot);\n    }\n\n    /* @notice Queries and returns the state of a single knockout liquidity position.\n     *\n     * @param loc The location of the knockout liquidity position on the curve\n     * @param poolHash The unique hash associated with the pool\n     * @param owner The address that owns the liquidity position\n     * @param pivot The time associated with the pivot the position was created on\n     *\n     * @return lots The total amount of liquidity in the position, in units of 1024 lots of\n     *              sqrt(X*Y) liquidity\n     * @return mileage The in-range curve fee mileage assigned to the liquidity. Used to\n     *                 calculate accumulated rewards based on the curve.\n     * @return timestamp The block time that the liquidity is stamped with from latest mint */\n    function queryKnockoutPos (KnockoutLiq.KnockoutPosLoc memory loc,\n                               bytes32 poolHash, address owner, uint32 pivot)\n        private view returns (uint96 lots, uint64 mileage, uint32 timestamp) {\n        bytes32 key = KnockoutLiq.encodePosKey(loc, poolHash, owner, pivot);\n        bytes32 slot = keccak256(abi.encodePacked(key, SdexSlots.KO_POS_SLOT));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n\n        lots = uint96((val << 160) >> 160);\n        mileage = uint64((val << 96) >> 224);\n        timestamp = uint32(val >> 224);\n    }\n\n    /* @notice Queries and returns the state of a single range order liquidity position.\n     *\n     * @param owner The address that owns the liquidity position\n     * @param base The base token address of the pair\n     * @param quote The quote token address of the pair\n     * @param poolIdx The index of the pool type\n     * @param lowerTick The 24-bit price tick the lower end of the liquidity range\n     * @param upperTick The 24-bit price tick the lower end of the liquidity range\n     *\n     * @return liq The total amount of liquidity in the position in units of sqrt(X*Y) liquidity\n     * @return fee The in-range curve fee mileage assigned to the liquidity. Used to\n     *             calculate accumulated rewards based on the curve.\n     * @return timestamp The block time that the liquidity is stamped with from latest mint\n     * @return atomic If true indicates that the liquidity position is atomic and user cannot\n     *                mint additional liquidity at this position unless original liquidity is\n     *                fully burned. */\n    function queryRangePosition (address owner, address base, address quote,\n                                 uint256 poolIdx, int24 lowerTick, int24 upperTick)\n        public view returns (uint128 liq, uint64 fee,\n                             uint32 timestamp, bool atomic) {\n        bytes32 poolHash = PoolSpecs.encodeKey(base, quote, poolIdx);\n        bytes32 posKey = keccak256(abi.encodePacked(owner, poolHash, lowerTick, upperTick));\n        bytes32 slot = keccak256(abi.encodePacked(posKey, SdexSlots.POS_MAP_SLOT_72));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n\n        liq = uint128((val << 128) >> 128);\n        fee = uint64((val >> 128) << (128 + 64) >> (128 + 64));\n        timestamp = uint32((val >> (128 + 64)) << (128 + 64 + 32) >> (128 + 64 + 32));\n        atomic = bool((val >> (128 + 64 + 32)) > 0);\n    }\n\n    /* @notice Queries and returns the state of a single ambient order liquidity position.\n     *\n     * @param owner The address that owns the liquidity position\n     * @param base The base token address of the pair\n     * @param quote The quote token address of the pair\n     * @param poolIdx The index of the pool type\n     *\n     * @return seeds The total amount of ambient liquidity seeds in the position in units\n     *               of rewards deflated sqrt(X*Y) liquidity\n     * @return timestamp The block time that the liquidity is stamped with from latest mint */\n    function queryAmbientPosition (address owner, address base, address quote,\n                                   uint256 poolIdx)\n        public view returns (uint128 seeds, uint32 timestamp) {\n        bytes32 poolHash = PoolSpecs.encodeKey(base, quote, poolIdx);\n        bytes32 posKey = keccak256(abi.encodePacked(owner, poolHash));\n        bytes32 slot = keccak256(abi.encodePacked(posKey, SdexSlots.AMB_MAP_SLOT));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n\n        seeds = uint128((val << 128) >> 128);\n        timestamp = uint32((val >> (128)) << (128 + 32) >> (128 + 32));\n    }    \n\n    /* @notice Queries and returns the total ambient liquidity rewards accumulated by a\n     *         given active range liquidity position\n     *\n     * @param owner The address that owns the liquidity position\n     * @param base The base token address of the pair\n     * @param quote The quote token address of the pair\n     * @param poolIdx The index of the pool type\n     * @param lowerTick The 24-bit price tick the lower end of the liquidity range\n     * @param upperTick The 24-bit price tick the lower end of the liquidity range\n     *\n     * @return The total accumulated rewards in the form of ambient sqrt(X*Y) liquidity */\n    function queryConcRewards (address owner, address base, address quote, uint256 poolIdx,\n                               int24 lowerTick, int24 upperTick) \n                               public view returns (uint128 liqRewards, \n                                                    uint128 baseRewards, uint128 quoteRewards) {\n        (uint128 liq, uint64 feeStart, ,) = queryRangePosition(owner, base, quote, poolIdx,\n                                                               lowerTick, upperTick);\n        (, , uint64 bidFee) = queryLevel(base, quote, poolIdx, lowerTick);\n        (, , uint64 askFee) = queryLevel(base, quote, poolIdx, upperTick);\n        CurveMath.CurveState memory curve = queryCurve(base, quote, poolIdx);\n        uint64 curveFee = queryCurve(base, quote, poolIdx).concGrowth_;\n\n        int24 curveTick = TickMath.getTickAtSqrtRatio(curve.priceRoot_);\n        uint64 feeLower = lowerTick <= curveTick ? bidFee : curveFee - bidFee;\n        uint64 feeUpper = upperTick <= curveTick ? askFee : curveFee - askFee;\n            \n        unchecked {\n            uint72 odometer = uint72(type(uint64).max) + uint72(feeUpper) - uint72(feeLower);\n\n            if (odometer < feeStart) {\n                return (0, 0, 0);\n            }\n\n            uint64 accumFees = uint64(odometer - feeStart);\n            uint128 seeds = FixedPoint.mulQ48(liq, accumFees).toUint128By144();\n            return convertSeedsToLiq(curve, seeds);\n        }\n    }\n\n    /* @notice Queries and returns the liquidity and tokens held by a single ambient\n     *         liquidity position\n     *\n     * @param owner The address that owns the liquidity position\n     * @param base The base token address of the pair\n     * @param quote The quote token address of the pair\n     * @param poolIdx The index of the pool type\n     *\n     * @return liq The total amount of ambient sqrt(X*Y) liquidity \n     * @return baseQty The base-side tokens held by the current position at current \n     *                 curve price.\n     * @return quoteQty The quote-side tokens held by the current position at current \n     *                  curve price. */\n    function queryAmbientTokens (address owner, address base, address quote,\n                                 uint256 poolIdx)\n        public view returns (uint128 liq, uint128 baseQty, uint128 quoteQty) {\n        (uint128 seeds, ) = queryAmbientPosition(owner, base, quote, poolIdx);\n        CurveMath.CurveState memory curve = queryCurve(base, quote, poolIdx);\n        return convertSeedsToLiq(curve, seeds);\n    }\n\n    /* @notice Queries and returns the liquidity and tokens held by a single range\n     *         position. Note that the returned quantities do *not* include accumulated\n     *         rewards.\n     *\n     * @param owner The address that owns the liquidity position\n     * @param base The base token address of the pair\n     * @param quote The quote token address of the pair\n     * @param poolIdx The index of the pool type\n     * @param lowerTick The 24-bit price tick the lower end of the liquidity range\n     * @param upperTick The 24-bit price tick the lower end of the liquidity range\n     *\n     * @return liq The total amount of ambient sqrt(X*Y) liquidity \n     * @return baseQty The base-side tokens held by the current position at current \n     *                 curve price.\n     * @return quoteQty The quote-side tokens held by the current position at current \n     *                  curve price. */\n    function queryRangeTokens (address owner, address base, address quote,\n                               uint256 poolIdx, int24 lowerTick, int24 upperTick)\n        public view returns (uint128 liq, uint128 baseQty, uint128 quoteQty) {\n        (liq, , ,) = queryRangePosition(owner, base, quote, poolIdx, lowerTick, upperTick);\n        CurveMath.CurveState memory curve = queryCurve(base, quote, poolIdx);\n        (baseQty, quoteQty) = concLiqToTokens(curve, lowerTick, upperTick, liq);\n    }\n\n    /* @notice Queries and returns the liquidity and tokens held by a single knockout\n     *         position. Note that the returned quantities do *not* include accumulated\n     *         rewards.\n     *\n     * @param owner The address that owns the liquidity position\n     * @param base The base token address of the pair\n     * @param quote The quote token address of the pair\n     * @param poolIdx The index of the pool type\n     * @param pivot The time associated with the pivot the position was created on\n     * @param isBid If true, represents liquidity pivot that gets knocked out when the curve\n     *              price falls below the tick. And vice versa, if false.\n     * @param lowerTick The 24-bit price tick the lower end of the liquidity range\n     * @param upperTick The 24-bit price tick the lower end of the liquidity range\n     *\n     * @return liq The total amount of ambient sqrt(X*Y) liquidity \n     * @return baseQty The base-side tokens held by the current position at current \n     *                 curve price.\n     * @return quoteQty The quote-side tokens held by the current position at current \n     *                  curve price.\n     * @return knockedOut Returns true if the position has been knocked out of the curve.\n     *                    In which case the values represent the tokens claimable. False,\n     *                    if the liquidity is still active in the curve. */\n    function queryKnockoutTokens (address owner, address base, address quote,\n                                  uint256 poolIdx, uint32 pivot, bool isBid,\n                                  int24 lowerTick, int24 upperTick)\n        public view returns (uint128 liq, uint128 baseQty, uint128 quoteQty, bool knockedOut) {\n\n        int24 knockoutTick = isBid ? lowerTick : upperTick;\n        (uint96 lots, , ) = queryKnockoutPos(owner, base, quote, poolIdx, pivot, isBid, lowerTick, upperTick);\n        (, uint32 pivotActive, ) = queryKnockoutPivot(base, quote, poolIdx, isBid, knockoutTick);\n\n        liq = LiquidityMath.lotsToLiquidity(lots);\n        knockedOut = pivotActive != pivot;\n\n        if (knockedOut) {\n            uint128 knockoutPrice = TickMath.getSqrtRatioAtTick(knockoutTick);\n            (baseQty, quoteQty) = concLiqToTokens(knockoutPrice, lowerTick, upperTick, liq);\n\n        } else {\n            CurveMath.CurveState memory curve = queryCurve(base, quote, poolIdx);\n            (baseQty, quoteQty) = concLiqToTokens(curve, lowerTick, upperTick, liq);\n        }\n    }\n\n    /* @notice Connverts an arbitrary liquidity seeds value to XYK liquidity and equivalent\n     *         full-range tokens for that liquidity. */ \n    function convertSeedsToLiq (CurveMath.CurveState memory curve, uint128 seeds) \n                                internal pure returns (uint128 liq, uint128 baseQty, uint128 quoteQty) {\n        liq = CompoundMath.inflateLiqSeed(seeds, curve.seedDeflator_);\n        (baseQty, quoteQty) = liquidityToTokens(curve, liq);\n    }\n\n    /* @notice Converts an arbitrary concentrated liquidity quantity in a given range to \n     *         the quantity of tokens in the position, given the current price. */\n    function concLiqToTokens (CurveMath.CurveState memory curve, \n                              int24 lowerTick, int24 upperTick, uint128 liq) \n        internal pure returns (uint128 baseQty, uint128 quoteQty) {\n        return concLiqToTokens(curve.priceRoot_, lowerTick, upperTick, liq);\n    }\n\n    /* @notice Converts an arbitrary concentrated liquidity quantity in a given range to \n     *         the quantity of tokens in the position, given the current price. */\n    function concLiqToTokens (uint128 curvePrice, \n                              int24 lowerTick, int24 upperTick, uint128 liq) \n        internal pure returns (uint128 baseQty, uint128 quoteQty) {\n        uint128 lowerPrice = TickMath.getSqrtRatioAtTick(lowerTick);\n        uint128 upperPrice = TickMath.getSqrtRatioAtTick(upperTick);\n\n        (uint128 lowerBase, uint128 lowerQuote) = liquidityToTokens(lowerPrice, liq);\n        (uint128 upperBase, uint128 upperQuote) = liquidityToTokens(upperPrice, liq);\n        (uint128 ambBase, uint128 ambQuote) = liquidityToTokens(curvePrice, liq);\n\n        if (curvePrice < lowerPrice) {\n            return (0, lowerQuote - upperQuote);\n        } else if (curvePrice >= upperPrice) {\n            return (upperBase - lowerBase, 0);\n        } else {\n            return (ambBase - lowerBase, ambQuote - upperQuote);\n        }\n    }\n\n    /* @notice Converts a liquidity value to the equivalent amount of full-range virtual tokens. */\n    function liquidityToTokens (CurveMath.CurveState memory curve, uint128 liq) \n                                internal pure returns (uint128 baseQty, uint128 quoteQty) {\n        return liquidityToTokens(curve.priceRoot_, liq);\n    }\n\n    /* @notice Converts a liquidity value to the equivalent amount of full-range virtual tokens. */\n    function liquidityToTokens (uint128 curvePrice, uint128 liq)\n                                internal pure returns (uint128 baseQty, uint128 quoteQty) {\n        baseQty = uint128(FixedPoint.mulQ64(liq, curvePrice));\n        quoteQty = uint128(FixedPoint.divQ64(liq, curvePrice));        \n    }\n}\n"
    },
    "contracts/libraries/Bitmaps.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n\nimport \"./BitMath.sol\";\n\n/* @title Tick bitmap library\n *\n * @notice Tick bitmaps are used for the tracking of tick initialization\n *    state over a 256-bit interval. Tick indices are 24-bit integer, so\n *    this library provides for 3-layers of recursive 256-bit bitmaps. Each\n *    layer covers the first (lobby), middle (mezzanine) or last (terminus) \n *    8-bits in the 24-bit index.\n *\n * @dev Note that the bitmap library works with the full set of possible int24\n *      values. Whereas other parts of the protocol set a MIN_TICK and MAX_TICK\n *      that are well within the type bounds of int24. It's the responsibility of\n *      calling code to assure that ticks being set are within the MIN_TICK and\n *      MAX_TICK, and this library does *not* provide those checks. */\nlibrary Bitmaps {\n\n    /* @notice Transforms the bitmap so the first or last N bits are set to zero.\n     * @param bitmap - The original 256-bit bitmap object.\n     * @param shift - The number N of slots in the bitmap to mask to zero.\n     * @param right - If true mask the N bits from right to left. Otherwise from\n     *                left to right.\n     * @return The bitmap with N bits (on the right or left side) masked. */\n    function truncateBitmap (uint256 bitmap, uint16 shift, bool right)\n        pure internal returns (uint256) {\n        return right ?\n            (bitmap >> shift) << shift:\n            (bitmap << shift) >> shift;\n    }\n\n    /* @notice - Determine the index of the first set bit in the bitmap starting\n     *    after N bits from the right or the left.\n     * @param bitmap - The 256-bit bitmap object.\n     * @param shift - Exclude the first shift N bits from the index result.\n     * @param right - If true find the first set bit starting from the right\n     *   (least significant bit as EVM is big endian). Otherwise from the lefft.\n     * @return idx - The index of the matching set bit. Index position is always\n     *   left indexed starting at zero regardless of the @right parameter.\n     * @return spills - If no matching set bit is found, this return value is set to\n     *   true. */\n    function bitAfterTrunc (uint256 bitmap, uint16 shift, bool right)\n        pure internal returns (uint8 idx, bool spills) {\n        bitmap = truncateBitmap(bitmap, shift, right);\n        spills = (bitmap == 0);\n        if (!spills) {\n            idx = right ?\n                BitMath.leastSignificantBit(bitmap) :\n                BitMath.mostSignificantBit(bitmap);\n        }\n    }\n\n    /* @notice Returns true if the bitmap's Nth bit slot is set.\n     * @param bitmap - The 256 bit bitmap object.\n     * @param pos - The bitmap index to check. Value is left indexed starting at zero.\n     * @return True if the bit is set. */\n    function isBitSet (uint256 bitmap, uint8 pos) pure internal returns (bool) {\n        (uint idx, bool spill) = bitAfterTrunc(bitmap, pos, true);\n        return !spill && idx == pos;\n    }\n\n    /* @notice Converts a signed integer bitmap index to an unsigned integer. */\n    function castBitmapIndex (int8 x) internal pure returns (uint8) {\n        unchecked {\n        return x >= 0 ? \n            uint8(x) + 128 : // max(int8(x)) + 128 <= 255, so this never overflows\n            uint8(uint16(int16(x) + 128)); // min(int8(x)) + 128 >= 0 (and less than 255)\n        }\n    }\n\n    /* @notice Converts an unsigned integer bitmap index to a signed integer. */\n    function uncastBitmapIndex (uint8 x) internal pure returns (int8) {\n        unchecked {\n        return x < 128 ?\n            int8(int16(uint16(x)) - 128) : // max(uint8) - 128 <= 127, so never overflows int8\n            int8(x - 128);  // min(uint8) - 128  >= -128, so never underflows int8\n        }\n    }\n\n    /* @notice Extracts the 8-bit tick lobby index from the full 24-bit tick index. */\n    function lobbyKey (int24 tick) internal pure returns (int8) {\n        return int8(tick >> 16); // 24-bit int shifted by 16 bits will always fit in 8 bits\n    }\n\n    /* @notice Extracts the 16-bit tick root from the full 24-bit tick \n     * index. */\n    function mezzKey (int24 tick) internal pure returns (int16) {\n        return int16(tick >> 8); // 24-bit int shifted by 8 bits will always fit in 16 bits\n    }\n\n    /* @notice Extracts the 8-bit lobby bits (the last 8-bits) from the full 24-bit tick \n     * index. Result can be used to index on a lobby bitmap. */\n    function lobbyBit (int24 tick) internal pure returns (uint8) {\n        return castBitmapIndex(lobbyKey(tick));\n    }\n\n    /* @notice Extracts the 8-bit mezznine bits (the middle 8-bits) from the full 24-bit \n     * tick index. Result can be used to index on a mezzanine bitmap. */\n    function mezzBit (int24 tick) internal pure returns (uint8) {\n        return uint8(uint16(mezzKey(tick) % 256)); // Modulo 256 will always <= 255, and fit in uint8\n    }\n\n    /* @notice Extracts the 8-bit terminus bits (the last 8-bits) from the full 24-bit \n     * tick index. Result can be used to index on a terminus bitmap. */\n    function termBit (int24 tick) internal pure returns (uint8) {\n        return uint8(uint24(tick % 256)); // Modulo 256 will always <= 255, and fit in uint8\n    }\n\n    /* @notice Determines the next shift bump from a starting terminus value. Note for \n     *   upper the barrier is always to the right. For lower it's on the tick. This is\n     *   because bumps always occur at the start of the tick.\n     *\n     * @param tick - The full 24-bit tick index.\n     * @param isUpper - If true, shift and index from left-to-right. Otherwise right-to-\n     *   left.\n     * @return - Returns the bumped terminus bit indexed directionally based on param \n     *   isUpper. Can be 256, if the terminus bit occurs at the last slot. */  \n    function termBump (int24 tick, bool isUpper) internal pure returns (uint16) {\n        unchecked {\n        uint8 bit = termBit(tick);\n        // Bump moves up for upper, but occurs at the bottom of the same tick for lower.\n        uint16 shiftTerm = isUpper ? 1 : 0;\n        return uint16(bitRelate(bit, isUpper)) + shiftTerm;\n        }\n    }\n\n    /* @notice Converts a directional bitmap position, to a cardinal bitmap position. For\n     *   example the 20th bit for a sell (right-to-left) would be the 235th bit in\n     *   the bitmap. \n     * @param bit - The directional-oriented index in the 256-bit bitmap.\n     * @param isUpper - If true, the direction is left-to-right, if false right-to-left.\n     * @return The cardinal (left-to-right) index in the bitmap. */\n    function bitRelate (uint8 bit, bool isUpper) internal pure returns (uint8) {\n        unchecked {\n        return isUpper ? bit : (255 - bit); // 255 minus uint8 will never underflow\n        }\n    }\n\n    /* @notice Converts a 16-bit tick base and an 8-bit terminus tick to a full 24-bit\n     *   tick index. */\n    function weldMezzTerm (int16 mezzBase, uint8 termBitArg)\n        internal pure returns (int24) {\n        unchecked {\n        // First term will always be <= 0x8FFF00 and second term (as a uint8) will always\n        // be positive and <= 0xFF. Therefore the sum will never overflow int24\n        return (int24(mezzBase) << 8) + int24(uint24(termBitArg));\n        }\n    }\n\n    /* @notice Converts an 8-bit lobby index and an 8-bit mezzanine bit into a 16-bit \n     *   tick base root. */\n    function weldLobbyMezz (int8 lobbyIdx, uint8 mezzBitArg)\n        internal pure returns (int16) {\n        unchecked {\n        // First term will always be <= 0x8F00 and second term (as a uint) will always\n        // be positive and <= 0xFF. Therefore the sum will never overflow int24\n        return (int16(lobbyIdx) << 8) + int16(uint16(mezzBitArg));\n        }\n    }\n\n    /* @notice Converts an 8-bit lobby index, an 8-bit mezzanine bit, and an 8-bit\n     *   terminus bit into a full 24-bit tick index. */\n    function weldLobbyMezzTerm (int8 lobbyIdx, uint8 mezzBitArg, uint8 termBitArg)\n        internal pure returns (int24) {\n        unchecked {\n        // First term will always be  <= 0x8F0000. Second term, starting as a uint8\n        // will always be positive and <= 0xFF00. Thir term will always be positive\n        // and <= 0xFF. Therefore the sum will never overflow int24\n        return (int24(lobbyIdx) << 16) +\n            (int24(uint24(mezzBitArg)) << 8) +\n            int24(uint24(termBitArg));\n        }\n    }\n\n    \n    /* @notice Converts an 8-bit lobby index, an 8-bit mezzanine bit, and an 8-bit\n     *   terminus bit into a full 24-bit tick index. */\n    function weldLobbyPosMezzTerm (uint8 lobbyWord, uint8 mezzBitArg, uint8 termBitArg)\n        internal pure returns (int24) {\n        return weldLobbyMezzTerm(Bitmaps.uncastBitmapIndex(lobbyWord),\n                                 mezzBitArg, termBitArg);\n    }\n\n    /* @notice The minimum and maximum 24-bit integers are used to represent -/+ \n     *   infinity range. We have to reserve these bits as non-standard range for when\n     *   price shifts past the last representable tick.\n     * @param tick The tick index value being tested\n     * @return True if the tick index represents a positive or negative infinity. */\n    function isTickFinite (int24 tick) internal pure returns (bool) {\n        return tick > type(int24).min &&\n            tick < type(int24).max;\n    }\n\n    /* @notice Returns the zero horizon point for the full 24-bit tick index. */\n    function zeroTick (bool isUpper) internal pure returns (int24) {\n        return isUpper ? type(int24).max : type(int24).min;\n    }\n\n    /* @notice Returns the zero horizon point equivalent for the first 16-bits of the \n     *    tick index. */\n    function zeroMezz (bool isUpper) internal pure returns (int16) {\n        return isUpper ? type(int16).max : type(int16).min;\n    }\n\n    /* @notice Returns the zero point equivalent for the terminus bit (last 8-bits) of\n     *    the tick index. */\n    function zeroTerm (bool isUpper) internal pure returns (uint8) {\n        return isUpper ? type(uint8).max : 0;\n    }\n}\n"
    },
    "contracts/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.19;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        // Set to unchecked, but the original UniV3 library was written in a pre-checked version of Solidity\n        unchecked{\n        require(x > 0);\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        // Set to unchecked, but the original UniV3 library was written in a pre-checked version of Solidity\n        unchecked {\n        require(x > 0);\n\n        r = 255;\n        if (x & type(uint128).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & type(uint64).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint32).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint8).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n        }\n    }\n\n}\n"
    },
    "contracts/libraries/Chaining.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport \"./SafeCast.sol\";\nimport \"./PoolSpecs.sol\";\nimport \"./PriceGrid.sol\";\nimport \"./CurveMath.sol\";\n\n/* @title Trade flow chaining library \n * @notice Provides common conventions and utility functions for aggregating\n *   and backfilling the user <-> pool flow of token assets within a single\n *   pre-defined pair of assets. */\nlibrary Chaining {\n    using SafeCast for int128;\n    using SafeCast for uint128;\n    using CurveMath for uint128;\n    using TickMath for int24;\n    using LiquidityMath for uint128;\n    using CurveMath for CurveMath.CurveState;\n\n    /* Used as an indicator code by long-form orders to indicate how a given sub-\n     * directive should size relative to some pre-existing cumulative collateral flow\n     * from all the actions on the pool.\n     * evaluation of the long form order. Types supported:\n     * \n     *    NO_ROLL_TYPE - No rolling fill. Evaluation will treat the set quantity as a \n     *        pre-fixed value in the native domain (i.e. tokens for swaps and liquidity \n     *        units for LP actions).\n     *    \n     *    ROLL_PASS_POS_TYPE - Rolling fill, but against a fixed token collateral target.\n     *        Difference with NO_ROLL_TYPE, is the set quantity will denominate as the unit\n     *        of the rolling quantity. I.e. represents token collateral instead of \n     *        liquidity units on LP actions.\n     *\n     *    ROLL_PASS_NEG_TYPE - Same as ROLL_PASS_POS_TYPE, but rolling quantity will be\n     *                         negative.\n     *\n     *    ROLL_FRAC_TYPE - Fills a fixed-point fraction of the cumulatve rolling flow.\n     *                     E.g. can swap 50% of the tokens returned from previous LP burn.\n     *                     Denominated in fixed point basis points (1/10,000).\n     *\n     *    ROLL_DEBIT_TYPE - Fills the cumulative rolling flow with a fixed offset in the \n     *                      direction of user debit. E.g. can swap-buy all the tokens \n     *                      needed, plus slightly more.\n     *\n     *    ROLL_CREDIT_TYPE - Same as above, but offset in the direction of user credit.\n     *                       E.g. can swap-sell all but X tokens from a previous burn \n     *                       operation.*/\n    uint8 constant NO_ROLL_TYPE = 0;\n    uint8 constant ROLL_PASS_POS_TYPE = 1;\n    uint8 constant ROLL_PASS_NEG_TYPE = 2;\n    uint8 constant ROLL_FRAC_TYPE = 4;\n    uint8 constant ROLL_DEBIT_TYPE = 5;\n    uint8 constant ROLL_CREDIT_TYPE = 6;\n\n    /* @notice Common convention that defines the full execution context for \n     *   any arbitrary sequence of tradable actions (swap/mint/burn) within\n     *   a single pool.\n     * \n     * @param pool_ - The pre-queried specifications for the pool's market specs\n     * @param improve_ - The pre-queries specification for off-grid price improvement\n     *   requirements. (May be zero if user didn't request price improvement.)\n     * @param roll_ - The base target to use for any quantities that are set as \n     *   open-ended rolling gaps. */\n    struct ExecCntx {\n        PoolSpecs.PoolCursor pool_;\n        PriceGrid.ImproveSettings improve_;\n        RollTarget roll_;\n    }\n\n    /* @notice In certain contexts SdexSwap provides the ability for the user to\n    *     substitute pre-fixed quantity fields with empty \"rolling\" fields that are\n    *     back-filled based on some cumulative flow across the execution. For example\n    *     a swap may specify to buy however much of quote token was demanded by an\n    *     earlier mint action on the pool. This struct provides the context for which \n    *     rolling flow to target if/when those back-fills are used.\n    *\n    *  @param inBaseQty_ If true, rolling quantity targets will use the cumulative\n    *     flows on the base-side token in the pair. If false, will use the quote-side\n    *     token flows.\n    *  @param prePairBal_ Specifies a pre-set rolling flow offset to add/subtract to\n    *     the cumulative flow within the pair. Useful for starting with a preset target\n    *     from a previous pool or pair in the chain. */\n    struct RollTarget {\n        bool inBaseQty_;\n        int128 prePairBal_;\n    }\n\n    /* @notice Represents the accumulated flow between user and pool within a transaction.\n     * \n     * @param baseFlow_ Represents the cumulative base side token flow. Negative for\n     *   flow going to the user, positive for flow going to the pool.\n     * @param quoteFlow_ The cumulative quote side token flow.\n     * @param baseProto_ The total amount of base side tokens being collected as protocol\n     *   fees. The above baseFlow_ value is inclusive of this quantity.\n     * @param quoteProto_ The total amount of quote tokens being collected as protocol\n     *   fees. The above quoteFlow_ value is inclusive of this quantity. */\n    struct PairFlow {\n        int128 baseFlow_;\n        int128 quoteFlow_;\n        uint128 baseProto_;\n        uint128 quoteProto_;\n    }\n\n    /* @notice Increments a PairFlow accumulator with a set of pre-determined flows.\n     * @param flow The PairFlow object being accumulated. Function writes to this\n     *   structure.\n     * @param base The base side token flows. Negative when going to the user, positive\n     *   for flows going to the pool.\n     * @param quote The quote side token flows. Negative when going to the user, positive\n     *   for flows going to the pool. */\n    function accumFlow (PairFlow memory flow, int128 base, int128 quote)\n        internal pure {\n        flow.baseFlow_ += base;\n        flow.quoteFlow_ += quote;\n    }\n\n    /* @notice Increments a PairFlow accumulator with the flows from another PairFlow\n     *   object.\n     * @param accum The PairFlow object being accumulated. Function writes to this\n     *   structure.\n     * @param flow The PairFlow input, whose flow is being added to the accumulator. */\n    function foldFlow (PairFlow memory accum, PairFlow memory flow) internal pure {\n        accum.baseFlow_ += flow.baseFlow_;\n        accum.quoteFlow_ += flow.quoteFlow_;\n        accum.baseProto_ += flow.baseProto_;\n        accum.quoteProto_ += flow.quoteProto_;\n    }\n\n    /* @notice Increments a PairFlow accumulator with the flows from a swap leg.\n     * @param flow The PairFlow object being accumulated. Function writes to this\n     *   structure.\n     * @param inBaseQty Whether the swap was denominated in base or quote side tokens.\n     * @param base The base side token flows. Negative when going to the user, positive\n     *   for flows going to the pool.\n     * @param quote The quote side token flows. Negative when going to the user, positive\n     *   for flows going to the pool.\n     * @param proto The amount of protocol fees collected by the swap operation. (The\n     *   total flows must be inclusive of this value). */\n    function accumSwap (PairFlow memory flow, bool inBaseQty,\n                        int128 base, int128 quote, uint128 proto) internal pure {\n        accumFlow(flow, base, quote);\n        if (inBaseQty) {\n            flow.quoteProto_ += proto;\n        } else {\n            flow.baseProto_ += proto;\n        }\n    }\n\n    /* @notice Computes the amount of ambient liquidity to mint/burn in order to \n     *   neutralize the previously accumulated flow in the pair.\n     *\n     * @dev Note that because of integer rounding liquidity can't exactly neutralize\n     *   a fixed flow of tokens. Therefore this function always rounds in favor of \n     *   leaving the user with a very small collateral credit. With a credit they can\n     *   use the dust discard feature at settlement to avoid any token transfer.\n     *\n     * @param roll Indicates the context for the type of roll target that the call \n     *   should target. (See RollTarget struct above.)\n     * @param dir The ambient liquidity directive the liquidity is applied to\n     * @param curve The liquidity curve that is being minted or burned against.\n     * @param flow The previously accumulated flow on this pair. Based on the context \n     *   above, this function will target the accumulated flow contained herein.\n     * \n     * @return liq The amount of ambient liquidity to mint/burn to meet the target.\n     * @return isAdd If true, then liquidity must be minted to neutralize rolling flow,\n     *   If false, then liquidity must be burned. */\n    function plugLiquidity (RollTarget memory roll,\n                            Directives.AmbientDirective memory dir,\n                            CurveMath.CurveState memory curve,\n                            PairFlow memory flow) internal pure {\n        if (dir.rollType_ != NO_ROLL_TYPE) {\n            (uint128 collateral, bool isAdd) =\n                collateralDemand(roll, flow, dir.rollType_, dir.liquidity_);\n\n            uint128 liq = sizeAmbientLiq\n                (collateral, isAdd, curve.priceRoot_, roll.inBaseQty_);\n            (dir.liquidity_, dir.isAdd_) = (liq, isAdd);\n        }\n    }\n    \n    /* @notice Computes the amount of concentrated liquidity to mint/burn in order to \n     *   neutralize the previously accumulated flow in the pair.\n     *\n     * @dev Note that concentrated liquidity is represented as lots 1024. The results of\n     *   this function will always conform to that multiple. Because of integer rounding\n     *   it's impossible to guarantee a liquidity value that exactly neutralizes an \n     *   arbitrary token flow quantity. Therefore this function always rounds in favor of \n     *   leaving the user with a very small collateral credit. With a credit they can\n     *   use the dust discard feature at settlement to avoid any token transfer.\n     *\n     * @param roll Indicates the context for the type of roll target that the call \n     *   should target. (See RollTarget struct above.)\n     * @param bend The concentrated range order directive the liquidity is applied to\n     * @param curve The liquidity curve that is being minted or burned against.\n     * @param flow The previously accumulated flow on this pair. Based on the context \n     *   above, this function will target the accumulated flow contained herein.\n     * @param lowTick The tick index of the lower bound of the concentrated liquidity\n     * @param highTick The tick index of the upper bound of the concentrated liquidity\n     * \n     * @return seed The amount of ambient liquidity seeds to mint/burn to meet the\n     *   target. \n     * @return isAdd If true, then liquidity must be minted to neutralize rolling flow,\n     *   If false, then liquidity must be burned. */\n    function plugLiquidity (RollTarget memory roll,\n                            Directives.ConcentratedDirective memory bend,\n                            CurveMath.CurveState memory curve,\n                            int24 lowTick, int24 highTick, PairFlow memory flow)\n        internal pure {\n        if (bend.rollType_ == NO_ROLL_TYPE) { return; }\n\n        (uint128 collateral, bool isAdd) = collateralDemand(roll, flow, bend.rollType_,\n                                                            bend.liquidity_);\n        uint128 liq = sizeConcLiq(collateral, isAdd, curve.priceRoot_,\n                                  lowTick, highTick, roll.inBaseQty_);\n        (bend.liquidity_, bend.isAdd_) = (liq, isAdd);\n    }\n\n    /* @notice Calculates the amount of ambient liquidity that a fixed amount of token\n     *         collateral maps to into the the pool.\n     *\n     * @dev Will always round liquidity conservatively. That is when being used in an add\n     *      liquidity context, user can be assured that the liquidity requires slightly\n     *      less than their collateral commitment. And when liquidity is being removed\n     *      collateral will be slightly higher for the amount of removed liquidity.\n     * \n     * @param collateral The amount of collateral (either base of quote) tokens that we\n     *                   want to size liquidity for.\n     * @param isAdd Indicates whether the liquidity is being added or removed. Necessary\n     *              to make sure that we round conservatively.\n     * @param priceRoot The current price in the pool.\n     * @param inBaseQty True if the collateral is a base token value, false if quote \n     *                  token.\n     * @return The amount of liquidity, in sqrt(X*Y) units, supported by this \n     *         collateral. */\n    function sizeAmbientLiq (uint128 collateral, bool isAdd, uint128 priceRoot,\n                             bool inBaseQty) internal pure returns (uint128) {\n        uint128 liq = bufferCollateral(collateral, isAdd)\n            .liquiditySupported(inBaseQty, priceRoot);\n        return isAdd ? liq : (liq + 1);\n    }\n\n    /* @notice Same as sizeAmbientLiq() (see above), but calculates for concentrated \n     *         liquidity in a given range.\n     * \n     * @param collateral The amount of collateral (either base of quote) tokens that we\n     *                   want to size liquidity for.\n     * @param isAdd Indicates whether the liquidity is being added or removed. Necessary\n     *              to make sure that we round conservatively.\n     * @param priceRoot The current price in the pool.\n     * @param lowTick The tick index of the lower bound of the concentrated liquidity \n     *                range.\n     * @param highTick The tick index of the upper bound.\n     * @param inBaseQty True if the collateral is a base token value, false if quote \n     *                  token.\n     * @return The amount of concentrated liquidity (in sqrt(X*Y) units) supported in\n     *         the given tick range. */\n    function sizeConcLiq (uint128 collateral, bool isAdd, uint128 priceRoot,\n                          int24 lowTick, int24 highTick, bool inBaseQty)\n        internal pure returns (uint128) {\n        (uint128 bidPrice, uint128 askPrice) =\n            determinePriceRange(priceRoot, lowTick, highTick, inBaseQty);\n        \n        uint128 liq = bufferCollateral(collateral, isAdd)\n            .liquiditySupported(inBaseQty, bidPrice, askPrice);\n\n        return isAdd ?\n            liq.shaveRoundLots() :\n            liq.shaveRoundLotsUp();\n    }\n\n    // Represents a small, economically meaningless amount of token wei that makes sure\n    // we're always leaving the user with a collateral credit.    \n    function bufferCollateral (uint128 collateral, bool isAdd)\n        private pure returns (uint128) {\n        uint128 BUFFER_COLLATERAL = 4;\n\n        if (isAdd) {\n            // This ternary switch always produces non-negative result, preventing underflow\n            return collateral < BUFFER_COLLATERAL ? 0 :\n                collateral - BUFFER_COLLATERAL;\n        } else {\n            // This ternary switch prevents buffering into an overflow\n            return collateral > type(uint128).max - 4 ?\n                type(uint128).max :\n                collateral + BUFFER_COLLATERAL;\n        }\n    }\n\n    /* @notice Converts a swap that's indicated to be a rolling gap-fill into one\n     *   with quantity and direction set to neutralize hitherto accumulated rolling\n     *   flow. E.g. if the user previously performed a buy swap, this would output\n     *   a sell swap with an exactly opposite quantity.\n     *\n     * @param roll Indicates the context for the type of roll target that the call \n     *   should target. (See RollTarget struct above.)\n     * @param swap The templated SwapDirective object. This function will update the\n     *   object with the quantity, direction, and (if necessary) price needed to gap-fill\n     *   the rolling flow accumulator.\n     * @param flow The previously accumulated flow on this pair. Based on the context \n     *   above, this function will target the accumulated flow contained herein. */\n    function plugSwapGap (RollTarget memory roll,\n                          Directives.SwapDirective memory swap,\n                          PairFlow memory flow) internal pure {\n        if (swap.rollType_ != NO_ROLL_TYPE) {\n            int128 plugQty = scaleRoll(roll, flow, swap.rollType_, swap.qty_);\n            overwriteSwap(swap, plugQty);\n        }\n    }\n\n    /* This function will overwrite the swap directive template to plug the\n     * rolling qty. This obviously involves writing the swap quantity. It\n     * may also possibly flip the swap direction, which is useful in certain\n     * complex scenarios where the user can't exactly predict the direction'\n     * of the roll.\n     *\n     * If rolling plug flips the swap direction, then the limit price will\n     * be set in the wrong direction and the trade will fail. In this case\n     * we disable limitPrice. This is fine because rolling swaps are only\n     * used in the composite code path, where the user can set their output\n     * limits at the settle layer. */\n    function overwriteSwap (Directives.SwapDirective memory swap,\n                            int128 rollQty) private pure {\n        bool prevDir = swap.isBuy_;\n        swap.isBuy_ = swap.inBaseQty_ ? (rollQty < 0) : (rollQty > 0);\n        swap.qty_ = rollQty > 0 ? uint128(rollQty) : uint128(-rollQty);\n\n        if (prevDir != swap.isBuy_) {\n            swap.limitPrice_ = swap.isBuy_ ?\n                TickMath.MAX_SQRT_RATIO : TickMath.MIN_SQRT_RATIO;\n        }\n    }\n\n    /* @notice Calculates the total amount of collateral and its direction, that we should\n     *   be targeting to neutralize when sizing a liquidity gap-fill. */\n    function collateralDemand (RollTarget memory roll, PairFlow memory flow,\n                               uint8 rollType, uint128 nextQty) private pure\n        returns (uint128 collateral, bool isAdd) {\n        int128 collatFlow = scaleRoll(roll, flow, rollType, nextQty);\n\n        isAdd = collatFlow < 0;\n        collateral = collatFlow > 0 ? uint128(collatFlow) : uint128(-collatFlow);\n    }\n\n    /* @notice Calculates the effective bid/ask committed collateral range related\n     *   to a concentrated liquidity range order. The calculation is different depending on\n     *   whether the curve price is inside or outside the specified tick range. (See below) */\n    function determinePriceRange (uint128 curvePrice, int24 lowTick, int24 highTick,\n                                  bool inBase) private pure\n        returns (uint128 bidPrice, uint128 askPrice) {\n        bidPrice = lowTick.getSqrtRatioAtTick();\n        askPrice = highTick.getSqrtRatioAtTick();\n\n        /* The required reserve collateral for a range order is a function of whether\n         * the order is in-range or out-of-range. For in range orders the reserves are\n         * determined based on the distance between the current price and range boundary\n         * price:\n         *           Lower range        Curve Price        Upper range\n         *                |                  |                  | \n         *    <-----------*******************O*******************------------->\n         *                --------------------\n         *                 Base token reserves\n         *\n         * For out of range orders the reserve collateral is a function of the entire\n         * width of the range.\n         *\n         *           Lower range              Upper range       Curve Price\n         *                |                        |                 |\n         *    <-----------**************************-----------------O---->\n         *                --------------------------\n         *                   Base token reserves\n         *\n         * And if the curve is out of range on the opposite side, the reserve collateral\n         * would be zero, and therefore it's impossible to map a non-zero amount of tokens\n         * to liquidity (and function reverts)\n         *\n         *        Curve Price          Lower range              Upper range       \n         *           |                     |                        |                 \n         *    <------O---------------------**************************---------------------->\n         *                                      ZERO base tokens\n         */                  \n        if (curvePrice <= bidPrice) {\n            require(!inBase);\n        } else if (curvePrice >= askPrice) {\n            require(inBase);\n        } else if (inBase) {\n            askPrice = curvePrice;\n        } else {\n            bidPrice = curvePrice;\n        }\n    }\n\n    /* @notice Sums the total rolling balance that should be targeted to be neutralized.\n     *   Includes both the accumulated flow in the pair and the pre-pair starting balance\n     *   set in the RollTarget context (if any). */\n    function totalBalance (RollTarget memory roll, PairFlow memory flow)\n        private pure returns (int128) {\n        int128 pairFlow = (roll.inBaseQty_ ? flow.baseFlow_ : flow.quoteFlow_);\n        return roll.prePairBal_ + pairFlow;\n    }\n    \n    /* @notice Given a cumulative rolling flow, calculates a gap-fill quantity based on\n     *         rolling target parameters.\n     *\n     * @param roll The rolling target schematic, set at the begining of the pair hop.\n     * @param flow The cumulative collateral flow accumulated in this pair hop so far.\n     * @param rollType The type of rolling gap-fill to target (see indicator comments \n     *                 above)\n     * @param target   The rolling gap-fill target, contextualized by rollType value.\n     * @return         The size optimally scaled to match the rolling gap-fill target. */\n    function scaleRoll (RollTarget memory roll, PairFlow memory flow,\n                        uint8 rollType, uint128 target) private pure returns (int128) {\n        int128 rollGap = totalBalance(roll, flow);\n        return scalePlug(rollGap, rollType, target);\n    }\n\n    /* @notice Given a fixed rolling gap, scales the next incremental size to achieve\n     *         a specific user-defined target.\n     *\n     * @param rollGap The rolling gap that exists prior to this leg of the long-form order.\n     * @param rollType The type of rolling gap-fill to target (see indicator comments \n     *                 above)\n     * @param target   The rolling gap-fill target, contextualized by rollType value.\n     * @return         The size optimally scaled to match the rolling gap-fill target. */\n    function scalePlug (int128 rollGap, uint8 rollType, uint128 target)\n        private pure returns (int128) {\n        if (rollType == ROLL_PASS_POS_TYPE) { return int128(target); }\n        else if (rollType == ROLL_PASS_NEG_TYPE) { return -int128(target); }\n        else if (rollType == ROLL_FRAC_TYPE) {\n            return int128(int256(rollGap) * int256(int128(target)) / 10000);\n        } else if (rollType == ROLL_DEBIT_TYPE) {\n            return rollGap + int128(target);\n        } else {\n            return rollGap - int128(target);\n        }\n    }\n\n    /* @notice Convenience function to round up flows pinned to liquidity. Will safely \n     *         (i.e. only in the debit direction) round up the flow to the user-specified\n     *         qty. This is primarily useful for mints where the user specifies a token \n     *         qty, that gets cast to liquidity, that then gets converted back to\n     *         a token quantity amount. Because of fixed-point rounding the latter will\n     *         be slightly smaller than the fixed specified amount. For usability and gas\n     *         optimization the user will likely want to just pay the full amount. */\n    function pinFlow (int128 baseFlow, int128 quoteFlow, uint128 uQty, bool inBase)\n        internal pure returns (int128, int128) {\n        int128 qty = uQty.toInt128Sign();\n        if (inBase && int128(qty) > baseFlow) {\n            baseFlow = int128(qty);\n        } else if (!inBase && int128(qty) > quoteFlow) {\n            quoteFlow = int128(qty);\n        }\n        return (baseFlow, quoteFlow);\n    }\n}\n"
    },
    "contracts/libraries/CompoundMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n\nimport \"./FixedPoint.sol\";\nimport \"./TickMath.sol\";\nimport \"./SafeCast.sol\";\n\n/* @title Compounding math library\n * @notice Library provides convenient math functionality for various transformations\n *         and reverse transformations related to compound growth. */\nlibrary CompoundMath {\n    using SafeCast for uint256;\n\n    /* @notice Provides a safe lower-bound approximation of the square root of (1+x)\n     *         based on a two-term Taylor series expansion. The purpose is to calculate\n     *         the square root for small compound growth rates. \n     * \n     *         Both the input and output values are passed as the growth rate *excluding*\n     *         the 1.0 multiplier base. For example assume the input (X) is 0.1, then the\n     *         output Y is:\n     *             (1 + Y) = sqrt(1+X)\n     *             (1 + Y) = sqrt(1 + 0.1)\n     *             (1 + Y) = 1.0488 (approximately)\n     *                   Y = 0.0488 (approximately)\n     *         In the example the square root of 10% compound growth is 4.88%\n     *\n     *         Another example, assume the input (X) is 0.6, then the output (Y) is:\n     *             (1 + Y) = sqrt(1+X)\n     *             (1 + Y) = sqrt(1 + 0.6)\n     *             (1 + Y) = 1.264 (approximately)\n     *                   Y = 0.264 (approximately)\n     *         In the example the square root of 60% growth is 26.4% compound growth\n     *\n     *         Another example, assume the input (X) is 0.018, then the output (Y) is:\n     *             (1 + Y) = sqrt(1+X)\n     *             (1 + Y) = sqrt(1 + 0.018)\n     *             (1 + Y) = 1.00896 (approximately)\n     *                   Y = 0.00896 (approximately)\n     *         In the example the square root of 1.8% growth is 0.896% compound growth\n     *\n     * @dev    Due to approximation error, only safe to use on input in the range of \n     *         [0,1). Will always round down from the true real value.\n     *\n     * @param x  The value of x in (1+x). Represented as a Q16.48 fixed-point\n     * @returns   The value of y for which (1+y) = sqrt(1+x). Represented as Q16.48 fixed point\n     * */\n    function approxSqrtCompound (uint64 x64) internal pure returns (uint64) {\n        // Taylor series error becomes too large above 2.0. Approx is still conservative\n        // but the angel's share becomes unreasonable. \n        require(x64 < FixedPoint.Q48);\n\n        unchecked {\n        uint256 x = uint256(x64);\n        // Shift by 48, to bring x^2 back in fixed point precision\n        uint256 xSq = (x * x) >> 48; // x * x never overflows 256 bits, because x is 64 bits\n        uint256 linear = x >> 1; // Linear Taylor series term is x/2\n        uint256 quad = xSq >> 3; // Quadratic Tayler series term ix x^2/8;\n\n        // This will always fit in 64 bits because result is smaller than original/\n        // Will always be greater than 0, because x^2 < x for x < 1\n        return uint64(linear - quad);\n        }\n    }\n\n    /* @notice Computes the result from compounding two cumulative growth rates.\n     * @dev    Rounds down from the real value. Caps the result if type exceeds the max\n     *         fixed-point value.\n     * @param x The compounded growth rate as in (1+x). Represted as Q16.48 fixed-point.\n     * @param y The compounded growth rate as in (1+y). Represted as Q16.48 fixed-point.\n     * @returns The cumulative compounded growth rate as in (1+z) = (1+x)*(1+y).\n     *          Represented as Q16.48 fixed-point. */\n    function compoundStack (uint64 x, uint64 y) internal\n        pure returns (uint64) {\n        unchecked {\n        uint256 ONE = FixedPoint.Q48;\n        uint256 num = (ONE + x) * (ONE + y); // Never overflows 256-bits because x and y are 64 bits\n        uint256 term = num >> 48;  // Divide by 48-bit ONE\n        uint256 z = term - ONE; // term will always be >= ONE\n        if (z >= type(uint64).max) { return type(uint64).max; }\n        return uint64(z);\n        }\n    }\n\n    /* @notice Computes the result from backing out a compounded growth value from\n     *         an existing value. The inverse of compoundStack().\n     * @dev    Rounds down from the real value.\n     * @param val The fixed price representing the starting value that we want\n     *            to back out a pre-growth seed from.\n     * @param deflator The compounded growth rate to back out, as in (1+g). Represented\n     *                 as Q16.48 fixed-point\n     * @returns The pre-growth value as in val/(1+g). Rounded down as an unsigned\n     *          integer. */\n    function compoundShrink (uint64 val, uint64 deflator) internal\n        pure returns (uint64) {\n        unchecked {\n        uint256 ONE = FixedPoint.Q48;\n        uint256 multFactor = ONE + deflator; // Never overflows because both fit inside 64 bits\n        uint256 num = uint256(val) << 48; // multiply by 48-bit ONE\n        uint256 z = num / multFactor; // multFactor will never be zero because it's bounded by 1\n        return uint64(z); // Will always fit in 64-bits because shrink can only decrease\n        }\n    }\n    \n    /* @notice Computes the implied compound growth rate based on the division of two\n     *     arbitrary quantities.\n     * @dev    Based on this function's use, calulated growth rate will always be \n     *         capped at 100%. The implied growth rate must always be non-negative.\n     * @param inflated The larger value to be divided. Any 128-bit integer or fixed point\n     * @param seed The smaller value to use as a divisor. Any 128-bit integer or fixed \n     *             point.\n     * @returns The cumulative compounded growth rate as in (1+z) = (1+x)/(1+y).\n     *          Represeted as Q16.48. */\n    function compoundDivide (uint128 inflated, uint128 seed) internal\n        pure returns (uint64) {\n        // Otherwise arithmetic doesn't safely fit in 256 -bit\n        require(inflated < type(uint208).max && inflated >= seed);\n\n        unchecked {\n        uint256 ONE = FixedPoint.Q48;\n        uint256 num = uint256(inflated) << 48;\n        uint256 z = (num / seed) - ONE; // Never underflows because num is always greater than seed\n\n        if (z >= ONE) { return uint64(ONE); }\n        return uint64(z);\n        }\n    }\n\n    /* @notice Calculates a final price from applying a growth rate to a starting price.\n     * @dev    Always rounds in the direction of @shiftUp\n     * @param price The starting price to be compounded. Q64.64 fixed point.\n     * @param growth The compounded growth rate to apply, as in (1+g). Represented\n     *                as Q16.48 fixed-point\n     * @param shiftUp If true compounds the starting price up, so the result will be \n     *                greater. If false, compounds the price down so the result will be\n     *                smaller than the original price.\n     * @returns The post-growth price as in price*(1+g) (or price*(1-g) if shiftUp is \n     *          false). Q64.64 always rounded in the direction of shiftUp. */\n    function compoundPrice (uint128 price, uint64 growth, bool shiftUp) internal\n        pure returns (uint128) {\n        unchecked {\n        uint256 ONE = FixedPoint.Q48;\n        uint256 multFactor = ONE + growth; // Guaranteed to fit in 65-bits\n        \n        if (shiftUp) {\n            uint256 num = uint256(price) * multFactor; // Guaranteed to fit in 193 bits\n            uint256 z = num >> 48; // De-scale by the 48-bit growth precision\n            return (z+1).toUint128(); // Round in the price shift\n        } else {\n            uint256 num = uint256(price) << 48;\n            // No need to safe cast, since this will be smaller than original price\n            return uint128(num / multFactor); \n        }\n        }\n    }\n\n    \n    /* @notice Inflates a starting value by a cumulative growth rate.\n     * @dev    Rounds down from the real value. Result is capped at max(uint128).\n     * @param seed The pre-inflated starting value as unsigned integer\n     * @param growth Cumulative growth rate as Q16.48 fixed-point\n     * @return The ending value = seed * (1 + growth). Rounded down to nearest\n     *         integer value */\n    function inflateLiqSeed (uint128 seed, uint64 growth)\n        internal pure returns (uint128) {\n        unchecked {\n        uint256 ONE = FixedPoint.Q48;\n        uint256 num = uint256(seed) * uint256(ONE + growth); // Guaranteed to fit in 256\n        uint256 inflated = num >> 48; // De-scale by the 48-bit growth precision;\n        \n        if (inflated > type(uint128).max) { return type(uint128).max; }\n        return uint128(inflated);\n        }\n    }\n\n    /* @notice Deflates a starting value by a cumulative growth rate.\n     * @dev    Rounds down from the real value.\n     * @param liq The post-inflated liquidity as unsigned integer\n     * @param growth Cumulative growth rate as Q16.48 fixed-point\n     * @return The ending value = liq / (1 + growth). Rounded down to nearest\n     *         integer value */\n    function deflateLiqSeed (uint128 liq, uint64 growth)\n        internal pure returns (uint128) {\n        unchecked {\n        uint256 ONE = FixedPoint.Q48;\n        uint256 num = uint256(liq) << 48;\n        uint256 deflated = num / (ONE + growth); // Guaranteed to fit in 256-bits\n        \n        // No need to safe cast-- will allways be smaller than starting\n        return uint128(deflated);\n        }\n    }\n}\n"
    },
    "contracts/libraries/CurveAssimilate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport './SafeCast.sol';\nimport './FixedPoint.sol';\nimport './LiquidityMath.sol';\nimport './CompoundMath.sol';\nimport './CurveMath.sol';\n\n/* @title Curve fee assimilation library\n * @notice Provides functionality for incorporating arbitrary token fees into\n *         a locally stable constant-product liquidity curve. */\nlibrary CurveAssimilate {    \n    using LiquidityMath for uint128;\n    using CompoundMath for uint128;\n    using CompoundMath for uint64;\n    using SafeCast for uint256;\n    using FixedPoint for uint128;\n    using CurveMath for CurveMath.CurveState;\n\n    /* @notice Converts token-based fees into ambient liquidity on the curve,\n     *         adjusting the price accordingly.\n     * \n     * @dev The user is responsible to make sure that the price shift will never\n     *      exceed the locally stable range of the liquidity curve. I.e. that\n     *      the price won't cross a book level bump. Because fees are only a tiny\n     *      fraction of swap notional, the best approach is to only collect fees\n     *      on the segment of the notional up to the level bump price limit. If\n     *      a swap spans multiple bumps, then call this function separtely on a\n     *      per-segment basis.\n     *\n     * @param curve  The pre-assimilated state of the consant-product AMM liquidity\n     *    curve. This in memory structure will be updated to reflect the impact of \n     *    the assimilation.\n     * @param feesPaid  The pre-calculated fees to be collected and incorporated\n     *    as liquidity into the curve. Must be denominated (and colleted) on the\n     *    opposite pair side as the swap denomination.\n     * @param isSwapInBase  Set to true, if the swap is denominated in the base\n     *    token of the pair. (And therefore fees are denominated in quote token) */\n    function assimilateLiq (CurveMath.CurveState memory curve, uint128 feesPaid,\n                            bool isSwapInBase) internal pure {\n        // In zero liquidity curves, it makes no sense to assimilate, since\n        // it will run prices to infinity.\n        uint128 liq = CurveMath.activeLiquidity(curve);\n        if (liq == 0) { return; }\n\n        bool feesInBase = !isSwapInBase;\n        uint128 feesToLiq = shaveForPrecision(liq, curve.priceRoot_,\n                                              feesPaid, feesInBase);\n        uint64 inflator = calcLiqInflator(liq, curve.priceRoot_,\n                                          feesToLiq, feesInBase);\n\n        if (inflator > 0) {\n            stepToLiquidity(curve, inflator, feesInBase);\n        }\n    }\n\n    /* @notice Converts a fixed fee collection into a constant product liquidity\n     *         multiplier.\n     * @dev    To be conservative, every fixed point calculation step rounds down.\n     *         Because of this the result can be an arbitrary epsilon smaller than\n     *         the real formula.\n     * @return The imputed percent growth to aggregate liquidity resulting from \n     *         assimilating these fees into the virtual reserves. Represented as\n     *         Q16.48 fixed-point, where the result G is used as a (1+G) multiplier. */\n    function calcLiqInflator (uint128 liq, uint128 price, uint128 feesPaid,\n                              bool inBaseQty) private pure returns (uint64) {\n        // First calculate the virtual reserves at the curve's current price...\n        uint128 reserve = CurveMath.reserveAtPrice(liq, price, inBaseQty);\n \n        // ...Then use that to calculate how much the liqudity would grow assuming the\n        // fees were added as reserves into an equivalent constant-product AMM curve.\n        return calcReserveInflator(reserve, feesPaid);\n    }\n\n    /* @notice Converts a fixed delta change in the virtual reserves to a percent \n     *         change in the AMM curve's active liquidity.\n     *\n     * @dev Inflators above will 100% result in reverted transactions. */\n    function calcReserveInflator (uint128 reserve, uint128 feesPaid)\n        private pure returns (uint64 inflator) {\n        // Short-circuit when virtual reserves are smaller than fees. This can only\n        // occur when liquidity is extremely small, and so is economically\n        // meanignless. But guarantees numerical stability.\n        if (reserve == 0 || feesPaid > reserve) { return 0; }\n        \n        uint128 nextReserve = reserve + feesPaid;\n        uint64 inflatorRoot = nextReserve.compoundDivide(reserve);\n        \n        // Since Liquidity is represented as Sqrt(X*Y) the growth rate of liquidity is\n        // Sqrt(X'/X) where X' = X + delta(X)\n        inflator = inflatorRoot.approxSqrtCompound();\n\n        // Important. The price precision buffer calcualted in assimilateLiq assumes\n        // liquidity will never expand by a factor of 2.0 (i.e. inflator over 1.0 in\n        // Q16.48). See the shaveForPrecision() function comments for more discussion\n        require(inflator < FixedPoint.Q48, \"IF\");\n    }\n\n    /* @notice Adjusts the fees assimilated into the liquidity curve. This is done to\n     *    hold out a small amount of collateral that doesn't expand the liquidity\n     *    in the curve. That's necessary so we have slack in the virtual reserves to\n     *    prevent under-collateralization resulting from fixed point precision rounding\n     *    on the price shift. \n     *    \n     * @dev Price can round up to one precision unit (2^-64) away from the true real\n     *    value. Therefore we have to over-collateralize the existing liquidity by\n     *    enough to buffer the virtual reserves by this amount. Economically this is \n     *    almost always a meaningless amount. Often just 1 wei (rounded up) for all but\n     *    the biggest or most extreme priced curves. \n     *\n     * @return The amount of reward fees available to assimilate into the liquidity\n     *    curve after deducting the precision over-collaterilization allocation. */\n    function shaveForPrecision (uint128 liq, uint128 price, uint128 feesPaid,\n                                bool isFeesInBase)\n        private pure returns (uint128) {\n\n        // The precision buffer is calculated on curve precision, before curve liquidity\n        // expands from fee assimilation. Therefore we upper bound the precision buffer to\n        // account for maximum possible liquidity expansion.\n        //\n        // We set a factor of 2.0, as the bound because that would represnet swap fees\n        // in excess of the entire virtual reserve of the curve. This still allows any\n        // size impact swap (because liquidity fees cannot exceed 100%). The only restrction\n        // is extremely large swaps where fees are collected in input tokens (i.e. fixed\n        // output swaps)\n        //\n        // See the require statement calcReserveInflator function, for where this check\n        // is enforced. \n        uint128 MAX_LIQ_EXPANSION = 2;\n\n        uint128 bufferTokens = MAX_LIQ_EXPANSION * CurveMath.priceToTokenPrecision\n            (liq, price, isFeesInBase);\n        unchecked {\n        return feesPaid <= bufferTokens ?\n            0 : feesPaid - bufferTokens; // Condition assures never underflow\n        }\n    }\n\n    /* @notice Given a targeted aggregate liquidity inflator, affects that change in\n     *    the curve object by expanding the ambient seeds, and adjusting the cumulative\n     *    growth accumulators as needed. \n     *\n     * @dev To be conservative, a number of fixed point calculations will round down \n     *    relative to the exact mathematical liquidity value. This is to prevent \n     *    under-collateralization from over-expanding liquidity relative to virtual \n     *    reserves available to the pool. This means the curve's liquidity grows slightly\n     *    less than mathematical exact calculation would imply. \n     *\n     * @dev    Price is always rounded further in the direction of the shift. This \n     *         shifts the collateralization burden in the direction of the fee-token.\n     *         This makes sure that the opposite token's collateral requirements is\n     *         unchanged. The fee token should be sufficiently over-collateralized from\n     *         a previous adjustment made in shaveForPrecision()\n     *\n     * @param curve The current state of the liquidity curve, will be updated to reflect\n     *              the assimilated liquidity from fee accumulation.\n     * @param inflator The incremental growth in total curve liquidity contributed by this\n     *                 swaps paid fees.\n     * @param feesInBase If true, indicates swap paid fees in base token. */\n    function stepToLiquidity (CurveMath.CurveState memory curve,\n                              uint64 inflator, bool feesInBase) private pure {\n        curve.priceRoot_ = CompoundMath.compoundPrice\n            (curve.priceRoot_, inflator, feesInBase);\n\n        // The formula for Liquidity is\n        //     L = A + C \n        //       = S * (1 + G) + C\n        //   (where A is ambient liqudity, S is ambient seeds, G is ambient growth,\n        //    and C is conc. liquidity)\n        //\n        // Liquidity growth is distributed pro-rata, between the ambient and concentrated\n        // terms. Therefore ambient-side growth is reflected by inflating the growth rate:\n        //    A' = A * (1 + I)\n        //       = S * (1 + G) * (1 + I)\n        //   (where A' is the post transaction ambient liquidity, and I is the liquidity\n        //    inflator for this transaction)\n        //\n        // Note that if the deflator reaches its maximum value (equivalent to 2^16), then\n        // this value will cease accumulating new rewards. Essentially all fees attributable\n        // to ambient liquidity will be burned. Economically speaking, this is unlikely to happen\n        // for any meaningful pool, but be aware. See the Ambient Rewards section of the\n        // documentation at docs/CurveBound.md in the repo for more discussion.\n        curve.seedDeflator_ = curve.seedDeflator_\n            .compoundStack(inflator);\n\n        // Now compute the increase in ambient seed rewards to concentrated liquidity.\n        // Rewards stored as ambient seeds, but collected in the form of liquidity:\n        //    Ar = Sr * (1 + G)\n        //    Sr = Ar / (1 + G)\n        //  (where Ar are concentrated rewards in ambient liquidity, and Sr are\n        //   concentrated rewards denominated in ambient seeds)\n        //\n        // Note that there's a minor difference from using the post-inflated cumulative\n        // ambient growth (G) calculated in the previous step. This rounds the rewards\n        // growth down, which increases numerical over-collateralization.\n\n        // Concentrated rewards are represented as a rate of per unit ambient growth\n        // in seeds. Therefore to calculate the marginal increase in concentrated liquidity\n        // rewards we deflate the marginal increase in total liquidity by the seed-to-liquidity\n        // deflator\n        uint64 concRewards = inflator.compoundShrink(curve.seedDeflator_);\n\n        // Represents the total number of new ambient liquidity seeds that are created from\n        // the swap fees accumulated as concentrated liquidity rewards. (All concentrated rewards\n        // are converted to ambient seeds.) To calculate we take the marginal increase in concentrated\n        // rewards on this swap and multiply by the total amount of active concentrated liquidity.\n        uint128 newAmbientSeeds = uint256(curve.concLiq_.mulQ48(concRewards))\n            .toUint128();\n\n        // To be conservative in favor of over-collateralization, we want to round down the marginal\n        // rewards.\n        curve.concGrowth_ += roundDownConcRewards(concRewards, newAmbientSeeds);\n        curve.ambientSeeds_ += newAmbientSeeds;\n    }\n\n    /* @notice To avoid over-promising rewards, we need to make sure that fixed-point\n     *   rounding effects don't round concentrated rewards growth more than ambient \n     *   seeds. Otherwise we could possibly reach a situation where burned rewards \n     *   exceed the the ambient seeds stored on the curve.\n     *\n     * @dev Functionally, the reward inflator is most likely higher precision than\n     *   the ambient seed injection. Therefore prevous fixed point math that rounds\n     *   down both could over-promise rewards realtive to backed seeds. To correct\n     *   for this, we have to shrink the rewards inflator by the precision unit's \n     *   fraction of the ambient injection. Thus guaranteeing that the adjusted rewards\n     *   inflator under-promises relative to backed seeds. */\n    function roundDownConcRewards (uint64 concInflator, uint128 newAmbientSeeds)\n        private pure returns (uint64) {\n        // No need to round down if the swap was too small for concentrated liquidity\n        // to earn any rewards.\n        if (newAmbientSeeds == 0) { return 0; }\n\n        // We always want to make sure that the rewards accumulator is conservatively\n        // rounded down relative to the actual liquidity being added to the curve.\n        //\n        // To shrink the rewards by ambient round down precision we use the formula:\n        // R' = R * A / (A + 1)\n        //   (where R is the rewards inflator, and A is the ambient seed injection)\n        //\n        // Precision wise this all fits in 256-bit arithmetic, and is guaranteed to\n        // cast to 64-bit result, since the result is always smaller than the original\n        // inflator.\n        return uint64(uint256(concInflator) * uint256(newAmbientSeeds) /\n                      uint256(newAmbientSeeds + 1));\n    }\n}\n"
    },
    "contracts/libraries/CurveCache.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport './CurveMath.sol';\nimport './TickMath.sol';\n\n/* @title Curve caching library.\n * @notice Certain values related to the CurveState aren't stored (to save storage),\n *    but are relatively gas expensive to calculate. As such we want to cache these\n *    calculations in memory whenever possible to avoid duplicated effort. This library\n *    provides a convenient facility for that. */\nlibrary CurveCache {\n    using TickMath for uint128;\n    using CurveMath for CurveMath.CurveState;\n\n    /* @notice Represents the underlying CurveState along with the tick price memory\n     *         cache, and associated bookeeping.\n     * \n     * @param curve_ The underlying CurveState object.\n     * @params isTickClean_ If true, then the current price tick value is valid to use.\n     * @params unsafePriceTick_ The price tick value (if previously cached). User should\n     *              not access directly, but use the pullPriceTick() helper function. */\n    struct Cache {\n        CurveMath.CurveState curve_;\n        bool isTickClean_;\n        int24 unsafePriceTick_;\n    }\n\n    /* @notice Given a curve cache instance retrieves the price tick, if cached, or \n     *         calculates and cached if cache is dirty. */\n    function pullPriceTick (Cache memory cache) internal pure returns (int24) {\n        if (!cache.isTickClean_) {\n            cache.unsafePriceTick_ = cache.curve_.priceRoot_.getTickAtSqrtRatio();\n            cache.isTickClean_ = true;\n        }\n        return cache.unsafePriceTick_;\n    }\n\n    /* @notice Call on a curve cache object, when the underlying price has changed, and\n     *         therefore the cache should be conisdered dirty. */\n    function dirtyPrice (Cache memory cache) internal pure {\n        cache.isTickClean_ = false;\n    }\n}\n"
    },
    "contracts/libraries/CurveMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport './SafeCast.sol';\nimport './FixedPoint.sol';\nimport './LiquidityMath.sol';\nimport './CompoundMath.sol';\n\n/* @title Curve and swap math library\n * @notice Library that defines locally stable constant liquidity curves and\n *         swap struct, as well as functions to derive impact and aggregate \n *         liquidity measures on these objects. */\nlibrary CurveMath {\n    using LiquidityMath for uint128;\n    using CompoundMath for uint256;\n    using SafeCast for uint256;\n    using SafeCast for uint192;\n\n    /* All SdexSwap swaps occur as legs across locally stable constant-product AMM\n     * curves. For large moves across tick boundaries, the state of this curve might \n     * change as range-bound liquidity is kicked in or out of the currently active \n     * curve. But for small moves within tick boundaries (or between tick boundaries \n     * with no liquidity bumps), the curve behaves like a classic constant-product AMM.\n     *\n     * SdexSwap tracks two types of liquidity. 1) Ambient liquidity that is non-\n     * range bound and remains active at all prices from zero to infinity, until \n     * removed by the staking user. 2) Concentrated liquidity that is tied to an \n     * arbitrary lower<->upper tick range and is kicked out of the curve when the\n     * price moves out of range.\n     *\n     * In the SdexSwap model all collected fees are directly incorporated as expanded\n     * liquidity onto the curve itself. (See CurveAssimilate.sol for more on the \n     * mechanics.) All accumulated fees are added as ambient-type liquidity, even those\n     * fees that belong to the pro-rata share of the active concentrated liquidity.\n     * This is because on an aggregate level, we can't break down the pro-rata share\n     * of concentrated rewards to the potentially near infinite concentrated range\n     * possibilities.\n     *\n     * Because of this concentrated liquidity can be flatly represented as 1:1 with\n     * contributed liquidity. Ambient liquidity, in contrast, deflates over time as\n     * it accumulates rewards. Therefore it's represented in terms of seed amount,\n     * i.e. the equivalent of 1 unit of ambient liquidity contributed at the inception\n     * of the pool. As fees accumulate the conversion rate from seed to liquidity \n     * continues to increase. \n     *\n     * Finally concentrated liquidity rewards are represented in terms of accumulated\n     * ambient seeds. This automatically takes care of the compounding of ambient \n     * rewards compounded on top of concentrated rewards. \n     *\n     * @param priceRoot_ The square root of the price ratio exchange rate between the\n     *   base and quote-side tokens in the AMM curve. (represented in Q64.64 fixed point)\n     * @param ambientSeeds_ The total ambient liquidity seeds in the current curve. \n     *   (Inflated by seed deflator to get efective ambient liquidity)\n     * @param concLiq_ The total concentrated liquidity active and in range at the\n     *   current state of the curve.\n     * @param seedDeflator_ The cumulative growth rate (represented as Q16.48 fixed\n     *    point) of a hypothetical 1-unit of ambient liquidity held in the pool since\n     *    inception.\n     * @param concGrowth_ The cumulative rewards growth rate (represented as Q16.48\n     *   fixed point) of hypothetical 1 unit of concentrated liquidity in range in the\n     *   pool since inception. \n     *\n     * @dev Price ratio is stored as a square root because it makes reserve calculation\n     *      arithmetic much easier. To be conservative with collateral these growth \n     *      rates should always be rounded down from their real-value results. Some \n     *      minor lower-bound approximation is fine, since all it will result in is \n     *      slightly smaller reward payouts. */\n    struct CurveState {\n        uint128 priceRoot_;\n        uint128 ambientSeeds_;\n        uint128 concLiq_;\n        uint64 seedDeflator_;\n        uint64 concGrowth_;\n    }\n\n    \n    /* @notice Calculates the total amount of liquidity represented by the liquidity \n     *         curve object.\n     * @dev    Result always rounds down from the real value, *assuming* that the fee\n     *         accumulation fields are conservative lower-bound rounded.\n     * @param curve - The currently active liqudity curve state. Remember this curve \n     *    state is only known to be valid within the current tick.\n     * @return - The total scalar liquidity. Equivalent to sqrt(X*Y) in an equivalent \n     *           constant-product AMM. */\n    function activeLiquidity (CurveState memory curve) internal pure returns (uint128) {\n        uint128 ambient = CompoundMath.inflateLiqSeed\n            (curve.ambientSeeds_, curve.seedDeflator_);\n        return LiquidityMath.addLiq(ambient, curve.concLiq_);\n    }\n\n    /* @notice Similar to calcLimitFlows(), except returns the max possible flow in the\n     *   *opposite* direction. I.e. if inBaseQty_ is True, returns the quote token flow\n     *   for the swap. And vice versa..\n     *\n     * @dev The fixed-point result approximates the real valued formula with close but\n     *   directionally unpredicable precision. It could be slightly above or slightly\n     *   below. In the case of zero flows this could be substantially over. This \n     *   function should not be used in any context with strict directional boundness \n     *   requirements. */\n    function calcLimitCounter (CurveState memory curve, uint128 swapQty, bool inBaseQty,\n                               uint128 limitPrice) internal pure returns (uint128) {\n        bool isBuy = limitPrice > curve.priceRoot_;\n        uint128 denomFlow = calcLimitFlows(curve, swapQty, inBaseQty, limitPrice);\n        return invertFlow(activeLiquidity(curve), curve.priceRoot_,\n                          denomFlow, isBuy, inBaseQty);\n    }\n\n    /* @notice Calculates the total quantity of tokens that can be swapped on the AMM\n     *   curve until either 1) the limit price is reached or 2) the swap fills its \n     *   entire remaining quantity.\n     *\n     * @dev This function does *NOT* account for the possibility of concentrated liq\n     *   being knocked in/out as the price on the AMM curve moves across tick boundaries.\n     *   It's the responsibility of the caller to properly check whether the limit price\n     *   is within the bounds of the locally stable curve.\n     *\n     * @dev As long as CurveState's fee accum fields are conservatively lower bounded,\n     *   and as long as limitPrice is accurate, then this function rounds down from the\n     *   true real value. At most this round down loss of precision is tightly bounded at\n     *   2 wei. (See comments in deltaPriceQuote() function)\n     * \n     * @param curve - The current state of the liquidity curve. No guarantee that it's\n     *   liquidity stable through the entire limit range (see @dev above). Note that this\n     *   function does *not* update the curve struct object.   \n     * @param swapQty - The total remaining quantity left in the swap.\n     * @param inBaseQty - Whether the swap quantity is denomianted in base or quote side\n     *                    token.\n     * @param limitPrice - The highest (lowest) acceptable ending price of the AMM curve\n     *   for a buy (sell) swap. Represented as Q64.64 fixed point square root of the \n     *   price. \n     *\n     * @return - The maximum executable swap flow (rounded down by fixed precision).\n     *           Denominated on the token side based on inBaseQty param. Will\n     *           always return unsigned magnitude regardless of the direction. User\n     *           can easily determine based on swap context. */\n    function calcLimitFlows (CurveState memory curve, uint128 swapQty,\n                             bool inBaseQty, uint128 limitPrice)\n        internal pure returns (uint128) {\n        uint128 limitFlow = calcLimitFlows(curve, inBaseQty, limitPrice);\n        return limitFlow > swapQty ? swapQty : limitFlow;\n    }\n    \n    function calcLimitFlows (CurveState memory curve, bool inBaseQty,\n                             uint128 limitPrice) private pure returns (uint128) {\n        uint128 liq = activeLiquidity(curve);\n        return inBaseQty ?\n            deltaBase(liq, curve.priceRoot_, limitPrice) :\n            deltaQuote(liq, curve.priceRoot_, limitPrice);\n    }\n\n    /* @notice Calculates the change to base token reserves associated with a price\n     *   move along an AMM curve of constant liquidity.\n     *\n     * @dev Result is a tight lower-bound for fixed-point precision. Meaning if the\n     *   the returned limit is X, then X will be inside the limit price and (X+1)\n     *   will be outside the limit price. */\n    function deltaBase (uint128 liq, uint128 priceX, uint128 priceY)\n        internal pure returns (uint128) {\n        unchecked {\n        uint128 priceDelta = priceX > priceY ?\n            priceX - priceY : priceY - priceX; // Condition assures never underflows\n        return reserveAtPrice(liq, priceDelta, true);\n        }\n    }\n\n    /* @notice Calculates the change to quote token reserves associated with a price\n     *   move along an AMM curve of constant liquidity.\n     * \n     * @dev Result is almost always within a fixed-point precision unit from the true\n     *   real value. However in certain rare cases, the result could be up to 2 wei\n     *   below the true mathematical value. Caller should account for this */\n    function deltaQuote (uint128 liq, uint128 price, uint128 limitPrice)\n        internal pure returns (uint128) {\n        // For purposes of downstream calculations, we make sure that limit price is\n        // larger. End result is symmetrical anyway\n        if (limitPrice > price) {\n            return calcQuoteDelta(liq, limitPrice, price);\n        } else {\n            return calcQuoteDelta(liq, price, limitPrice);\n        }\n    }\n\n    /* The formula calculated is\n     *    F = L * d / (P*P')\n     *   (where F is the flow to the limit price, where L is liquidity, d is delta, \n     *    P is price and P' is limit price)\n     *\n     * Calculating this requires two stacked mulDiv. To meet the function's contract\n     * we need to compute the result with tight fixed point boundaries at or below\n     * 2 wei to conform to the function's contract.\n     * \n     * The fixed point calculation of flow is\n     *    F = mulDiv(mulDiv(...)) = FR - FF\n     *  (where F is the fixed point result of the formula, FR is the true real valued\n     *   result with inifnite precision, FF is the loss of precision fractional round\n     *   down, mulDiv(...) is a fixed point mulDiv call of the form X*Y/Z)\n     *\n     * The individual fixed point terms are\n     *    T1 = mulDiv(X1, Y1, Z1) = T1R - T1F\n     *    T2 = mulDiv(T1, Y2, Z2) = T2R - T2F\n     *  (where T1 and T2 are the fixed point results from the first and second term,\n     *   T1R and T2R are the real valued results from an infinite precision mulDiv,\n     *   T1F and T2F are the fractional round downs, X1/Y1/Z1/Y2/Z2 are the arbitrary\n     *   input terms in the fixed point calculation)\n     *\n     * Therefore the total loss of precision is\n     *    FF = T2F + T1F * T2R/T1\n     *\n     * To guarantee a 2 wei precision loss boundary:\n     *    FF <= 2\n     *    T2F + T1F * T2R/T1 <= 2\n     *    T1F * T2R/T1 <=  1      (since T2F as a round-down is always < 1)\n     *    T2R/T1 <= 1             (since T1F as a round-down is always < 1)\n     *    Y2/Z2 >= 1\n     *    Z2 >= Y2 */\n    function calcQuoteDelta (uint128 liq, uint128 priceBig, uint128 priceSmall)\n        private pure returns (uint128) {\n        uint128 priceDelta = priceBig - priceSmall;\n\n        // This is cast to uint256 but is guaranteed to be less than 2^192 based off\n        // the return type of divQ64\n        uint256 termOne = FixedPoint.divQ64(liq, priceSmall);\n        \n        // As long as the final result doesn't overflow from 128-bits, this term is\n        // guaranteed not to overflow from 256 bits. That's because the final divisor\n        // can be at most 128-bits, therefore this intermediate term must be 256 bits\n        // or less.\n        //\n        // By definition priceBig is always larger than priceDelta. Therefore the above\n        // condition of Z2 >= Y2 is satisfied and the equation caps at a maximum of 2\n        // wei of precision loss.\n        uint256 termTwo = termOne * uint256(priceDelta) / uint256(priceBig);\n        return termTwo.toUint128();\n    }\n\n    /* @notice Returns the amount of virtual reserves give the price and liquidity of the\n     *   constant-product liquidity curve.\n     *\n     * @dev The actual pool probably holds significantly less collateral because of the \n     *   use of concentrated liquidity. \n     * @dev Results always round down from the precise real-valued mathematical result.\n     * \n     * @param liq - The total active liquidity in AMM curve. Represented as sqrt(X*Y)\n     * @param price - The current active (square root of) price of the AMM curve. \n     *                 represnted as Q64.64 fixed point\n     * @param inBaseQty - The side of the pool to calculate the virtual reserves for.\n     *\n     * @returns The virtual reserves of the token (rounded down to nearest integer). \n     *   Equivalent to the amount of tokens that would be held for an equivalent \n     *   classical constant- product AMM without concentrated liquidity.  */\n    function reserveAtPrice (uint128 liq, uint128 price, bool inBaseQty)\n        internal pure returns (uint128) {\n        return (inBaseQty ?\n                    uint256(FixedPoint.mulQ64(liq, price)) :\n                    uint256(FixedPoint.divQ64(liq, price))).toUint128();\n    }\n\n    /* @notice Calculated the amount of concentrated liquidity within a price range\n     *         supported by a fixed amount of collateral. Note that this calculates the \n     *         collateral only needed by one side of the pair.\n     *\n     * @dev    Always rounds fixed-point arithmetic result down. \n     *\n     * @param collateral The total amount of token collateral being pledged.\n     * @param inBase If true, the collateral represents the base-side token in the pair.\n     *               If false the quote side token.\n     * @param priceX The price boundary of the concentrated liquidity position.\n     * @param priceY The other price boundary of the concentrated liquidity position.\n     * @returns The total amount of liquidity supported by the collateral. */\n    function liquiditySupported (uint128 collateral, bool inBase,\n                                 uint128 priceX, uint128 priceY)\n        internal pure returns (uint128) {\n        if (!inBase) {\n            return liquiditySupported(collateral, true,\n                                      FixedPoint.recipQ64(priceX),\n                                      FixedPoint.recipQ64(priceY));\n        } else {\n            unchecked {\n            uint128 priceDelta = priceX > priceY ?\n                priceX - priceY : priceY - priceX; // Conditional assures never underflows\n            return liquiditySupported(collateral, true, priceDelta);\n            }\n        }\n    }\n\n    /* @notice Calculated the amount of ambient liquidity supported by a fixed amount of \n     *         collateral. Note that this calculates the collateral only needed by one\n     *         side of the pair.\n     *\n     * @dev    Always rounds fixed-point arithmetic result down. \n     *\n     * @param collateral The total amount of token collateral being pledged.\n     * @param inBase If true, the collateral represents the base-side token in the pair.\n     *               If false the quote side token.\n     * @param price The current (square root) price of the curve as Q64.64 fixed point.\n     * @returns The total amount of ambient liquidity supported by the collateral. */\n    function liquiditySupported (uint128 collateral, bool inBase, uint128 price)\n        internal pure returns (uint128) {\n        return inBase ?\n            FixedPoint.divQ64(collateral, price).toUint128By192() :\n            FixedPoint.mulQ64(collateral, price).toUint128By192();\n    }\n\n    /* @dev The fixed point arithmetic results in output that's a close approximation\n     *   to the true real value, but could be skewed in either direction. The output\n     *   from this function should not be consumed in any context that requires strict\n     *   boundness. */\n    function invertFlow (uint128 liq, uint128 price, uint128 denomFlow,\n                         bool isBuy, bool inBaseQty) private pure returns (uint128) {\n        if (liq == 0) { return 0; }\n\n        uint256 invertReserve = reserveAtPrice(liq, price, !inBaseQty);\n        uint256 initReserve = reserveAtPrice(liq, price, inBaseQty);\n\n        unchecked {\n        uint256 endReserve = (isBuy == inBaseQty) ?\n            initReserve + denomFlow : // Will always fit in 256-bits\n            initReserve - denomFlow; // flow is always less than total reserves\n        if (endReserve == 0) { return type(uint128).max; }\n        \n        uint256 endInvert = uint256(liq) * uint256(liq) / endReserve;\n        return (endInvert > invertReserve ?\n                endInvert - invertReserve :\n                invertReserve - endInvert).toUint128();\n        }\n     }\n\n    /* @notice Computes the amount of token over-collateralization needed to buffer any \n     *   loss of precision rounding in the fixed price arithmetic on curve price. This\n     *   is necessary because price occurs in different units than tokens, and we can't\n     *   assume a single wei is sufficient to buffer one price unit.\n     * \n     * @dev In practice the price unit precision is almost always smaller than the token\n     *   token precision. Therefore the result is usually just 1 wei. The exception are\n     *   pools where liquidity is very high or price is very low. \n     *\n     * @param liq The total liquidity in the curve.\n     * @param price The (square root) price of the curve in Q64.64 fixed point\n     * @param inBase If true calculate the token precision on the base side of the pair.\n     *               Otherwise, calculate on the quote token side. \n     *\n     * @return The conservative upper bound in number of tokens that should be \n     *   burned to over-collateralize a single precision unit of price rounding. If\n     *   the price arithmetic involves multiple units of precision loss, this number\n     *   should be multiplied by that factor. */\n    function priceToTokenPrecision (uint128 liq, uint128 price,\n                                    bool inBase) internal pure returns (uint128) {\n        unchecked {\n        // To provide more base token collateral than price precision rounding:\n        //     delta(B) >= L * delta(P)\n        //     delta(P) <= 2^-64  (64 bit precision rounding)\n        //     delta(B) >= L * 2^-64\n        //  (where L is liquidity, B is base token reserves, P is price)\n        if (inBase) {\n            // Since liq is shifted right by 64 bits, adding one can never overflow\n            return (liq >> 64) + 1; \n            \n        } else {\n            // Calculate the quote reservs at the current price and a one unit price step,\n            // then take the difference as the minimum required quote tokens needed to\n            // buffer that price step.\n            uint192 step = FixedPoint.divQ64(liq, price - 1);\n            uint192 start = FixedPoint.divQ64(liq, price);\n\n            // next reserves will always be equal or greater than start reserves, so the \n            // subtraction will never underflow. \n            uint192 delta = step - start;\n\n            // Round tokens up conservative.\n            // This will never overflow because 192 bit nums incremented by 1 will always fit in\n            // 256 bits.\n            uint256 deltaRound = uint256(delta) + 1;\n\n            return deltaRound.toUint128();\n        }\n        }\n    }\n\n}\n"
    },
    "contracts/libraries/CurveRoll.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport './SafeCast.sol';\nimport './FixedPoint.sol';\nimport './LiquidityMath.sol';\nimport './CompoundMath.sol';\nimport './CurveMath.sol';\n\n/* @title Curve roll library\n * @notice Provides functionality for rolling swap flows onto a constant-product\n *         AMM liquidity curve. */\nlibrary CurveRoll {\n    using SafeCast for uint256;\n    using SafeCast for uint128;\n    using LiquidityMath for uint128;\n    using CompoundMath for uint256;\n    using CurveMath for CurveMath.CurveState;\n    using CurveMath for uint128;\n\n    /* @notice Applies a given flow onto a constant product AMM curve, adjusts the curve\n     *   price, and outputs accumulator deltas on both sides.\n     *\n     * @dev Note that this function does *NOT* check whether the curve is liquidity \n     *   stable through the flow impact. It's the callers job to make sure that the \n     *   impact doesn't cross through any tick barrier that knocks concentrated liquidity\n     *   in/out. \n     *\n     * @param curve - The current state of the active liquidity curve. After calling\n     *   this struct will be updated with the post-swap price. Note that none of the\n     *   fee accumulator fields are adjusted. This function does *not* collect or apply\n     *   liquidity fees. It's the callers responsibility to handle fees outside this\n     *   call.\n     * @param flow - The amount of tokens to swap on this leg. In certain cases this \n     *   number may be a fixed point estimate based on a price target. Collateral safety\n     *   is guaranteed with up to 2 wei of precision loss.\n     * @param inBaseQty - If true, the above flow applies to the base-side tokens in the\n     *                    pair. If false, applies to the quote-side tokens.\n     * @param isBuy - If true, the flows are paying base tokens to the pool and receiving\n     *                quote tokens. (Hence pushing the price up.) If false, vice versa.\n     * @param swapQty - The total quantity left on the swap across all legs. May or may\n     *                  not be equal to flow, or could be left depending on whether this\n     *                  leg will fill the entire quantity.\n     *\n     * @return baseFlow - The signed flow of the base-side tokens. Negative means the flow\n     *              is being paid from the pool to the user. Positive means the flow is\n     *              being paid from the user to the pool.\n     * @return quoteFlow - The signed flow of the quote-side tokens.\n     * @return qtyLeft - The amount of swapQty remaining after the flow from this leg is\n     *                   processed. */\n    function rollFlow (CurveMath.CurveState memory curve, uint128 flow,\n                       bool inBaseQty, bool isBuy, uint128 swapQty)\n        internal pure returns (int128, int128, uint128) {\n        (uint128 counterFlow, uint128 nextPrice) = deriveImpact\n            (curve, flow, inBaseQty, isBuy);\n        (int128 paidFlow, int128 paidCounter) = signFlow\n            (flow, counterFlow, inBaseQty, isBuy);\n        return setCurvePos(curve, inBaseQty, isBuy, swapQty,\n                           nextPrice, paidFlow, paidCounter);\n    }\n\n    /* @notice Moves a curve to a pre-determined price target, and calculates the flows\n     *   as necessary to reach the target. The final curve will end at exactly that price\n     *   and the flows are set to guarantee incremental collateral safety.\n     *\n     * @dev Note that this function does *NOT* check whether the curve is liquidity \n     *   stable through the swap impact. It's the callers job to make sure that the \n     *   impact doesn't cross through any tick barrier that knocks concentrated liquidity\n     *   in/out. \n     *\n     * @param curve - The current state of the active liquidity curve. After calling\n     *   this struct will be updated with the post-swap price. Note that none of the\n     *   fee accumulator fields are adjusted. This function does *not* collect or apply\n     *   liquidity fees. It's the callers responsibility to handle fees outside this\n     *   call.\n     * @param price - The target limit price that the curve is being rolled to. Defined\n     *                as Q64.64 fixed point.\n     * @param inBaseQty - If true, the above flow applies to the base-side tokens in the\n     *                    pair. If false, applies to the quote-side tokens.\n     * @param isBuy - If true, the flows are paying base tokens to the pool and receiving\n     *                quote tokens. (Hence pushing the price up.) If false, vice versa.\n     * @param swapQty - The total quantity left on the swap across all legs. May or may\n     *                  not be equal to flow, or could be left depending on whether this\n     *                  leg will fill the entire quantity.\n     *\n     * @return baseFlow - The signed flow of the base-side tokens. Negative means the flow\n     *              is being paid from the pool to the user. Positive means the flow is\n     *              being paid from the user to the pool.\n     * @return quoteFlow - The signed flow of the quote-side tokens.\n     * @return qtyLeft - The amount of swapQty remaining after the flow from this leg is\n     *                   processed. */\n    function rollPrice (CurveMath.CurveState memory curve, uint128 price,\n                        bool inBaseQty, bool isBuy, uint128 swapQty)\n        internal pure returns (int128, int128, uint128)  {\n        (uint128 flow, uint128 counterFlow) = deriveDemand(curve, price, inBaseQty);\n        (int128 paidFlow, int128 paidCounter) = signFixed\n            (flow, counterFlow, inBaseQty, isBuy);\n        return setCurvePos(curve, inBaseQty, isBuy, swapQty, price,\n                           paidFlow, paidCounter);\n    }\n\n    /* @notice Called when a curve has reached its a  bump barrier. Because the \n     *   barrier occurs at the final price in the tick, we need to \"shave the price\"\n     *   over into the next tick. The curve has kicked in liquidity that's only active\n     *   below this price, and we need the price to reflect the correct tick. So we burn\n     *   an economically meaningless amount of collateral token wei to shift the price \n     *   down by exactly one unit of precision into the next tick. */\n    function shaveAtBump (CurveMath.CurveState memory curve,\n                          bool inBaseQty, bool isBuy, uint128 swapLeft)\n        pure internal returns (int128, int128, uint128) {\n        uint128 burnDown = CurveMath.priceToTokenPrecision\n            (curve.activeLiquidity(), curve.priceRoot_, inBaseQty);\n        require(swapLeft > burnDown, \"BD\");\n        \n        if (isBuy) {\n            return setShaveUp(curve, inBaseQty, burnDown);\n        } else {\n            return setShaveDown(curve, inBaseQty, burnDown);\n        }\n    }\n\n    /* @notice After calculating a burn down amount of collateral, roll the curve over\n     *         into the next tick below the current tick. \n     *\n     * @dev    This is used to handle the situation when we've reached the end of a liquidity\n     *         range, and need to safely move the curve by one price unit to move it over into\n     *         the next liquidity range. Although a single price unit is almost always economically\n     *         de minims, there are small flows needed to move the curve price while remaining safely\n     *         over-collateralized.\n     *\n     * @param curve The liquidity curve, which will be adjusted to move the price one unit.\n     * @param inBaseQty If true indicates that the swap is made with fixed base tokens and floating quote\n     *                  tokens.\n     * @param burnDown The pre-calculated amount of tokens needed to maintain over-collateralization when\n     *                 moving the curve by one price unit.\n     * \n     * @return paidBase The additional amount of base tokens that the swapper should pay to the curve to\n     *                  move the price one unit.\n     * @return paidQuote The additional amount of quote tokens the swapper should pay to the curve.\n     * @return burnSwap  The amount of tokens to remove from the remaining fixed leg of the swap quantity. */\n    function setShaveDown (CurveMath.CurveState memory curve, bool inBaseQty,\n                           uint128 burnDown) private pure\n        returns (int128 paidBase, int128 paidQuote, uint128 burnSwap) {\n        unchecked {\n        if (curve.priceRoot_ > TickMath.MIN_SQRT_RATIO) {\n            curve.priceRoot_ -= 1; // MIN_SQRT is well above uint128 0\n        }\n\n        // When moving the price down at constant liquidity, no additional base tokens are required for\n        // collateralization\n        paidBase = 0;\n\n        // When moving the price down at constant liquidity, the swapper must pay a small amount of additional\n        // quote tokens to keep the curve over-collateralized.\n        paidQuote = burnDown.toInt128Sign();\n        \n        // If the fixed swap leg is in base tokens, then this has zero impact, if the swap leg is in quote\n        // tokens then we have to adjust the deduct the quote tokens the user paid above from the remaining swap\n        // quantity\n        burnSwap = inBaseQty ? 0 : burnDown;\n        }\n    }\n\n    /* @notice After calculating a burn down amount of collateral, roll the curve over\n     *         into the next tick above the current tick. */\n    function setShaveUp (CurveMath.CurveState memory curve, bool inBaseQty,\n                         uint128 burnDown) private pure\n        returns (int128 paidBase, int128 paidQuote, uint128 burnSwap) {\n        unchecked {\n        if (curve.priceRoot_ < TickMath.MAX_SQRT_RATIO - 1) {\n            curve.priceRoot_ += 1; // MAX_SQRT is well below uint128.max\n        }\n        // When moving the price up at constant liquidity, no additional quote tokens are required for\n        // collateralization\n        paidQuote = 0;\n\n        // When moving the price up at constant liquidity, the swapper must pay a small amount of additional\n        // base tokens to keep the curve over-collateralized.\n        paidBase = burnDown.toInt128Sign();\n        \n        // If the fixed swap leg is in quote tokens, then this has zero impact, if the swap leg is in base\n        // tokens then we have to adjust the deduct the quote tokens the user paid above from the remaining swap\n        // quantity\n        burnSwap = inBaseQty ? burnDown : 0;\n        }\n    }\n\n    /* @notice After previously calculating the denominated and counter-denominated flows,\n     *         this function assigns those to the correct side of the pair and decrements\n     *         the total swap quantity by the amount spent. */\n    function setCurvePos (CurveMath.CurveState memory curve,\n                          bool inBaseQty, bool isBuy, uint128 swapQty,\n                          uint128 price, int128 paidFlow, int128 paidCounter)\n        private pure returns (int128 paidBase, int128 paidQuote, uint128 qtyLeft) {\n        uint128 spent = flowToSpent(paidFlow, inBaseQty, isBuy);\n        \n        if (spent >= swapQty) {\n            qtyLeft = 0;\n        } else {\n            qtyLeft = swapQty - spent;\n        }\n\n        paidBase = (inBaseQty ? paidFlow : paidCounter);\n        paidQuote = (inBaseQty ? paidCounter : paidFlow); \n        curve.priceRoot_ = price;\n    }\n\n    /* @notice Convert a signed paid flow to a decrement to apply to swap qty left. */\n    function flowToSpent (int128 paidFlow, bool inBaseQty, bool isBuy)\n        private pure returns (uint128) {\n        int128 spent = (inBaseQty == isBuy) ? paidFlow : -paidFlow;\n        if (spent < 0) { return 0; }\n        return uint128(spent);\n    }\n\n    /* @notice Calculates the flow and counterflow associated with moving the constant\n     *         product curve to a target price.\n     * @dev    Both sides of the flow are rounded down at up to 2 wei of precision loss\n     *         (see CurveMath.sol). The results should not be used directly without \n     *         buffering the counterflow in the direction of collateral support. */\n    function deriveDemand (CurveMath.CurveState memory curve, uint128 price,\n                           bool inBaseQty) private pure\n        returns (uint128 flow, uint128 counterFlow) {\n        uint128 liq = curve.activeLiquidity();\n        uint128 baseFlow = liq.deltaBase(curve.priceRoot_, price);\n        uint128 quoteFlow = liq.deltaQuote(curve.priceRoot_, price);\n        if (inBaseQty) {\n            (flow, counterFlow) = (baseFlow, quoteFlow);\n        } else {\n            (flow, counterFlow) = (quoteFlow, baseFlow);\n            \n        }\n    }\n\n    /* @notice Given a fixed swap flow on a cosntant product AMM curve, calculates\n     *   the final price and counterflow. This function assumes that the AMM curve is\n     *   constant product stable through the impact range. It's the caller's \n     *   responsibility to check that we're not passing liquidity bump tick boundaries.\n     *\n     * @dev The price and counter-flow guarantee collateral stability on the AMM curve.\n     *   Because of fixed-point effects the price may be arbitarily rounded, but the \n     *   counter-flow will always be set correctly to match. The result of this function\n     *   is based on the AMM curve being constant through the entire range. Note that \n     *   this function only calulcates a result it does *not* write into the Curve or \n     *   Swap structs.\n     *\n     * @param curve The constant-product AMM curve\n     * @param flow  The fixed token flow from the side the swap is denominated in.\n     * @param inBaseQty If true, the flow is denominated in base-side tokens.\n     * @param isBuy If true, the flows are paying base tokens to the pool and receiving\n     *              quote tokens.\n     *\n     * @return counterFlow The magnitude of token flow on the opposite side the swap\n     *                     is denominated in. Note that this value is *not* signed. Also\n     *                     note that this value is always rounded down. \n     * @return nextPrice   The ending price of the curve assuming the full flow is \n     *                     processed. Note that this value is *not* written into the \n     *                     curve struct. */\n    function deriveImpact (CurveMath.CurveState memory curve, uint128 flow,\n                           bool inBaseQty, bool isBuy) internal pure\n        returns (uint128 counterFlow, uint128 nextPrice) {\n        uint128 liq = curve.activeLiquidity();\n        nextPrice = deriveFlowPrice(curve.priceRoot_, liq, flow, inBaseQty, isBuy);\n\n        /* We calculate the counterflow exactly off the computed price. Ultimately safe\n         * collateralization only cares about the price, not the contravening flow.\n         * Therefore we always compute based on the final, rounded price, not from the\n         * original fixed flow. */\n        counterFlow = !inBaseQty ?\n            liq.deltaBase(curve.priceRoot_, nextPrice) :\n            liq.deltaQuote(curve.priceRoot_, nextPrice);\n    }\n\n    /* @dev The end price is always rounded to the inside of the flow token:\n     *\n     *       Flow   |   Dir   |  Price Roudning  | Loss of Precision\n     *     ---------------------------------------------------------------\n     *       Base   |   Buy   |     Down         |    1 wei\n     *       Base   |   Sell  |     Down         |    1 wei\n     *       Quote  |   Buy   |     Up           |   Arbitrary\n     *       Quote  |   Sell  |     Up           |   Arbitrary\n     * \n     *   This guarantees that the pool is adaquately collateralized given the flow of the\n     *   fixed side. Because of the arbitrary roudning, it's critical that the counter-\n     *   flow is computed using the exact price returned by this function, and not \n     *   independently. */\n    function deriveFlowPrice (uint128 price, uint128 liq,\n                              uint128 flow, bool inBaseQty, bool isBuy)\n        private pure returns (uint128) {\n        uint128 curvePrice = inBaseQty ?\n            calcBaseFlowPrice(price, liq, flow, isBuy) :\n            calcQuoteFlowPrice(price, liq, flow, isBuy);\n\n        if (curvePrice >= TickMath.MAX_SQRT_RATIO) { return TickMath.MAX_SQRT_RATIO - 1;}\n        if (curvePrice < TickMath.MIN_SQRT_RATIO) { return TickMath.MIN_SQRT_RATIO; }\n        return curvePrice;\n    }\n\n    /* Because the base flow is fixed, we want to always set the price in favor of \n     * base token over-collateralization. Upstream, we'll independently set quote token\n     * flows based off the price calculated here. Since higher price increases base \n     * collateral, we round price down regardless of whether the fixed base flow is a \n     * buy or a sell. \n     *\n     * This seems counterintuitive when base token is the output, but even then moving \n     * the price further down will increase the quote token input and over-collateralize\n     * the base token. The max loss of precision is 1 unit of fixed-point price. */\n    function calcBaseFlowPrice (uint128 price, uint128 liq, uint128 flow, bool isBuy)\n        private pure returns (uint128) {\n        if (liq == 0) { return type(uint128).max; }\n        \n        uint192 deltaCalc = FixedPoint.divQ64(flow, liq);\n        if (deltaCalc > type(uint128).max) { return type(uint128).max; }\n        uint128 priceDelta = uint128(deltaCalc);\n        \n        /* For a fixed amount of base flow tokens, the resulting price should be conservatively\n         * rounded down. Since Price = [Base Reserves]/[Quote Reserves], rounding price down\n         * is equivalent to rounding the curve to be over collateralized relative to the actual\n         * physical base tokens. */\n        if (isBuy) {\n            // Since priceDelta is rounded down to the lower unit, this equation rounds down the\n            // the price by up to 1 unit\n            return price + priceDelta;\n\n        } else {\n            if (priceDelta >= price) { return 0; }\n            // priceDelta is rounded down by a maximum of 1 unit, so adding 1 to the subtracted\n            // priceDelta value rounds price down by up to 1 unit.\n            return price - (priceDelta + 1);\n        }\n    }\n\n    /* The same rounding logic as calcBaseFlowPrice applies, but because it's the \n     * opposite side we want to conservatively round the price *up*, regardless of \n     * whether it's a buy or sell. \n     * \n     * Calculating flow price for quote flow is more complex because the flow delta \n     * applies to the inverse of the price. So when calculating the inverse, we make \n     * sure to round in the direction that rounds up the final price. */\n    function calcQuoteFlowPrice (uint128 price, uint128 liq, uint128 flow, bool isBuy)\n        private pure returns (uint128) {\n        // Since this is a term in the quotient rounding down, rounds up the final price\n        uint128 invPrice = FixedPoint.recipQ64(price);\n        // This is also a quotient term so we use this function's round down logic\n        uint128 invNext = calcBaseFlowPrice(invPrice, liq, flow, !isBuy);\n        if (invNext == 0) { return TickMath.MAX_SQRT_RATIO; }\n        return FixedPoint.recipQ64(invNext) + 1;\n    }\n\n\n    // Max round precision loss on token flow is 2 wei, but a 4 wei cushion provides\n    // extra margin and is economically meaningless.\n    int128 constant ROUND_PRECISION_WEI = 4;\n\n    /* @notice Correctly assigns the signed direction to the unsigned flow and counter\n     *   flow magnitudes that were previously computed for a fixed flow swap. Positive \n     *   sign implies the flow is being received by the pool, negative that it's being \n     *   received by the user. */\n    function signFlow (uint128 flowMagn, uint128 counterMagn,\n                       bool inBaseQty, bool isBuy)\n        private pure returns (int128 flow, int128 counter) {\n        (flow, counter) = signMagn(flowMagn, counterMagn, inBaseQty, isBuy);\n        // Conservatively round directional counterflow in the direction of the pool's\n        // collateral. Don't round swap flow because that's a fixed target. \n        counter = counter + ROUND_PRECISION_WEI;\n    }\n\n    /* @notice Same as signFlow, but used for the flow from a price target swap leg. */\n    function signFixed (uint128 flowMagn, uint128 counterMagn,\n                        bool inBaseQty, bool isBuy)\n        private pure returns (int128 flow, int128 counter) {\n        (flow, counter) = signMagn(flowMagn, counterMagn, inBaseQty, isBuy);\n        // In a price target, bothsides of the flow are floating, and have to be rounded\n        // in pool's favor to conservatively accomodate the price precision.\n        flow = flow + ROUND_PRECISION_WEI;\n        counter = counter + ROUND_PRECISION_WEI;\n    }\n\n    /* @notice Takes an unsigned flow magntiude and correctly signs it based on the\n     *         directional and denomination of the flows. */\n    function signMagn (uint128 flowMagn, uint128 counterMagn,\n                       bool inBaseQty, bool isBuy)\n        private pure returns (int128 flow, int128 counter) {\n        \n        if (inBaseQty == isBuy) {\n            (flow, counter) = (flowMagn.toInt128Sign(), -counterMagn.toInt128Sign());\n        } else {\n            (flow, counter) = (-flowMagn.toInt128Sign(), counterMagn.toInt128Sign());\n        }\n        \n        \n    }\n}\n"
    },
    "contracts/libraries/Directives.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport \"./SafeCast.sol\";\n\n/* @title Directive library\n * @notice This library defines common structs and associated helper functions for\n *         user defined trade action directives. */\nlibrary Directives {\n    using SafeCast for int256;\n    using SafeCast for uint256;\n\n    /* @notice Defines a single requested swap on a pre-specified pool.\n     *\n     * @dev A directive indicating no swap action must set *both* qty and limitPrice to\n     *      zero. qty=0 alone will indicate the use of a flexible back-filled rolling \n     *      quantity. \n     *\n     * @param isBuy_ If true, swap converts base-side token to quote-side token.\n     *               Vice-versa if false.\n     * @param inBaseQty_ If true, swap quantity is denominated in base-side token. \n     *                   If false in quote side token.\n     * @param rollType_  The flavor of rolling gap fill that should be applied (if any)\n     *                   to this leg of the directive. See Chaining.sol for list of\n     *                   rolling type codes.\n     * @param qty_ The total amount to be swapped. (Or rolling target if rollType_ is \n     *             enabled)\n     * @param limitPrice_ The maximum (minimum) *price to pay, if a buy (sell) swap\n     *           *at the margin*. I.e. the swap will keep exeucting until the curve\n     *           reaches this price (or exhausts the specified quantity.) Represented\n     *           as the square root of the pool's price ratio in Q64.64 fixed-point. */\n    struct SwapDirective {\n        bool isBuy_;\n        bool inBaseQty_;\n        uint8 rollType_;\n        uint128 qty_;\n        uint128 limitPrice_;\n    }\n\n    /* @notice Defines a sequence of mint/burn actions related to concentrated liquidity\n     *         range orders on a single pool.\n     *\n     * @param lowTick_ A single tick index that defines one side of the range order \n     *                 boundary for all range orders in this directive.\n     * @param highTick_ The tick index of the other side of the boundary of the range\n     *                  order.\n     * @param isAdd_ If true, the action mints new concentrated liquidity. If false, it\n     *               burns pre-existing concentrated liquidity. \n     * @param isTickRel_  If true indicates the low and high tick value should be take\n     *                    relative to the current price tick. E.g. -5 indicates 5 ticks\n     *                    below the current tick. Otherwise, high and low tick values are\n     *                    absolute tick index values.\n     * @param rollType_  The flavor of rolling gap fill that should be applied (if any)\n     *                   to this leg of the directive. See Chaining.sol for list of\n     *                   rolling type codes.\n     * @param liquidity_ The total amount of concentrated liquidity to add/remove.\n     *                   Represented as the equivalent of sqrt(X*Y) liquidity for the \n     *                   equivalent constant-product AMM curve. If rolling is turned\n     *                   on, this is instead interpreted as a rolling target value. */\n    struct ConcentratedDirective {\n        int24 lowTick_;\n        int24 highTick_;\n        bool isAdd_;\n        bool isTickRel_;\n        uint8 rollType_;\n        uint128 liquidity_;\n    }\n\n    /* @notice Along with a root open tick from above defines a single range order mint\n     *         or burn action.\n\n    /* @notice Defines a directive related to the mint/burn of ambient liquidity on a \n     *         single pre-specified curve.\n     *\n     * @dev A directive indicating no ambient mint/burn must set *both* isAdd to false and\n     *      liquidity to zero. liquidity=0 alone will indicate the use of a flxeible \n     *      back-filled rolling quantity in place.\n     *\n     * @param isAdd_ If true, the action mints new ambient liquidity. If false, burns \n     *               pre-existing liquidity in the curve.\n     * @param rollType_  The flavor of rolling gap fill that should be applied (if any)\n     *                   to this leg of the directive. See Chaining.sol for list of\n     *                   rolling type codes.\n     * @param liquidity_ The total amount of ambient liquidity to add/remove.\n     *                   Represented as the equivalent of sqrt(X*Y) liquidity for a\n     *                   constant-product AMM curve. (If this and rollType_ are zero,\n     *                   this is a non-action.) */\n    struct AmbientDirective {\n        bool isAdd_;\n        uint8 rollType_;\n        uint128 liquidity_;\n    }\n\n    /* @param rollExit_ If set to true, use the exit side of the pair's tokens when\n     *                  calculating rolling back-fill quantities.\n     * @param swapDefer_ If set to true, execute the swap directive *after* the passive\n     *                  mint/burn directives for the pool. If false, swap executes first.\n     * @param offsetSurplus_ If set to true offset any rolling back-fill quantities with\n     *                       the client's pre-existing surplus collateral at the dex. */\n    struct ChainingFlags {\n        bool rollExit_;\n        bool swapDefer_;\n        bool offsetSurplus_;\n    }\n\n    /* @notice Defines a full suite of trade action directives to be executed on a single\n     *         pool within a pre-specified pair.\n     * @param poolIdx_ The pool type index that identified the pool to be operated on in\n     *                 this pair.\n     * @param ambient_ Directive related to ambient liquidity actions (if any).\n     * @param conc_ Directives related to concentrated liquidity range orders (if any).\n     * @param swap_ Directive for the swap action on the pool (if any).\n     * @param chain_ Flags related to chaining order of the directive actions and how\n     *               rolling back fill is calculated. */\n    struct PoolDirective {\n        uint256 poolIdx_;\n        AmbientDirective ambient_;\n        ConcentratedDirective[] conc_;\n        SwapDirective swap_;\n        ChainingFlags chain_;\n    }\n\n    /* @notice Specifies the settlement procedures between user and dex related to\n     *         a single token within a chain of hops in a sequence of one or more\n     *         pairs. The same struct is used for the entry/exit terminal tokens as\n     *         well as intermediate tokens between pairs.\n     *\n     * @param token_ The tracker address to the token in the pair. (If set to zero \n     *              specifies native Ethereum as the pair asset.)\n     * @param limitQty_ A net flow limit that the user expects the execution to meet\n     *    or exceed. Otherwise the transaction is reverted. Negative specifies a minimum\n     *    credit from the pool to the user. Positive a maximum debit from user to the \n     *    pool. \n     * @param dustThresh_ A threshold, below which the user requests no transaction is\n     *    sent as part of a credit. (Debits are always collected.) Used to avoid \n     *    unnecessary gas cost of a token transfer on an economically meaningless value.\n     * @param useSurplus_ If set to true the settlement should attempt to complete using\n     *    the client's surplus collateral balance at the dex. */\n    struct SettlementChannel {\n        address token_;\n        int128 limitQty_;\n        uint128 dustThresh_;\n        bool useSurplus_;\n    }\n\n    /* @notice Specified if and how off-grid price improvement is being requested. (Note\n     *         that even if requested, there may be no price improvement set for the \n     *         token. To avoid wasted gas, user should check off-chain.)\n     * @param isEnabled_ By default, no price improvement is set, avoiding the gas cost\n     *         of a storage query. If true, indicates that the user wants to query the\n     *         price improvement settings. \n     * @param useBaseSide_ If true requests price improvement from the base-side token\n     *         in the pair. Otherwise, requested on the quote-side token. */\n    struct PriceImproveReq {\n        bool isEnabled_;\n        bool useBaseSide_;\n    }\n\n    /* @notice Defines a full directive related to a single hop in a sequence of pairs.\n     * @param pools_ Defines directives on one or more pools on the pair.\n     * @param settle_ Defines the settlement for the token on the *exit* side of the hop.\n     *         (The entry side is defined in the previous hop, or the open directive if\n     *          this is the first hop in the sequence.)\n     * @param improve_ Off-grid price improvement settings. */\n    struct HopDirective {\n        PoolDirective[] pools_;\n        SettlementChannel settle_;\n        PriceImproveReq improve_;\n    }\n\n    /* @notice Top-level trade order directive, encompassing an arbitrary collection of\n     *    of swap, mints, and burns across multiple pools within a chained sequence of \n     *    pairs. \n     * @param open_ Defines the token and settlement for the entry token in the first hop\n     *    in the chain.\n     * @param hops_ Defines a sequence of directives on pairs that will be executed in the\n     *    order specified by this array. */\n    struct OrderDirective {\n        SettlementChannel open_;\n        HopDirective[] hops_;\n    }\n\n}\n"
    },
    "contracts/libraries/Encoding.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport \"./Directives.sol\";\n\n/* @title Order encoding library\n * @notice Provides facilities for encoding and decoding user specified order directive\n *    structures to/from raw transaction bytes. */\nlibrary OrderEncoding {\n\n    // Preamble code that begins at the start of long-form orders. Allows us to support\n    // alternative message schemas in the future. To start all encoded long-form orders\n    // must start with this code in the first character position.\n    uint8 constant LONG_FORM_SCHEMA = 1;\n\n    /* @notice Parses raw bytes into an OrderDirective struct in memory.\n     * \n     * @dev In general the array lengths and arithmetic in this function and child\n     *      functions are unchecked/unsanitized. The only use of this function is to\n     *      parse a user-supplied string into constituent commands. If a user supplies\n     *      malformed data it will have no impact on the state of the contract besides\n     *      the internally safe swap/mint/burn calls. */\n    function decodeOrder (bytes calldata input) internal pure returns\n        (Directives.OrderDirective memory dir) {\n        uint offset = 0;\n        uint8 cnt;\n        uint8 schemaType;\n\n        (schemaType, dir.open_.token_, dir.open_.limitQty_, dir.open_.dustThresh_,\n            dir.open_.useSurplus_, cnt) = abi.decode(input[offset:(offset+32*6)],\n            (uint8, address, int128, uint128, bool, uint8));\n        unchecked { // 0 + 32*6 is well with bounds of 256 bits\n        offset += 32*6;\n        }\n \n        require(schemaType == LONG_FORM_SCHEMA);\n        \n        dir.hops_ = new Directives.HopDirective[](cnt);\n        unchecked {\n        // An iterate by 1 loop will run out of gas far before overflowing 256 bits\n        for (uint i = 0; i < cnt; ++i) {\n            offset = parseHop(dir.hops_[i], input, offset);\n        }\n        }\n    }\n\n    /* @notice Parses an offset bytestream into a single HopDirective in memory and \n     *         increments the offset accordingly. */\n    function parseHop (Directives.HopDirective memory hop,\n                       bytes calldata input, uint256 offset)\n        private pure returns (uint256 next) {\n        next = offset;\n\n        uint8 poolCnt;\n        poolCnt = abi.decode(input[next:(next+32)], (uint8));\n        unchecked {\n        \n        next += 32;\n        }\n\n        hop.pools_ = new Directives.PoolDirective[](poolCnt);\n        unchecked {\n        // An iterate by 1 loop will run out of gas far before overflowing 256 bits\n        for (uint i = 0; i < poolCnt; ++i) {\n            next = parsePool(hop.pools_[i], input, next);\n        }\n        }\n\n        return parseSettle(hop, input, next);\n    }\n\n    /* @notice Parses the settlement fields in a hop directive. */\n    function parseSettle (Directives.HopDirective memory hop, bytes calldata input, uint256 offset) \n        private pure returns (uint256) {\n        (hop.settle_.token_, hop.settle_.limitQty_, hop.settle_.dustThresh_,\n            hop.settle_.useSurplus_, hop.improve_.isEnabled_, hop.improve_.useBaseSide_) =\n            abi.decode(input[offset:(offset+32*6)], (address, int128, uint128, bool, bool, bool));\n\n        unchecked {\n        // Incrementing by 192 will run out of gas far before overflowing 256-bits\n        return offset + 32*6;\n        }        \n    }\n\n    /* @notice Parses an offset bytestream into a single PoolDirective in memory \n               and increments the offset accordingly. */\n    function parsePool (Directives.PoolDirective memory pair,\n                        bytes calldata input, uint256 offset)\n        private pure returns (uint256 next) {\n        uint concCnt;\n        next = offset;\n\n        (pair.poolIdx_, pair.ambient_.isAdd_, pair.ambient_.rollType_, pair.ambient_.liquidity_,\n            concCnt) = abi.decode(input[next:(next+32*5)], (uint256, bool, uint8, uint128, uint8));\n\n        unchecked {\n        // Incrementing by 160 will run out of gas far before overflowing 256-bits\n        next += 32*5;\n        }\n        pair.conc_ = new Directives.ConcentratedDirective[](concCnt);\n\n        unchecked {\n        // An iterate by 1 loop will run out of gas far before overflowing 256 bits\n        for (uint i = 0; i < concCnt; ++i) {\n            next = parseConcentrated(pair.conc_[i], input, next);\n        }\n        }\n\n        (pair.swap_.isBuy_, pair.swap_.inBaseQty_, \n            pair.swap_.rollType_, pair.swap_.qty_, pair.swap_.limitPrice_) =\n            abi.decode(input[next:(next+32*5)], (bool, bool, uint8, uint128, uint128));\n        unchecked {         // Incrementing by 160 will run out of gas far before overlowing 256 bits\n        next += 32*5;\n        }\n\n        (pair.chain_.rollExit_, pair.chain_.swapDefer_,\n            pair.chain_.offsetSurplus_) = abi.decode(input[next:(next+32*3)], (bool, bool, bool));\n        unchecked {        // Incrementing by 96 will run out of gas far before overlowing 256 bits\n        next += 32*3;\n        }\n    }\n\n    /* @notice Parses an offset bytestream into a single ConcentratedDirective in \n     *         memory and increments the offset accordingly. */\n    function parseConcentrated (Directives.ConcentratedDirective memory pass,\n                                bytes calldata input, uint256 offset)\n        private pure returns (uint256 next) {\n        (pass.lowTick_, pass.highTick_, pass.isTickRel_, pass.isAdd_,\n            pass.rollType_, pass.liquidity_) = abi.decode(input[offset:(offset+32*6)], \n            (int24, int24, bool, bool, uint8, uint128));\n\n        unchecked {         // Incrementing by 196 at a time should never overflow 256 bits\n        next = offset + 32*6;\n        }\n    }\n}\n"
    },
    "contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint {\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n    uint256 internal constant Q64 = 0x10000000000000000;\n    uint256 internal constant Q48 = 0x1000000000000;\n\n    /* @notice Multiplies two Q64.64 numbers by each other. */\n    function mulQ64 (uint128 x, uint128 y) internal pure returns (uint192) {\n        unchecked { // 128 bit integers squared will always fit in 256-bits\n        return uint192((uint256(x) * uint256(y)) >> 64);\n        }\n    }\n\n    /* @notice Divides one Q64.64 number by another. */\n    function divQ64 (uint128 x, uint128 y) internal pure returns (uint192) {\n        unchecked { // No overflow or underflow possible in the below operations\n        return (uint192(x) << 64) / y;\n        }\n    }\n\n    /* @notice Multiplies a Q64.64 by a Q16.48. */\n    function mulQ48 (uint128 x, uint64 y) internal pure returns (uint144) {\n        unchecked { // 128 bit integers squared will always fit in 256-bits\n        return uint144((uint256(x) * uint256(y)) >> 48);\n        }\n    }\n\n    /* @notice Takes the reciprocal of a Q64.64 number. */\n    function recipQ64 (uint128 x) internal pure returns (uint128) {\n        unchecked { // Only possible overflow possible is captured with a specific check\n        uint256 div = uint256(FixedPoint.Q128) / uint256(x);\n        require(div <= type(uint128).max);\n        return uint128(div);\n        }\n    }\n}\n"
    },
    "contracts/libraries/KnockoutLiq.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n\n/* @notice Defines structures and functions necessary to track knockout liquidity. \n *         Knockout liquidity works like standard concentrated range liquidity, *except*\n *         the position becomes inactive once the price of the curve breaches a certain\n *         tick pivot. In that sense knockout liquidity behaves like a \"non-reversible\n *         limit order\" seen in the traditional limit order book. */\nlibrary KnockoutLiq {\n\n    /* @notice Defines a currently active knockout liquidity bump point that exists on\n     *         a specific AMM curve at a specific tick/direction.\n     *\n     * @param lots_ The total number of lots active in the knockout pivot. Note that this\n     *              number should always be included in the corresponding LevelBook lots.\n     *\n     * @param pivotTime_ The block time the first liquidity was created on the pivot \n     *                   point. This resets every time the knockout is crossed, and is\n     *                   therefore used to distinguish tranches of liquidity that were\n     *                   added at the same tick but with different knockout times.\n     *\n     * @param rangeTicks_ The number of ticks wide the range order for the knockout \n     *                    tranche. Unlike traditional concentrated liquidity, all knockout\n     *                    liquidity in the same tranche must have the same width. This is\n     *                    used to determine what counter-side tick to decrement liquidity\n     *                    on when knocking out an order. */\n    struct KnockoutPivot {\n        uint96 lots_;\n        uint32 pivotTime_;\n        uint16 rangeTicks_;\n    }\n\n    /* @notice Stores a cryptographically provable history of previous knockout events\n     *         at a given tick/direction. \n     *\n     * @dev To avoid unnecessary SSTORES, we Merkle at the same location instead of \n     *      growing an array. This allows users trying to claim a previously knockout \n     *      position to post a Merkle proof. (And since the underlying liquidity is \n     *      computable even without this proof, the only loss for those that don't are the\n     *      accumulated fees while the range liquidity was active.)\n     *\n     * @param merkleRoot_ The Merkle root of the prior entry in the chain.\n     * @param pivotTime_ The pivot time of the last tranche to be knocked out at this tick\n     * @param feeMileage_ The fee mileage for the range at the time the tranche was \n     *                    knocked out. */\n    struct KnockoutMerkle {\n        uint160 merkleRoot_;\n        uint32 pivotTime_;\n        uint64 feeMileage_;\n    }\n\n    /* @notice Represents a single user's knockout liquidity position.\n     * @param lots_ The total number of liquidity lots in the position. \n     * @param feeMileage_ The in-range cumulative fee mileage at the time the position was\n     *                    created.\n     * @param timestamp_ The block time the position was created (or when liquidity was\n     *                   added to the position). */\n    struct KnockoutPos {\n        uint96 lots_;\n        uint64 feeMileage_;\n        uint32 timestamp_;\n    }\n\n    /* @notice Represents the location of a knockout position inside a given AMM curve.\n     *         Necessary to recover a user's position in the storage.\n     *\n     * @param isBid_ If true, indicates that the knockout is on the bid side, i.e. will\n     *                knockout when price falls below the tick.\n     * @param lowerTick The 24-bit tick index of the lower boundary of the knockout range order\n     * @param upperTick The 24-bit tick index of the upper boundary of the knockout range order */\n    struct KnockoutPosLoc {\n        bool isBid_;\n        int24 lowerTick_;\n        int24 upperTick_;\n    }\n\n    /* @notice Resets all fields on a existing pivot struct. */\n    function deletePivot (KnockoutPivot storage pivot) internal {\n        pivot.lots_ = 0;\n        pivot.pivotTime_ = 0;\n        pivot.rangeTicks_ = 0;\n    }\n    \n    /* @notice Encodes a hash key for a given knockout pivot point.\n     * @param pool The hash index of the AMM pool.\n     * @param isBid If true indicates the knockout pivot is on the bid side.\n     * @param tick The tick index of the knockout pivot.\n     * @return Unique hash key mapping to the pivot struct. */\n    function encodePivotKey (bytes32 pool, bool isBid, int24 tick)\n        internal pure returns (bytes32) {\n        return keccak256(abi.encode(pool, isBid, tick));\n    }\n\n    /* @notice Encodes a hash key for a knockout pivot given a pos location struct. */\n    function encodePivotKey (KnockoutPosLoc memory loc, bytes32 pool)\n        internal pure returns (bytes32) {\n        return encodePivotKey(pool, loc.isBid_, knockoutTick(loc));\n    }\n\n    /* @notice Determines which tick side is the pivot point based on whether the pivot\n     *         is a bid or ask. */\n    function knockoutTick (KnockoutPosLoc memory loc) internal pure returns (int24) {\n        return loc.isBid_ ? loc.lowerTick_ : loc.upperTick_;\n    }\n\n    function tickRange (KnockoutPosLoc memory loc) internal pure returns (uint16) {\n        uint24 range = uint24(loc.upperTick_ - loc.lowerTick_);\n        require (range < type(uint16).max);\n        return uint16(range);\n    }\n\n    /* @notice Encodes a hash key for a knockout position. \n     * @param loc The location of the knockout position\n     * @param pool The hash index of the AMM pool.\n     * @param owner The claimant of the liquidity position.\n     * @param pivotTime The timestamp of when the pivot tranche was created\n     * @return Unique hash key to position. */\n    function encodePosKey (KnockoutPosLoc memory loc,\n                           bytes32 pool, address owner, uint32 pivotTime)\n        internal pure returns (bytes32) {\n        return keccak256(abi.encode(pool, owner, loc.isBid_,\n                                    loc.lowerTick_, loc.upperTick_, pivotTime));\n    }\n    /* @notice Commits a now-crossed Knockout pivot to the merkle history for that tick\n     *         location.\n     * @param merkle The Merkle history object. Will be overwrriten by this function.\n     * @param pivot The most recent pivot state. Should not call this unless the pivot has\n     *              just been knocked out.\n     * @param feeMileage The in-range fee mileage at the time of knockout crossing. */\n    function commitKnockout (KnockoutMerkle storage merkle,\n                             KnockoutPivot memory pivot, uint64 feeMileage) internal {\n        merkle.merkleRoot_ = rootLink(merkle, commitEntropySalt());\n        merkle.pivotTime_ = pivot.pivotTime_;\n        merkle.feeMileage_ = feeMileage;\n    }\n\n    /* @notice Returns hard-to-fake entropy at commit time to prevent a long-range \n     *         birthday collission attack.\n     *\n     * @dev Knockout commits use 160-bit hashes for the Merkle chain. A birthday \n     *      collission attack could be carried with 2^80 SHA256 hashes for an approximate\n     *      cost of 10 billion dollars or 1 year of bitcoin mining. (See EIP-3607 for more\n     *      discussion.) This mitigates the risk of a long run attack by injecting 160 \n     *      bits of entropy from the block hash which can only be fully known at the time\n     *      a Merkle root is committed. \n     *\n     *      Even if an attacker is the block builder and can manipulate blockhash, they \n     *      can only control as many bits of blockhash entropy as SHA256 hashes they can \n     *      calculate in O(block time). Practically speaking an attacker will not be able\n     *      to calculate more than 2^100 hashes at the scale of block times. \n     *      Therefore this salt injects a minimum of 60 bits of uncontrollable entropy, \n     *      and raises the cost of a long-range collision attack to 2^140 hashes, which \n     *      is outright infeasible. */\n    function commitEntropySalt() internal view returns (uint160) {\n        return uint160(uint256(blockhash(block.number-1)));\n    }\n\n    /* @notice Converts the most recent Merkle state to a 160-bit Merkle root hash. */\n    function rootLink (KnockoutMerkle memory merkle, uint160 salt)\n        private pure returns (uint160) {\n        return rootLink(merkle.merkleRoot_, merkle.pivotTime_, merkle.feeMileage_, salt);\n    }\n\n    /* @notice Converts the most current Merkle state params to 160-bit Merkle hash.*/\n    function rootLink (uint160 root, uint32 pivotTime, uint64 feeMileage, uint160 salt)\n        private pure returns (uint160) {\n        return rootLink(root, encodeChainLink(pivotTime, feeMileage, salt));\n    }\n\n    /* @notice Hashes together the previous Merkle root with the encoded chain step. */\n    function rootLink (uint160 root, uint256 chainLink)\n        private pure returns (uint160) {\n        bytes32 hash = keccak256(abi.encode(root, chainLink));\n        return uint160(uint256(hash) >> 96);\n    }\n\n    /* @notice Tightly packs the 32-bit pivot time with the 64-bit fee mileage and the salt. */\n    function encodeChainLink (uint32 pivotTime, uint64 feeMileage, uint160 salt)\n        private pure returns (uint256)  {\n        return (uint256(salt) << 96) +\n            (uint256(pivotTime) << 64) +\n            uint256(feeMileage);\n    }\n\n    /* @notice Decodes a tightly packed chain link into the pivot time and fee mileage */\n    function decodeChainLink (uint256 entry)\n        private pure returns (uint32 pivotTime, uint64 feeMileage)  {\n        pivotTime = uint32((entry << 160) >> 224);\n        feeMileage = uint64((entry << 192) >> 192);\n    }\n\n    /* @notice Verifies a Merkle proof for a previous knockout commitment.\n     *\n     * @param merkle The current Merkle chain for the pivot tick.\n     * @param proofRoot The Merkle root the proof is starting at.\n     * @param proof A proof that starts at the point in history the user wants to prove\n     *              and includes the encoded 96-bit chain entries (see encodeChainLink())\n     *              up to the current Merkle state.\n     *\n     * @return The 32-bit Knockout tranche pivot time and 64-bit fee mileage at the start of\n     *         the proof. */\n    function proveHistory (KnockoutMerkle memory merkle, uint160 proofRoot,\n                           uint256[] memory proof)\n        internal pure returns (uint32, uint64) {\n        // If we're only looking at the most recent knockout, it's still stored raw\n        // and doesn't need a proof.\n        return proof.length == 0 ?\n            (merkle.pivotTime_, merkle.feeMileage_) :\n            proveSteps(merkle, proofRoot, proof);\n    }\n\n    /* @notice Verifies a non-empty Merkle proof. */\n    function proveSteps (KnockoutMerkle memory merkle, uint160 proofRoot,\n                         uint256[] memory proof)\n        private pure returns (uint32, uint64) {\n        uint160 incrRoot = proofRoot;\n        unchecked {\n            // Iterate by 1 loop will run out of gas far before overflowing 256 bits\n            for (uint i = 0; i < proof.length; ++i) {\n                incrRoot = rootLink(incrRoot, proof[i]);\n            }\n        }\n\n        require(incrRoot == merkle.merkleRoot_, \"KP\");\n        return decodeChainLink(proof[0]);\n    }\n\n\n    /* @notice Verifies that a given knockout location is valid relative to the curve\n     *         price and the pool's current knockout parameters. If not, the call will\n     *         revert\n     *\n     * @param loc The location for the proposed knockout liquidity candidate.\n     * @param priceTick The tick index of the curves current price.\n     *\n     * @param loc The tightly packed knockout parameters related to the pool. The fields\n     *            are set in the following order from most to least significant bit:\n     *         [8]             [7]            [6][5]          [4][3][2][1]\n     *        Unusued      On-Grid Flag      PlaceType         OrderWidth\n     *            \n     *            The field types are as follows:\n     *               OrderWidth - The width of new knockout pivots in ticks represented by\n     *                            power of two. \n     *               PlaceType - Restricts where new knockout pivots can be placed \n     *                           relative to curve price. Uses the following codes:\n     *                    0 - Disabled. No knockout pivots allowed.\n     *                    1 - Knockout bids (asks) must be placed with upper (lower) tick\n     *                        below (above) the current curve price.\n     *                    2 - Knockout bids (asks) must be placed with lower (upper) tick\n     *                        below (above) the current curve price.\n     *\n     *              On-Grid Flag - If set requires that any new knockout range order can only\n     *                             be placed on a tick index that's a multiple of the width. \n     *                             Can be used to restrict density of knockout orders, beyond \n     *                             the normal pool tick size. */\n    function assertValidPos (KnockoutPosLoc memory loc, int24 priceTick, \n                             uint8 knockoutBits) internal pure {\n        (bool enabled, uint8 width, bool inside, bool onGrid) =\n            unpackBits(knockoutBits);\n\n        require(enabled && gridOkay(loc, width, onGrid) &&\n                spreadOkay(loc, priceTick, inside), \"KV\");\n    }\n\n    /* @notice Evaluates whether the placement and width of a knockout pivot candidate\n     *         conforms to the grid parameters. */\n    function gridOkay (KnockoutPosLoc memory loc, uint8 widthBits, bool mustBeOnGrid)\n        private pure returns (bool) {\n        uint24 width = uint24(loc.upperTick_ - loc.lowerTick_);\n        bool rightWidth = width == uint24(1) << widthBits;\n\n        int24 tick = loc.upperTick_;\n        uint24 absTick = tick > 0 ? uint24(tick) : uint24(-tick);\n        bool onGrid = (!mustBeOnGrid) || (absTick >> widthBits) << widthBits == absTick;\n\n        return rightWidth && onGrid;\n    }\n\n    /* @notice Evaluates whether the placement of a knockout pivot candidates conforms\n     *         to the parameters relative to the curve's current price tick. */\n    function spreadOkay (KnockoutPosLoc memory loc, int24 priceTick,\n                         bool inside) internal pure returns (bool) {\n        // Checks to see whether the range order is placed directionally correct relative\n        // to the current tick price. If inside is true, then the range order can be placed\n        // with the curve price inside the range. \n        // Otherwise bids must have the entire range below the curve price, and asks must\n        // have the entire range above the curve price.\n        if (loc.isBid_) {\n            int24 refTick = inside ? loc.lowerTick_ : loc.upperTick_;\n            return refTick < priceTick;\n        } else {\n            int24 refTick = inside ? loc.upperTick_ : loc.lowerTick_;\n            return refTick >= priceTick;\n        }\n    }\n\n    /* @notice Decodes the tightly packed bits in pool knockout parameters.\n     * @return enabled True if new knockout pivots are enabled at all.\n     * @return widthBits The width of new knockout pivots in ticks to the power of two.\n     * @return inside  True if knockout range order can be minted with the current curve\n     *                 price inside the tick range. If false, knockout range orders can\n     *                 only be minted with the full range is outside the current curve \n     *                 price.\n     * @return onGrid True if new knockout range orders are restricted to ticks that\n     *                are multiples of the width size. */\n    function unpackBits (uint8 knockoutBits) private pure returns\n        (bool enabled, uint8 widthBits, bool inside, bool onGrid) {\n        widthBits = uint8(knockoutBits & 0x0F);\n        uint8 flagBits = uint8(knockoutBits & 0x30) >> 4;\n\n        enabled = flagBits > 0;\n        inside = flagBits >= 2;\n\n        onGrid = knockoutBits & 0x40 > 0;\n    }\n}\n"
    },
    "contracts/libraries/LiquidityMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.19;\n\nimport './SafeCast.sol';\nimport './TickMath.sol';\n\n/// @title Math library for liquidity\nlibrary LiquidityMath {\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        unchecked { // Arithmetic checks done explicitly\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x);\n        } else {\n            require((z = x + uint128(y)) >= x);\n        }\n        }\n    }\n\n    /// @notice Add an unsigned liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addLiq(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        unchecked { // Arithmetic checks done explicitly\n        require((z = x + y) >= x);\n        }\n    }\n\n    /// @notice Add an unsigned liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addLots(uint96 x, uint96 y) internal pure returns (uint96 z) {\n        unchecked { // Arithmetic checks done explicitly\n        require((z = x + y) >= x);\n        }\n    }\n\n    /// @notice Subtract an unsigned liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function minusDelta(uint128 x, uint128 y) internal pure returns (uint128 z) {\n        z = x - y;\n    }\n\n    /* @notice Same as minusDelta, but operates on lots of liquidity rather than outright\n     *         liquiidty. */\n    function minusLots(uint96 x, uint96 y) internal pure returns (uint96 z) {\n        z = x - y;\n    }\n\n    /* In certain contexts we need to represent liquidity, but don't have the full 128 \n     * bits or precision. The compromise is to use \"lots\" of liquidity, which is liquidity\n     * represented as multiples of 1024. Usually in those contexts, max lots is capped at\n     * 2^96 (equivalent to 2^106 of liquidity.) \n     *\n     * More explanation, along with examples can be found in the documentation at \n     * docs/LiquidityLots.md in the project respository. */\n    uint16 constant LOT_SIZE = 1024;\n    uint8 constant LOT_SIZE_BITS = 10;\n    \n\n    /* By utilizing the least significant digit of the liquidity lots value, we can \n     * support special types of \"knockout\" liquidity, that when crossed trigger specific\n     * calls. The aggregate knockout liquidity will always sum to an odd number of lots\n     * whereas all vanilla resting liquidity will have an even number of lots. That\n     * means we can test whether any level has knockout liquidity simply by seeing if the\n     * the total sum is an odd number. \n     *\n     * More explanation, along with examples can be found in the documentation at \n     * docs/LiquidityLots.md in the project respository. */\n    uint96 constant KNOCKOUT_FLAG_MASK = 0x1;\n    uint8 constant LOT_ACTIVE_BITS = 11;\n\n    /* @notice Converts raw liquidity to lots of resting liquidity. (See comment above \n     *         defining lots. */\n    function liquidityToLots (uint128 liq) internal pure returns (uint96) {\n            uint256 lots = liq >> LOT_SIZE_BITS;\n            uint256 liqTrunc = lots << LOT_SIZE_BITS;\n            bool hasEmptyMask = (lots & KNOCKOUT_FLAG_MASK == 0);\n            require(hasEmptyMask &&\n                    liqTrunc == liq &&\n                    lots < type(uint96).max, \"FD\");\n            return uint96(lots);\n    }\n\n    /* @notice Checks if an aggergate lots counter contains a knockout liquidity component\n     *         by checking the least significant bit.\n     *\n     * @dev    Note that it's critical that the sum *total* of knockout lots on any\n     *         given level be an odd number. Don't add two odd knockout lots together\n     *         without renormalzing, because they'll sum to an even lot quantity. */\n    function hasKnockoutLiq (uint96 lots) internal pure returns (bool) {\n        return lots & KNOCKOUT_FLAG_MASK > 0;\n    }\n\n    /* @notice Truncates an existing liquidity quantity into a quantity that's a multiple\n     *         of the 2048-multiplier defining even-sized lots of liquidity. */\n    function shaveRoundLots (uint128 liq) internal pure returns (uint128) {\n        return (liq >> LOT_ACTIVE_BITS) << LOT_ACTIVE_BITS;\n    }\n\n    /* @notice Truncates an existing liquidity quantity into a quantity that's a multiple\n     *         of the 2048-multiplier defining even-sized lots of liquidity, but rounds up \n     *         to the next multiple of 2048. */\n    function shaveRoundLotsUp (uint128 liq) internal pure returns (uint128 result) {\n        unchecked {\n        require((liq & 0xfffffffffffffffffffffffffffff800) != 0xfffffffffffffffffffffffffffff800, \"overflow\");\n\n        // By shifting down 11 bits, adding the one will always fit in 128 bits\n        uint128 roundUp = (liq >> LOT_ACTIVE_BITS) + 1;\n        return (roundUp << LOT_ACTIVE_BITS);\n        }\n    }\n\n    /* @notice Given a number of lots of liquidity converts to raw liquidity value. */\n    function lotsToLiquidity (uint96 lots) internal pure returns (uint128) {\n        uint96 realLots = lots & ~KNOCKOUT_FLAG_MASK;\n        return uint128(realLots) << LOT_SIZE_BITS;\n    }\n\n    /* @notice Given a positive and negative delta lots value net out the raw liquidity\n     *         delta. */\n    function netLotsOnLiquidity (uint96 incrLots, uint96 decrLots) internal pure\n        returns (int128) {\n        unchecked {\n        // Original values are 96-bits, every possible difference will fit in signed-128 bits\n        return lotToNetLiq(incrLots) - lotToNetLiq(decrLots);\n        }\n    }\n\n    /* @notice Given an amount of lots of liquidity converts to a signed raw liquidity\n     *         delta. (Which by definition is always positive.) */\n    function lotToNetLiq (uint96 lots) internal pure returns (int128) {\n        return int128(lotsToLiquidity(lots));\n    }\n\n    \n    /* @notice Blends the weighted average of two fee reward accumulators based on the\n     *         relative size of two liquidity position.\n     *\n     * @dev To be conservative in terms of rewards/collateral, this function always\n     *   rounds up to 2 units of precision. We need mileage rounded up, so reward payouts\n     *   are rounded down. However this could lead to the technically \"impossible\" \n     *   situation where the mileage on a subsequent rewards burn is smaller than the\n     *   blended mileage in the liquidity postion. Technically this shouldn't happen \n     *   because mileage only increases through time. However this is a non-consequential\n     *   failure. burnPosLiq() just treats it as a zero reward situation, and the staker\n     *   loses an economically non-meaningful amount of rewards on the burn. */\n    function blendMileage (uint64 mileageX, uint128 liqX, uint64 mileageY, uint128 liqY)\n        internal pure returns (uint64) {\n        if (liqY == 0) { return mileageX; }\n        if (liqX == 0) { return mileageY; }\n        if (mileageX == mileageY) { return mileageX; }\n        uint64 termX = calcBlend(mileageX, liqX, liqX + liqY);\n        uint64 termY = calcBlend(mileageY, liqY, liqX + liqY);\n\n        // With mileage we want to be conservative on the upside. Under-estimating\n        // mileage means overpaying rewards. So, round up the fractional weights.\n        return (termX + 1) + (termY + 1);\n    }\n\n    /* @notice Blends the weighted average of two 72-bit fee reward accumulators based on the\n     *         relative size of two liquidity position.\n     * \n     * @dev See dev notes from blendMileage() method. Same logic applies. */\n    function blendMileage72 (uint72 mileageX, uint128 liqX, uint72 mileageY, uint128 liqY)\n        internal pure returns (uint72) {\n        if (liqY == 0) { return mileageX; }\n        if (liqX == 0) { return mileageY; }\n        if (mileageX == mileageY) { return mileageX; }\n        uint72 termX = calcBlend72(mileageX, liqX, liqX + liqY);\n        uint72 termY = calcBlend72(mileageY, liqY, liqX + liqY);\n\n        // With mileage we want to be conservative on the upside. Under-estimating\n        // mileage means overpaying rewards. So, round up the fractional weights.\n        return (termX + 1) + (termY + 1);\n    }\n    \n    /* @notice Calculates a weighted blend of adding incremental rewards mileage. */\n    function calcBlend (uint64 mileage, uint128 weight, uint128 total)\n        private pure returns (uint64) {\n        unchecked { // Intermediate results will always fit in 256-bits\n        // Can safely cast, because result will always be smaller than original since\n        // weight is less than total.\n        return uint64(uint256(mileage) * uint256(weight) / uint256(total));\n        }\n    }\n\n    /* @notice Calculates a weighted blend of adding incremental rewards mileage. */\n    function calcBlend72 (uint72 mileage, uint128 weight, uint128 total)\n        private pure returns (uint72) {\n        unchecked { // Intermediate results will always fit in 256-bits\n        // Can safely cast, because result will always be smaller than original since\n        // weight is less than total.\n        return uint72(uint256(mileage) * uint256(weight) / uint256(total));\n        }\n    }\n\n\n    /* @dev Computes a rounding safe calculation of the accumulated rewards rate based on\n     *      a beginning and end mileage counter. */\n    function deltaRewardsRate (uint64 feeMileage, uint64 oldMileage) internal pure\n        returns (uint64) {\n        uint64 REWARD_ROUND_DOWN = 2;\n        if (feeMileage > oldMileage + REWARD_ROUND_DOWN) {\n            return feeMileage - oldMileage - REWARD_ROUND_DOWN;\n        } else {\n            return 0;\n        }\n    }\n\n    /* @dev Computes a rounding safe calculation of the accumulated rewards for 72 bit mileage\n     *      delta snapshots. */\n    function deltaRewardsRate72 (uint72 feeMileage, uint72 oldMileage) internal pure\n        returns (uint64) {\n        uint72 REWARD_ROUND_DOWN = 2;\n        if (feeMileage > oldMileage + REWARD_ROUND_DOWN) {    \n            uint72 mileageDelta = feeMileage - oldMileage - REWARD_ROUND_DOWN;\n\n            // In practice a the cumulative growth in a curve, and therefore in any range,\n            // in the curve can never exceed 2^64. So in practice this mileage delta should\n            // never exceed 2^64. However, to be on the safe side we cap it to prevent\n            // overflow.\n            return mileageDelta > type(uint64).max ?\n                type(uint64).max : uint64(mileageDelta);\n\n        } else {\n            return 0;\n        }\n    }\n}\n"
    },
    "contracts/libraries/PoolSpecs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\n/* @title Pool specification library.\n * @notice Library for defining, querying, and encoding the specifications of the\n *         parameters of a pool type. */\nlibrary PoolSpecs {\n\n    /* @notice Specifcations of the parameters of a single pool type. Any given pair\n     *         may have many different pool types, each of which may operate as segmented\n     *         markets with different underlying behavior to the AMM. \n     *\n     * @param schema_ Placeholder that defines the structure of the poolSpecs object in\n     *                in storage. Because slots initialize zero, 0 is used for an \n     *                unitialized or disabled pool. 1 is the only currently used schema\n     *                (for the below struct), but allows for upgradeability in the future\n     *\n     * @param feeRate_ The overall fee (liquidity fees + protocol fees inclusive) that\n     *            swappers pay to the pool as a fraction of notional. Represented as an \n     *            integer representing hundredths of a basis point. I.e. a 0.25% fee \n     *            would be 2500\n     *\n     * @param protocolTake_ The fraction of the fee rate that goes to the protocol fee \n     *             (the rest accumulates as a liquidity fee to LPs). Represented in units\n     *             of 1/256. Since uint8 can represent up to 255, protocol could take\n     *             as much as 99.6% of liquidity fees. However currently the protocol\n     *             set function prohibits values above 128, i.e. 50% of liquidity fees. \n     *             (See set ProtocolTakeRate in PoolRegistry.sol)\n     *\n     * @param tickSize The minimum granularity of price ticks defining a grid, on which \n     *          range orders may be placed. (Outside off-grid price improvement facility.)\n     *          For example a value of 50 would mean that range order bounds could only\n     *          be placed on every 50th price tick, guaranteeing a minimum separation of\n     *          0.005% (50 one basis point ticks) between bump points.\n     *\n     * @param jitThresh_ Sets the minimum TTL for concentrated LP positions in the pool.\n     *                   Represented in units of 10 seconds (as measured by block time)\n     *                   E.g. a value of 5 equates to a minimum TTL of 50 seconds.\n     *                   Attempts to burn or partially burn an LP position in less than\n     *                   N seconds (as measured in block.timestamp) after a position was\n     *                   minted (or had its liquidity increased) will revert. If set to\n     *                   0, atomically flashed liquidity that mints->burns in the same\n     *                   block is enabled.\n     *\n     * @param knockoutBits_ Defines the parameters for where and how knockout liquidity\n     *                      is allowed in the pool. (See KnockoutLiq library for a full\n     *                      description of the bit field.)\n     *\n     * @param oracleFlags_ Bitmap flags to indicate the pool's oracle permission \n     *                     requirements. Current implementation only uses the least \n     *                     significant bit, which if on checks oracle permission on every\n     *                     pool related call. Otherwise pool is permissionless. */\n    struct Pool {\n        uint8 schema_;\n        uint16 feeRate_;\n        uint8 protocolTake_;\n        uint16 tickSize_;\n        uint8 jitThresh_;\n        uint8 knockoutBits_;\n        uint8 oracleFlags_;\n    }\n\n    uint8 constant BASE_SCHEMA = 1;\n    uint8 constant DISABLED_SCHEMA = 0;\n\n    /* @notice Convenience struct that's used to gather all useful context about on a \n     *         specific pool.\n     * @param head_ The full specification for the pool. (See struct Pool comments above.)\n     * @param hash_ The keccak256 hash used to encode the full pool location.\n     * @param oracle_ The permission oracle associated with this pool (0 if pool is \n     *                permissionless.) */\n    struct PoolCursor {\n        Pool head_;\n        bytes32 hash_;\n        address oracle_;\n    }\n\n\n    /* @notice Given a mapping of pools, a base/quote token pair and a pool type index,\n     *         copies the pool specification to memory. */\n    function queryPool (mapping(bytes32 => Pool) storage pools,\n                        address tokenX, address tokenY, uint256 poolIdx)\n        internal view returns (PoolCursor memory specs) {\n        bytes32 key = encodeKey(tokenX, tokenY, poolIdx);\n        Pool memory pool = pools[key];\n        address oracle = oracleForPool(poolIdx, pool.oracleFlags_);\n        return PoolCursor ({head_: pool, hash_: key, oracle_: oracle});\n    }\n\n    /* @notice Given a mapping of pools, a base/quote token pair and a pool type index,\n     *         retrieves a storage reference to the pool specification. */\n    function selectPool (mapping(bytes32 => Pool) storage pools,\n                         address tokenX, address tokenY, uint256 poolIdx)\n        internal view returns (Pool storage specs) {\n        bytes32 key = encodeKey(tokenX, tokenY, poolIdx);\n        return pools[key];\n    }\n\n    /* @notice Writes a pool specification for a pair and pool type combination. */\n    function writePool (mapping(bytes32 => Pool) storage pools,\n                        address tokenX, address tokenY, uint256 poolIdx,\n                        Pool memory val) internal {\n        bytes32 key = encodeKey(tokenX, tokenY, poolIdx);\n        pools[key] = val;\n    }\n\n    /* @notice Hashes the key associated with a pool for a base/quote asset pair and\n     *         a specific pool type index. */\n    function encodeKey (address tokenX, address tokenY, uint256 poolIdx)\n        internal pure returns (bytes32) {\n        require(tokenX < tokenY);\n        return keccak256(abi.encode(tokenX, tokenY, poolIdx));\n    }\n\n    /* @notice Returns the permission oracle associated with the pool (or 0 if pool is\n     *         permissionless. \n     *\n     * @dev    The oracle (if enabled on pool settings) is always deterministically based\n     *         on the first 160-bits of the pool type value. This means users can know \n     *         ahead of time if a pool can be oracled by checking the bits in the pool\n     *         index. */\n    function oracleForPool (uint256 poolIdx, uint8 oracleFlags)\n        internal pure returns (address) {\n        uint8 ORACLE_ENABLED_MASK = 0x1;\n        bool oracleEnabled = (oracleFlags & ORACLE_ENABLED_MASK == 1);\n        return oracleEnabled ?\n            address(uint160(poolIdx >> 96)) :\n            address(0);\n    }\n\n    /* @notice Constructs a cryptographically unique virtual address based off a base\n     *         address (either virtual or real), and a salt unique to the base address.\n     *         Can be used to create synthetic tokens, users, etc.\n     *\n     * @param base The address of the base root.\n     * @param salt A salt unique to the base token tracker contract.\n     *\n     * @return A synthetic token address corresponding to the specific virtual address. */\n    function virtualizeAddress (address base, uint256 salt) internal\n        pure returns (address) {\n        bytes32 hash = keccak256(abi.encode(base, salt));\n        uint160 hashTrail = uint160((uint256(hash) << 96) >> 96);\n        return address(hashTrail);\n    }\n}\n"
    },
    "contracts/libraries/PriceGrid.sol": {
      "content": "// SPDX-License-Identifier: GPL-3                                                   \n\npragma solidity 0.8.19;\n\nimport './TickMath.sol';\nimport './FixedPoint.sol';\nimport './SafeCast.sol';\nimport './CurveMath.sol';\nimport './Directives.sol';\n\n/* @title Price grid library.\n * @notice Functionality for tick-defined price grids and facilities for off-grid\n *         price improvement. */\nlibrary PriceGrid {\n    using TickMath for int24;\n    using SafeCast for uint256;\n    using SafeCast for uint192;\n\n    /* @notice Defines the off-grid price improvement options (if any) available to\n     *         the user for new range orders on a specific pair.\n     *\n     * @param inBase_ If true the collateral thresholds apply to the base-side tokens.\n     *                If false, applies to the quote-side tokens.\n     * @param unitCollateral_ The minimum collateral commitment required for an off-grid\n     *                range order *per tick* that's off grid.\n     * @param awayTicks_ The maximum number of ticks away from the current price that an\n     *                off-grid range order is allowed. */\n    struct ImproveSettings {\n        bool inBase_;\n        uint128 unitCollateral_;\n        uint16 awayTicks_;\n    }\n\n    /* @notice Asserts that a given range order is either on grid or eligble for off-grid\n     *         price improvement.\n     *\n     * @param set The off-grid price improvement requirements active for this pool.\n     * @param lowTick The lower tick index of the range order.\n     * @param highTick The upper tick index of the range order.\n     * @param liquidity The amount of liquidity in the range order.\n     * @param gridSize The grid size associated with the pool in ticks.\n     * @param priceTick The price tick of the current price in the pool.\n     *\n     * @return Returns false if the range is on-grid, and true if the range order\n     *         is off-grid but eligible for price improvement. (If off-grid and \n     *         ineligible, the transaction will revert.) */\n    function verifyFit (ImproveSettings memory set, int24 lowTick, int24 highTick,\n                        uint128 liquidity, uint16 gridSize, int24 priceTick)\n        internal pure returns (bool) {\n        if (!isOnGrid(lowTick, highTick, gridSize)) {\n            uint128 thresh = improveThresh(set, gridSize, priceTick,\n                                           lowTick, highTick);\n            require(liquidity >= thresh, \"D\");\n            return true;\n        }\n        return false;\n    }\n\n    /* @notice Asserts that a given range order is on grid.\n     * @param lowTick The lower tick index of the range order.\n     * @param highTick The upper tick index of the range order.\n     * @param gridSize The grid size associated with the pool in ticks. */\n    function verifyFit (int24 lowTick, int24 highTick, uint16 gridSize)\n        internal pure {\n        require(isOnGrid(lowTick, highTick, gridSize), \"D\");\n    }\n\n    /* @notice Returns true if the boundaries of a range order occur on the tick grid.\n     * @param lowerTick The lower tick index of the range order.\n     * @param upperTick The upper tick index of the range order.\n     * @param gridSize The grid size associated with the pool in ticks. */\n    function isOnGrid (int24 lowerTick, int24 upperTick, uint16 gridSize)\n        internal pure returns (bool) {\n        int24 tickNorm = int24(uint24(gridSize));\n        return lowerTick % tickNorm == 0 &&\n            upperTick % tickNorm == 0;\n    }\n\n    /* @notice Calculates the minimum liquidity required for a range order to be eligible\n     *         for off-grid price improvement.\n     * @param set The off-grid price improvement requirements active for this pool.\n     * @param tickSize The size of the grid in tick granularity.\n     * @param priceTick The price tick of the current price in the pool.\n     * @param bidTick The lower tick index of the range order.\n     * @param askTick The upper tick index of the range order.\n     * @return The elibility threshold represented as newly minted liquidity. */\n    function improveThresh (ImproveSettings memory set,\n                            uint16 tickSize, int24 priceTick,\n                            int24 bidTick, int24 askTick)\n        internal pure returns (uint128) {\n        require(bidTick < askTick);\n        return canImprove(set, priceTick, bidTick, askTick) ?\n            improvableThresh(set, tickSize, bidTick, askTick) :\n            type(uint128).max;\n    }\n\n\n    /* @notice Calculated the liquidity threshold for price improvement, assuming that\n     *    the order is eligible. */\n    function improvableThresh (ImproveSettings memory set,\n                               uint16 tickSize, int24 bidTick, int24 askTick)\n        private pure returns (uint128) {\n        uint24 unitClip = clipInside(tickSize, bidTick, askTick);\n        if (unitClip > 0) {\n            return liqForClip(set, unitClip, bidTick);\n        } else {\n            uint24 bidWing = clipBelow(tickSize, bidTick);\n            uint24 askWing = clipAbove(tickSize, askTick);\n            return liqForWing(set, bidWing, bidTick) +\n                liqForWing(set, askWing, askTick);\n        }\n    }\n\n    /* @notice Calculates the liquidity threshold for a range where both boundaries\n     *         are off grid. */\n    function liqForClip (ImproveSettings memory set, uint24 wingSize,\n                         int24 refTick)\n        private pure returns (uint128 liqDemand) {\n        // If neither side is tethered to the grid the gas burden is twice as high\n        // because there's two out-of-band crossings\n        return 2 * liqForWing(set, wingSize, refTick);\n    }\n    \n    /* @notice Calculates the liquidity threshold for a range where one boundary is\n     *         off grid and one boundary is on grid. */\n    function liqForWing (ImproveSettings memory set, uint24 wingSize,\n                         int24 refTick)\n        private pure returns (uint128) {\n        if (wingSize == 0) { return 0; }\n        uint128 collateral = set.unitCollateral_;\n        return convertToLiq(collateral, refTick, wingSize, set.inBase_);\n    }\n\n    /* @notice Given a range boundary determines the number of encompassed ticks\n     *    that are off-grid. */\n    function clipInside (uint16 tickSize, int24 bidTick, int24 askTick)\n        internal pure returns (uint24) {\n        require(bidTick < askTick);\n        if (bidTick < 0 && askTick < 0) {\n            return clipInside(tickSize, -askTick, -bidTick);\n        } else if (bidTick < 0 && askTick >= 0) {\n            return 0;\n        } else {\n            return clipNorm(uint24(tickSize), uint24(bidTick),\n                            uint24(askTick));\n        }\n    }\n\n    /* @notice Determines off-grid tick size from a normalized range boundary that's\n     *    safe for modular arithmetic. */\n    function clipNorm (uint24 tickSize, uint24 bidTick, uint24 askTick)\n        internal pure returns (uint24) {\n        if (bidTick % tickSize == 0 || askTick % tickSize == 0) {\n            return 0;\n        } else if ((bidTick / tickSize) != (askTick / tickSize)) {\n            return 0;\n        } else {\n            return askTick - bidTick;\n        }\n    }\n\n    /* @notice Returns the number of off-grid ticks associated with the left side of\n     *   a multi-grid spanning range order. */\n    function clipBelow (uint16 tickSize, int24 bidTick)\n        internal pure returns (uint24) {\n        if (bidTick < 0) { return clipAbove(tickSize, -bidTick); }\n        if (bidTick == 0) { return 0; }\n        \n        uint24 bidNorm = uint24(bidTick);\n        uint24 tickNorm = uint24(tickSize);\n        uint24 gridTick = ((bidNorm - 1) / tickNorm + 1) * tickNorm;\n        return gridTick - bidNorm;\n    }\n\n    /* @notice Returns the number of off-grid ticks associated with the right side of\n     *   a multi-grid spanning range order. */\n    function clipAbove (uint16 tickSize, int24 askTick)\n        internal pure returns (uint24) {\n        if (askTick < 0) { return clipBelow(tickSize, -askTick); }\n        \n        uint24 askNorm = uint24(askTick);\n        uint24 tickNorm = uint24(tickSize);\n        uint24 gridTick = (askNorm / tickNorm) * tickNorm;\n        return askNorm - gridTick;\n    }\n\n    /* We're converting from generalized collateral requirements to position-specific \n     * liquidity requirements. This is approximately the inversion of calculating \n     * collateral given liquidity. Therefore, we can just use the pre-existing CurveMath.\n     * We're not worried about exact results in this context anyway. Remember this is\n     * only being used to set an approximate economic threshold for allowing users to\n     * add liquidity inside the grid. */\n    function convertToLiq (uint128 collateral, int24 tick, uint24 wingSize, bool inBase)\n        private pure returns (uint128) {\n        uint128 priceTick = tick.getSqrtRatioAtTick();\n        uint128 priceWing = (tick + int24(wingSize)).getSqrtRatioAtTick();\n        return CurveMath.liquiditySupported(collateral, inBase, priceTick, priceWing);\n    }\n\n    /* @notice Returns true if the range order is within proximity to the curve's price\n     *    tick enough to be eligible for off-grid price improvement. */\n    function canImprove (ImproveSettings memory set, int24 priceTick,\n                         int24 bidTick, int24 askTick)\n        private pure returns (bool) {\n        if (set.unitCollateral_ == 0) { return false; }\n        \n        uint24 bidDist = diffTicks(bidTick, priceTick);\n        uint24 askDist = diffTicks(priceTick, askTick);\n        return bidDist <= set.awayTicks_ &&\n            askDist <= set.awayTicks_;\n    }\n\n    function diffTicks (int24 tickX, int24 tickY) private pure returns (uint24) {\n        return tickY > tickX ?\n            uint24(tickY - tickX) : uint24(tickX - tickY);\n    }\n}\n"
    },
    "contracts/libraries/ProtocolCmd.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport './SafeCast.sol';\n\n/* @title Protocol Command library.\n *\n * @notice To allow for flexibility and upgradeability the top-level interface to the Sdex\n *         dex contract contains a general purpose encoding scheme. User commands specify a\n *         proxy contract index, and input is passed raw and unformatted. Each proxy contract\n *         is free to specify its own input format, but by convention many proxy contracts\n *         adhere to a specification where the first 32 bytes of the input encodes a sub-command\n *         code. This library contains all of these sub-command codes in a single location for\n *         easy lookup. */\nlibrary ProtocolCmd {\n    \n    \n    ////////////////////////////////////////////////////////////////////////////\n    // Privileged commands invokable by direct governance only.\n    ////////////////////////////////////////////////////////////////////////////\n    // Code for transferring authority in the underlying SdexSwapDex contract.\n    uint8 constant AUTHORITY_TRANSFER_CODE = 20;\n    // Code to upgrade one of the sidecar proxy contracts on SdexSwapDex.\n    uint8 constant UPGRADE_DEX_CODE = 21;\n    // Code to force hot path to use the proxy contract\n    uint8 constant HOT_OPEN_CODE = 22;\n    // Code to toggle on or off emergency safe mode \n    uint8 constant SAFE_MODE_CODE = 23;\n    // Code to collect accumulated protocol fees for the treasury.\n    uint8 constant COLLECT_TREASURY_CODE = 40;\n    // Code to set the protocol treasury\n    uint8 constant SET_TREASURY_CODE = 41;\n    ////////////////////////////////////////////////////////////////////////////\n\n    \n    ////////////////////////////////////////////////////////////////////////////\n    // General purpose policy commands.\n    ////////////////////////////////////////////////////////////////////////////\n    // Code to disable a given pool template\n    uint8 constant DISABLE_TEMPLATE_CODE = 109;\n    // Code to set pool type template\n    uint8 constant POOL_TEMPLATE_CODE = 110;\n    // Code to revise parameters on pre-existing pool\n    uint8 constant POOL_REVISE_CODE = 111;\n    // Code to set the liquidity burn on pool initialization\n    uint8 constant INIT_POOL_LIQ_CODE = 112;\n    // Code to set/reset the off-grid liquidity threshold.\n    uint8 constant OFF_GRID_CODE = 113;\n    // Code to set the protocol take rate\n    uint8 constant SET_TAKE_CODE = 114;\n    // Code to resync the protocol take rate on an extant pool\n    uint8 constant RESYNC_TAKE_CODE = 115;\n    uint8 constant RELAYER_TAKE_CODE = 116;\n    ////////////////////////////////////////////////////////////////////////////\n\n\n    function encodeHotPath (bool open)\n        internal pure returns (bytes memory) {\n        return abi.encode(HOT_OPEN_CODE, open);\n    }\n\n    function encodeSafeMode (bool safeMode)\n        internal pure returns (bytes memory) {\n        return abi.encode(SAFE_MODE_CODE, safeMode);\n    }\n}\n\n\nlibrary UserCmd {\n\n    ////////////////////////////////////////////////////////////////////////////\n    // General purpose cold path codes\n    ////////////////////////////////////////////////////////////////////////////\n    uint8 constant INIT_POOL_CODE = 71;\n    uint8 constant APPROVE_ROUTER_CODE = 72;\n    uint8 constant DEPOSIT_SURPLUS_CODE = 73;\n    uint8 constant DISBURSE_SURPLUS_CODE = 74;\n    uint8 constant TRANSFER_SURPLUS_CODE = 75;\n    uint8 constant SIDE_POCKET_CODE = 76;\n    uint8 constant DEPOSIT_VIRTUAL_CODE = 77;\n    uint8 constant DISBURSE_VIRTUAL_CODE = 78;\n    uint8 constant RESET_NONCE = 80;\n    uint8 constant RESET_NONCE_COND = 81;\n    uint8 constant GATE_ORACLE_COND = 82;\n    uint8 constant DEPOSIT_PERMIT_CODE = 83;\n\n    ////////////////////////////////////////////////////////////////////////////\n    // LP action warm path command codes\n    ////////////////////////////////////////////////////////////////////////////\n    uint8 constant MINT_RANGE_LIQ_LP = 1;\n    uint8 constant MINT_RANGE_BASE_LP = 11;\n    uint8 constant MINT_RANGE_QUOTE_LP = 12;\n    uint8 constant BURN_RANGE_LIQ_LP = 2;\n    uint8 constant BURN_RANGE_BASE_LP = 21;\n    uint8 constant BURN_RANGE_QUOTE_LP = 22;\n    uint8 constant MINT_AMBIENT_LIQ_LP = 3;\n    uint8 constant MINT_AMBIENT_BASE_LP = 31;\n    uint8 constant MINT_AMBIENT_QUOTE_LP = 32;\n    uint8 constant BURN_AMBIENT_LIQ_LP = 4;\n    uint8 constant BURN_AMBIENT_BASE_LP = 41;\n    uint8 constant BURN_AMBIENT_QUOTE_LP = 42;\n    uint8 constant HARVEST_LP = 5;\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Knockout LP command codes\n    ////////////////////////////////////////////////////////////////////////////\n    uint8 constant MINT_KNOCKOUT = 91;\n    uint8 constant BURN_KNOCKOUT = 92;\n    uint8 constant CLAIM_KNOCKOUT = 93;\n    uint8 constant RECOVER_KNOCKOUT = 94;\n}\n"
    },
    "contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.19;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        unchecked { // Explicit bounds check\n        require((z = uint160(y)) == y);\n        }\n    }\n    \n    /// @notice Cast a uint256 to a uint128, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint128\n    function toUint128(uint256 y) internal pure returns (uint128 z) {\n        unchecked { // Explicit bounds check\n        require((z = uint128(y)) == y);\n        }\n    }\n\n    /// @notice Cast a uint192 to a uint128, revert on overflow\n    /// @param y The uint192 to be downcasted\n    /// @return z The downcasted integer, now type uint128\n    function toUint128By192(uint192 y) internal pure returns (uint128 z) {\n        unchecked { // Explicit bounds check\n        require((z = uint128(y)) == y);\n        }\n    }\n\n    /// @notice Cast a uint144 to a uint128, revert on overflow\n    /// @param y The uint144 to be downcasted\n    /// @return z The downcasted integer, now type uint128\n    function toUint128By144(uint144 y) internal pure returns (uint128 z) {\n        unchecked{ // Explicit bounds check\n        require((z = uint128(y)) == y);\n        }\n    }\n    \n    /// @notice Cast a uint128 to a int128, revert on overflow\n    /// @param y The uint128 to be casted\n    /// @return z The casted integer, now type int128\n    function toInt128Sign(uint128 y) internal pure returns (int128 z) {\n        unchecked { // Explicit bounds check\n        require(y < 2**127);\n        return int128(y);\n        }\n    }\n\n    // Unix timestamp can fit into 32-bits until the year 2106. After which, internally\n    // stored timestamps will stop increasing. Deployed contracts relying on this function\n    // should be re-evaluated before that date.\n    function timeUint32() internal view returns (uint32) {\n        unchecked { // Explicit bounds check\n        uint time = block.timestamp;\n        if (time > type(uint32).max) { return type(uint32).max; }\n        return uint32(time);\n        }\n    }\n}\n"
    },
    "contracts/libraries/SwapCurve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport './TickMath.sol';\nimport './LiquidityMath.sol';\nimport './SafeCast.sol';\nimport './CurveMath.sol';\nimport './CurveAssimilate.sol';\nimport './CurveRoll.sol';\nimport './PoolSpecs.sol';\nimport './Directives.sol';\nimport './Chaining.sol';\n\n/* @title Swap Curve library.\n * @notice Library contains functionality for fully applying a swap directive to \n *         a locally stable AMM liquidty curve within the bounds of the stable range,\n *         in a way that accumulates fees onto the curve's liquidity. */\nlibrary SwapCurve {\n    using SafeCast for uint128;\n    using CurveMath for CurveMath.CurveState;\n    using CurveAssimilate for CurveMath.CurveState;\n    using CurveRoll for CurveMath.CurveState;\n    using Chaining for Chaining.PairFlow;\n\n    /* @notice Applies the swap on to the liquidity curve, either fully exhausting\n     *   the swap or reaching the concentrated liquidity bounds or the user-specified\n     *   limit price. After calling, the curve and swap objects will be updated with\n     *   the swap price impact, the liquidity fees assimilated into the curve's ambient\n     *   liquidity, and the swap accumulators incremented with the cumulative flows.\n     * \n     * @param curve - The current in-range liquidity curve. After calling, price and\n     *    fee accumulation will be adjusted based on the swap processed in this leg.\n     * @param accum - An accumulator for the asset pair the swap/curve applies to.\n     *    This object will be incremented with the flow processed on this leg. The swap\n     *    may or may not be fully exhausted. Caller should check the swap.qty_ field.\n     @ @param swap - The user directive specifying the swap to execute on this curve.\n     *    Defines the direction, size, and limit price. After calling, the swapQty will\n     *    be decremented with the amount of size executed in this leg.\n     * @param pool - The specifications for the pool's AMM curve, notably in this context\n     *    the fee rate and protocol take.     *\n     * @param bumpTick - The tick boundary, past which the constant product AMM \n     *    liquidity curve is no longer known to be valid. (Either because it represents\n     *    a liquidity bump point, or the end of a tick bitmap horizon.) The curve will \n     *    never move past this tick boundary in the call. Caller's responsibility is to \n     *    set this parameter in the correct direction. I.e. buys should be the boundary \n     *    from above and sells from below. Represented as a price tick index. */\n    function swapToLimit (CurveMath.CurveState memory curve,\n                          Chaining.PairFlow memory accum,\n                          Directives.SwapDirective memory swap,\n                          PoolSpecs.Pool memory pool, int24 bumpTick) pure internal {\n        uint128 limitPrice = determineLimit(bumpTick, swap.limitPrice_, swap.isBuy_);\n        uint128 startPrice = curve.priceRoot_;\n\n        (int128 paidBase, int128 paidQuote, uint128 paidProto) =\n            bookExchFees(curve, swap.qty_, pool, swap.inBaseQty_, limitPrice);\n        accum.accumSwap(swap.inBaseQty_, paidBase, paidQuote, paidProto);\n        \n        // limitPrice is still valid even though curve has moved from ingesting liquidity\n        // fees in bookExchFees(). That's because the collected fees are mathematically\n        // capped at a fraction of the flow necessary to reach limitPrice. See\n        // bookExchFees() comments. (This is also why we book fees before swapping, so we\n        // don't run into the limitPrice when trying to ingest fees.)\n        (paidBase, paidQuote, swap.qty_) = swapOverCurve\n            (curve, swap.inBaseQty_, swap.isBuy_, swap.qty_, limitPrice);\n        accum.accumSwap(swap.inBaseQty_, paidBase, paidQuote, 0);\n        assertPriceDirection(swap.isBuy_, curve, startPrice);\n    }\n\n    /* @notice Validates the invariant that the price change is in the direction of the swap. */\n    function assertPriceDirection (bool isBuy, CurveMath.CurveState memory curve, uint128 startPrice) pure private {\n        require(isBuy ? curve.priceRoot_ >= startPrice : curve.priceRoot_ <= startPrice);\n    }\n\n    /* @notice Calculates the exchange fee given a swap directive and limitPrice. Note \n     *   this assumes the curve is constant-product without liquidity bumps through the\n     *   whole range. Don't use this function if you're unable to guarantee that the AMM\n     *   curve is locally stable through the price impact.\n     *\n     * @param curve The current state of the AMM liquidity curve. Must be stable without\n     *              liquidity bumps through the price impact.\n     * @param swapQty The quantity specified for this leg of the swap, may or may not be\n     *                fully executed depending on limitPrice.\n     * @param feeRate The pool's fee as a proportion of notion executed. Represented as\n     *                a multiple of 0.0001%\n     * @param protoTake The protocol's take as a share of the exchange fee. (Rest goes to\n     *                  liquidity rewards.) Represented as 1/n (with zero a special case.)\n     * @param inBaseQty If true the swap quantity is denominated as base-side tokens. If \n     *                  false, quote-side tokens.\n     * @param limitPrice The max (min) price this leg will swap to if it's a buy (sell).\n     *                   Represented as the square root of price as a Q64.64 fixed-point.\n     *\n     * @return liqFee The total fees that's allocated as liquidity rewards accumulated\n     *                to liquidity providers in the pool (in the opposite side tokens of\n     *                the swap denomination).\n     * @return protoFee The total fee accumulated as SdexSwap protocol fees. */\n    function calcFeeOverSwap (CurveMath.CurveState memory curve, uint128 swapQty,\n                              uint16 feeRate, uint8 protoTake,\n                              bool inBaseQty, uint128 limitPrice)\n        internal pure returns (uint128 liqFee, uint128 protoFee) {\n        uint128 flow = curve.calcLimitCounter(swapQty, inBaseQty, limitPrice);\n        (liqFee, protoFee) = calcFeeOverFlow(flow, feeRate, protoTake);\n    }\n\n    /* @notice Give a pre-determined price limit, executes a fixed amount of swap \n     *         quantity into the liquidity curve. \n     *\n     * @dev    Note that this function does *not* process liquidity fees, and those should\n     *         be collected and assimilated into the curve *before* calling this function.\n     *         Otherwise we may reach the end of the locally stable curve and not be able\n     *         to correctly account for the impact on the curve.\n     *\n     * @param curve The liquidity curve state being executed on. This object will update \n     *              with the post-swap impact.\n     * @param inBaseQty If true, the swapQty param is denominated in base-side tokens.\n     * @param isBuy If true, the swap is paying base tokens to the pool and receiving \n     *              quote tokens.\n     * @param swapQty The total quantity to be swapped. May or may not be fully exhausted\n     *                depending on limitPrice.\n     * @param limitPrice The max (min) price this leg will swap to if it's a buy (sell).\n     *                   Represented as the square root of price as a Q64.64 fixed-point.\n     *\n     * @return paidBase The amount of base-side token flow associated with this leg of\n     *                  the swap (not counting previously collected fees). If negative\n     *                  pool is paying out base-tokens. If positive pool is collecting.\n     * @return paidQuote The amount of quote-side token flow for this leg of the swap.\n     * @return qtyLeft The total amount of swapQty left after this leg executes. If swap\n     *                 fully executes, this value will be zero. */\n    function swapOverCurve (CurveMath.CurveState memory curve,\n                            bool inBaseQty, bool isBuy, uint128 swapQty,\n                            uint128 limitPrice) pure private\n        returns (int128 paidBase, int128 paidQuote, uint128 qtyLeft) {\n\n        // Invariant check swap direction matches price direction\n        require(isBuy ? limitPrice >= curve.priceRoot_ : limitPrice <= curve.priceRoot_);\n\n        uint128 realFlows = curve.calcLimitFlows(swapQty, inBaseQty, limitPrice);\n        bool hitsLimit = realFlows < swapQty;\n\n        if (hitsLimit) {\n            (paidBase, paidQuote, qtyLeft) = curve.rollPrice\n                (limitPrice, inBaseQty, isBuy, swapQty);\n            assertPriceEndStable(curve, qtyLeft, limitPrice);\n\n        } else {\n            uint128 startPrice = curve.priceRoot_;\n            (paidBase, paidQuote, qtyLeft) = curve.rollFlow\n                (realFlows, inBaseQty, isBuy, swapQty);\n            assertFlowEndStable(curve, qtyLeft, isBuy, limitPrice);\n            assertPriceDirection(isBuy, curve, startPrice);\n        }\n    }\n\n    /* In rare corner cases, swap can result in a corrupt end state. This occurs\n     * when the swap flow lands within in a rounding error of the limit price. That \n     * potentially creates an error where we're swapping through a curve price range\n     * without supported liquidity. \n     *\n     * The other corner case is the flow based swap not exhausting liquidity for some\n     * code or rounding reason. The upstream logic uses the exhaustion of the swap qty\n     * to determine whether a liquidity bump was reached. In this case it would try to\n     * inappropriately kick in liquidity at a bump the price hasn't reached.\n     *\n     * In both cases the condition is so astronomically rare that we just crash the \n     * transaction. */\n    function assertFlowEndStable (CurveMath.CurveState memory curve,\n                                  uint128 qtyLeft, bool isBuy,\n                                  uint128 limitPrice) pure private {\n        bool insideLimit = isBuy ?\n            curve.priceRoot_ < limitPrice :\n            curve.priceRoot_ > limitPrice;\n        bool hasNone = qtyLeft == 0;\n        require(insideLimit && hasNone, \"RF\");\n    }\n\n    /* Similar to asserFlowEndStable() but for limit-bound swap legs. Due to rounding \n     * effects we may also simultaneously exhaust the flow at the same exact point we\n     * reach the limit barrier. This could corrupt the upstream logic which uses the\n     * remaining qty to determine whether we've reached a tick bump. \n     * \n     * In this case the corner case would mean it would fail to kick in new liquidity \n     * that's required by reaching the tick bump limit. Again this is so astronomically \n     * rare for non-pathological curves that we just crash the transaction. */\n    function assertPriceEndStable (CurveMath.CurveState memory curve,\n                                   uint128 qtyLeft, uint128 limitPrice) pure private {\n        bool atLimit = curve.priceRoot_ == limitPrice;\n        bool hasRemaining = qtyLeft > 0;\n        require(atLimit && hasRemaining, \"RP\");\n    }\n\n    /* @notice Determines an effective limit price given the combination of swap-\n     *    specified limit, tick liquidity bump boundary on the locally stable AMM curve,\n     *    and the numerical boundaries of the price field. Always picks the value that's\n     *    most to the inside of the swap direction. */\n    function determineLimit (int24 bumpTick, uint128 limitPrice, bool isBuy)\n        pure private returns (uint128) {\n        unchecked {\n        uint128 bounded = boundLimit(bumpTick, limitPrice, isBuy);\n        if (bounded < TickMath.MIN_SQRT_RATIO)  return TickMath.MIN_SQRT_RATIO;\n        if (bounded >= TickMath.MAX_SQRT_RATIO) return TickMath.MAX_SQRT_RATIO - 1; // Well above 0, cannot underflow\n        return bounded;\n        }\n    }\n\n    /* @notice Finds the effective max (min) swap limit price giving a bump tick index\n     *         boundary and a user specified limitPrice.\n     * \n     * @dev Because the mapping from ticks to bumps always occur at the lowest price unit\n     *      inside a tick, there is an asymmetry between the lower and upper bump tick arg. \n     *      The lower bump tick is the lowest tick *inclusive* for which liquidity is active.\n     *      The upper bump tick is the *next* tick above where liquidity is active. Therefore\n     *      the lower liquidity price maps to the bump tick price, whereas the upper liquidity\n     *      price bound maps to one unit less than the bump tick price.\n     *\n     *     Lower bump price                             Upper bump price\n     *            |                                           |\n     *      ------X******************************************+X-----------------\n     *            |                                          |\n     *     Min liquidity prce                         Max liquidity price\n     */ \n    function boundLimit (int24 bumpTick, uint128 limitPrice, bool isBuy)\n        pure private returns (uint128) {\n        unchecked {\n        if (bumpTick <= TickMath.MIN_TICK || bumpTick >= TickMath.MAX_TICK) {\n            return limitPrice;\n        } else if (isBuy) {\n            /* See comment above. Upper bound liquidity is last active at the price one unit\n             * below the upper tick price. */\n            uint128 TICK_STEP_SHAVE_DOWN = 1;\n\n            // Valid uint128 root prices are always well above 0.\n            uint128 bumpPrice = TickMath.getSqrtRatioAtTick(bumpTick) - TICK_STEP_SHAVE_DOWN;\n            return bumpPrice < limitPrice ? bumpPrice : limitPrice;\n        } else {\n            uint128 bumpPrice = TickMath.getSqrtRatioAtTick(bumpTick);\n            return bumpPrice > limitPrice ? bumpPrice : limitPrice;\n        }\n        }\n    }\n\n    /* @notice Calculates exchange fee charge based off an estimate of the predicted\n     *         order flow on this leg of the swap.\n     * \n     * @dev    Note that the process of collecting the exchange fee itself alters the\n     *   structure of the curve, because those fees assimilate as liquidity into the \n     *   curve new liquidity. As such the flow used to pro-rate fees is only an estimate\n     *   of the actual flow that winds up executed. This means that fees are not exact \n     *   relative to realized flows. But because fees only have a small impact on the \n     *   curve, they'll tend to be very close. Getting fee exactly correct doesn't \n     *   matter, and either over or undershooting is fine from a collateral stability \n     *   perspective. */\n    function bookExchFees (CurveMath.CurveState memory curve,\n                           uint128 swapQty, PoolSpecs.Pool memory pool,\n                           bool inBaseQty, uint128 limitPrice) pure private\n        returns (int128, int128, uint128) {\n        (uint128 liqFees, uint128 exchFees) = calcFeeOverSwap\n            (curve, swapQty, pool.feeRate_, pool.protocolTake_, inBaseQty, limitPrice);\n                \n        /* We can guarantee that the price shift associated with the liquidity\n         * assimilation is safe. The limit price boundary is by definition within the\n         * tick price boundary of the locally stable AMM curve (see determineLimit()\n         * function). The liquidity assimilation flow is mathematically capped within \n         * the limit price flow, because liquidity fees are a small fraction of swap\n         * flows. */\n        curve.assimilateLiq(liqFees, inBaseQty);\n\n        return assignFees(liqFees, exchFees, inBaseQty);\n    }\n\n    /* @notice Correctly applies the liquidity and protocol fees to the correct side in\n     *         in th pair, given how the swap is denominated. */\n    function assignFees (uint128 liqFees, uint128 exchFees, bool inBaseQty)\n        pure private returns (int128 paidBase, int128 paidQuote,\n                              uint128 paidProto) {\n        unchecked {\n            // Safe for unchecked because total fees are always previously calculated in\n            // 128-bit space\n            uint128 totalFees = liqFees + exchFees; \n\n            if (inBaseQty) {\n                paidQuote = totalFees.toInt128Sign();\n            } else {\n                paidBase = totalFees.toInt128Sign();\n            }\n            paidProto = exchFees;\n        }\n    }\n\n    /* @notice Given a fixed flow and a fee rate, calculates the owed liquidty and \n     *         protocol fees. */\n    function calcFeeOverFlow (uint128 flow, uint16 feeRate, uint8 protoProp)\n        private pure returns (uint128 liqFee, uint128 protoFee) {\n        unchecked {\n            uint256 FEE_BP_MULT = 1_000_000;\n            \n            // Guaranteed to fit in 256 bit arithmetic. Safe to cast back to uint128\n            // because fees will never be larger than the underlying flow.            \n            uint256 totalFee = (uint256(flow) * feeRate) / FEE_BP_MULT;\n            protoFee = uint128(totalFee * protoProp / 256);\n            liqFee = uint128(totalFee) - protoFee;\n        }\n    }\n}\n"
    },
    "contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.19;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.64 numbers. Supports\n/// prices between 2**-96 and 2**120\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-96\n    int24 internal constant MIN_TICK = -665454;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**120\n    int24 internal constant MAX_TICK = 831818;\n    \n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK). The reason we don't set this as min(uint128) is so that single precicion moves represent a small fraction.\n    uint128 internal constant MIN_SQRT_RATIO = 65538;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint128 internal constant MAX_SQRT_RATIO = 21267430153580247136652501917186561138;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^64\n    /// @dev Throws if tick < MIN_TICK or tick > MAX_TICK\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX64 A Fixed point Q64.64 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint128 sqrtPriceX64) {\n        // Set to unchecked, but the original UniV3 library was written in a pre-checked version of Solidity\n        unchecked { \n        require(tick >= MIN_TICK && tick <= MAX_TICK);\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<64 rounding up to go from a Q128.128 to a Q64.64\n        // we then downcast because we know the result always fits within 128 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX64 = uint128((ratio >> 64) + (ratio % (1 << 64) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX64 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX64 The sqrt ratio for which to compute the tick as a Q64.64\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint128 sqrtPriceX64) internal pure returns (int24 tick) {\n        // Set to unchecked, but the original UniV3 library was written in a pre-checked version of Solidity\n        unchecked {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX64 >= MIN_SQRT_RATIO && sqrtPriceX64 < MAX_SQRT_RATIO);\n        uint256 ratio = uint256(sqrtPriceX64) << 64;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX64 ? tickHi : tickLow;\n        }\n    }\n}\n"
    },
    "contracts/libraries/TokenFlow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport './Chaining.sol';\n\n/* @title Token flow library\n * @notice Provides a facility for joining token flows for trades that occur on an \n *         arbitrary long chain of overlapping pairs. */\nlibrary TokenFlow {\n\n    /* @notice Represents the current hop within a chain of pair hops.\n     * @param baseToken_ The base token in the current pair. (If zero native Ethereum)\n     * @param quoteToken_ The quote token in the current pair.\n     * @param isBaseFront_ If true, then the base side of the pair represents the entry\n     *                     token on this hop in the chain.\n     * @param legFlow_ - Represents the total flow from the exit side on the previous pair\n     *                   hop in the chain.\n     * @param flow_ - Accumulator to collect the flow on this pair hop. */\n    struct PairSeq {\n        address baseToken_;\n        address quoteToken_;\n        bool isBaseFront_;\n        int128 legFlow_;\n        Chaining.PairFlow flow_;\n    }\n\n    /* @notice Moves the PairSeq cursor object onto the next pair in a hop.\n     *\n     * @dev    Note that this doesn't process, roll or reset flows. All of the \n     *         bookkeeping related to this and settlement should be done *before* calling\n     *         this on the next pair. \n     *\n     * @param seq The cursor object, pair tokens will be updated after call.\n     * @param tokenFront The token associated with the front or entry of the chain's \n     *                   next pair hop.\n     * @param tokenBack The token associated with the back or exit of the chain's \n     *                  next pair hop. */     \n    function nextHop (PairSeq memory seq, address tokenFront, address tokenBack)\n        pure internal {\n        seq.isBaseFront_ = tokenFront < tokenBack;\n        if (seq.isBaseFront_) {\n            seq.baseToken_ = tokenFront;\n            seq.quoteToken_ = tokenBack;\n        } else {\n            seq.quoteToken_ = tokenFront;\n            seq.baseToken_ = tokenBack;\n        }\n    }\n\n    /* @notice Returns the token at the front/entry side of the pair hop. */\n    function frontToken (PairSeq memory seq) internal pure returns (address) {\n        return seq.isBaseFront_ ? seq.baseToken_ : seq.quoteToken_;\n    }\n\n    /* @notice Returns the token at the back/exit side of the pair hop. */\n    function backToken (PairSeq memory seq) internal pure returns (address) {\n        return seq.isBaseFront_ ? seq.quoteToken_ : seq.baseToken_;\n    }\n\n    /* @notice Called when all the flows have been tallied and finalized for this\n     *         pair hop in the chain. Resets and rolls the object and returns the net\n     *         flows to be settled between user and exchange.\n     *\n     * @param seq The PairSeq cursor object. Aftering calling the object will be updated \n     *            to have the back/exit flow rolled into the leg for the next hop, and \n     *            the previous accumulators will be reset.\n     *\n     * @return clippedFlow The net flow (inclusive of the rolled leg flow from the \n     *                     previous hop) on the front/entry side of the pair to be \n     *                     settled. Negative indicates credit from dex to user, positive\n     *                     indicates debit from user to dex.*/\n    function clipFlow (PairSeq memory seq) internal pure returns (int128 clippedFlow) {\n        (int128 frontAccum, int128 backAccum) = seq.isBaseFront_ ?\n            (seq.flow_.baseFlow_, seq.flow_.quoteFlow_) :\n            (seq.flow_.quoteFlow_, seq.flow_.baseFlow_);\n        \n        clippedFlow = seq.legFlow_ + frontAccum;\n        seq.legFlow_ = backAccum;\n        \n        seq.flow_.baseFlow_ = 0;\n        seq.flow_.quoteFlow_ = 0;\n        seq.flow_.baseProto_ = 0;\n        seq.flow_.quoteProto_ = 0;\n    }\n\n    /* @notice Returns the final flow to be settled associated with the closing leg at \n     *         the end of the chain of pair hops. Negative means credit from dex to user.\n     *         Positive is debit from user to dex. */\n    function closeFlow (PairSeq memory seq) internal pure returns (int128) {\n        return seq.legFlow_;\n    }\n\n    /* @notice If true, indicates that the asset-specifying address represents native \n     *         Ethereum. Otherwise it should be the valid address of the ERC20 token \n     *         tracker. */\n    function isEtherNative (address token) internal pure returns (bool) {\n        return token == address(0);\n    }\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.19;\n\nimport '../interfaces/IERC20Minimal.sol';\n\n/// @title TransferHelper\n/// @notice Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false\nlibrary TransferHelper {\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Calls transfer on token contract, errors with TF if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20Minimal.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TF\");\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Calls transferFrom on token contract, errors with TF if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param from The sender address of the transfer\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20Minimal.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TF\");\n    }\n\n    // @notice Transfers native Ether to a recipient.\n    // @dev errors with TF if transfer fails\n    function safeEtherSend(\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, ) = to.call{value: value}(\"\");\n        require(success, \"TF\");\n    }\n\n}\n"
    },
    "contracts/mixins/AgentMask.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport \"./StorageLayout.sol\";\nimport \"../interfaces/ISdexCondOracle.sol\";\n\n/* @title Agent mask mixin.\n * @notice Maps and manages surplus balances, nonces, and external router approvals\n *         based on the wallet addresses of end-users. */\ncontract AgentMask is StorageLayout {\n    using SafeCast for uint256;\n    \n    /* @notice Standard re-entrant gate for an unprivileged order called directly\n     *         by the user.\n     *\n     * @dev    lockHolder_ account is set to msg.sender, and therefore this call will\n     *         touch the positions, tokens, and liquidity owned by msg.sender. */\n    modifier reEntrantLock() {\n        require(lockHolder_ == address(0));\n        lockHolder_ = msg.sender;\n        _;\n        lockHolder_ = address(0);\n        resetMsgVal();\n    }\n\n    /* @notice Re-entrant gate for privileged protocol authority commands. */\n    modifier protocolOnly (bool sudo) {\n        require(msg.sender == authority_ && lockHolder_ == address(0));\n        lockHolder_ = msg.sender;\n        sudoMode_ = sudo;\n        _;\n        lockHolder_ = address(0);\n        sudoMode_ = false;\n        resetMsgVal();\n    }\n\n    /* @notice Re-entrant gate for an order called by external router on behalf of a\n     *         third party client. Requires the user to have previously approved the \n     *         router.\n     *\n     * @dev    lockHolder_ is set to the client address directly supplied by the caller.\n     *         (The client address must always directly approve the msg.sender contract to\n     *         act on its behalf.) Therefore this call (if approved) will touch the positions,\n     *         tokens, and liquidity owned by client address.\n     *\n     * @param client The client who's order the router is calling on behalf of.\n     * @param callPath  The proxy sidecar callpath the agent is requesting to call on the user's behalf */\n    modifier reEntrantApproved (address client, uint16 callPath) {\n        stepAgentNonce(client, msg.sender, callPath);\n        require(lockHolder_ == address(0));\n        lockHolder_ = client;\n        _;\n        lockHolder_ = address(0);\n        resetMsgVal();\n    }\n\n    /* @notice Re-entrant gate for a relayer calling an order that was signed off-chain\n     *         using the EIP-712 standard.\n     *\n     * @dev    lockHolder_ is set to the address whose private key signed the ECDSA \n     *         signature. Regardless of which address is msg.sender, all operations inside\n     *         this call will touch the positions, tokens, and liquidity owned by the\n     *         signing address.  */\n    modifier reEntrantAgent (SdexRelayerCall memory call,\n                             bytes calldata signature) {\n        require(lockHolder_ == address(0));\n        lockHolder_ = lockSigner(call, signature);\n        _;\n        lockHolder_ = address(0);\n        resetMsgVal();\n    }\n\n    struct SdexRelayerCall {\n        uint16 callpath;\n        bytes cmd;\n        bytes conds;\n        bytes tip;\n    }\n\n    /* @notice Atomically returns the msg.value of the transaction and marks the funds as\n     *         spent. This provides a layer of safety to prevent msg.value from being spent\n     *         twice in a single transaction.\n     * @dev    For safety msg.value should *never* be accessed in any way outside this function.\n     *         This assures that if msg.value is used at one point in the callpath it isn't \n     *         inadvertantly used at another point, because that would trigger a revert. */\n    function popMsgVal() internal returns (uint128 msgVal) {\n        require(msgValSpent_ == false, \"DS\");\n        msgVal = msg.value.toUint128();\n        msgValSpent_ = true;\n    }\n\n    /* @dev This should only be called when the top-level contract call is fully out-of-scope.\n     *      Otherwise the risk is msg.val could be double spent. */\n    function resetMsgVal() private {\n        msgValSpent_ = false;\n    }\n    \n    /* @notice Given the order, evaluation conditionals, and off-chain signature, recovers\n     *         the client address if valid or reverts the transactions. */\n    function lockSigner (SdexRelayerCall memory call,\n                         bytes calldata signature) private returns (address client) {\n        client = verifySignature(call, signature);\n        checkRelayConditions(client, call.conds);\n    }\n\n    /* @notice Verifies that the conditions signed by the user are met at evaluation time,\n     *         and if necessary increments the nonce. \n     *\n     * @param client The client who's order is being evaluated on behalf of.\n     * @param deadline The deadline (in block time) that the order must be evaluated by.\n     * @param alive    The live time (in block time) that the order cannot be evaluated\n     *                 before.\n     * @param salt     A salt to apply when checking the nonce. Allows users to sign\n     *                 an arbitrary number of multiple nonce tracks, so they don't have\n     *                 to wait for unrelated orders.\n     * @param nonce    The replay-attack prevention nonce. Two orders with the same salt\n     *                 and nonce cannot be evaluated (unless the user explicitly resets\n     *                 the nonce). A nonce cannot be evaluated until prior orders at\n     *                 lower nonces haven been successfully evaluated.\n     * @param relayer  Address of the relayer the user requires to evaluate the order.\n     *                 Must match either msg.sender or tx.origin. If zero, the order\n     *                 does not require a specific relayer. */\n    function checkRelayConditions (address client, bytes memory conds) internal {\n        (uint48 deadline, uint48 alive, bytes32 salt, uint32 nonce,\n         address relayer)\n            = abi.decode(conds, (uint48, uint48, bytes32, uint32, address));\n        \n        require(block.timestamp <= deadline);\n        require(block.timestamp >= alive);\n        require(relayer == address(0) || relayer == msg.sender || relayer == tx.origin);\n        stepNonce(client, salt, nonce);\n    }\n\n    /* @notice Verifies the supplied signature matches the EIP-712 compatible data.\n     *\n     * @dev Note that the ECDSA signature is malleable, because (v, r, s) are unrestricted.\n     *      However this is not an issue, because the raw signature itself is not used as an\n     *      index or nonce in any form. A malicious attacker *could* change the signature, but\n     *      could not change the plaintext checksum being signed. \n     * \n     *      If a malleable signature was submitted, either it would arrive before the honest \n     *      signature, in which case the call parameters would be identical. Or it would arrive after\n     *      the honest signature, in which case the call parameter would be rejected becaue it\n     *      used an expired nonce. In no state of the world does a malleable signature make a \n     *      replay attack possible. */\n    function verifySignature (SdexRelayerCall memory call,\n                              bytes calldata signature)\n        internal view returns (address client) {\n        (uint8 v, bytes32 r, bytes32 s) =\n            abi.decode(signature, (uint8, bytes32, bytes32));\n        bytes32 checksum = checksumHash(call);\n        client = ecrecover(checksum, v, r, s);\n        require(client != address(0));\n    }\n    \n    /* @notice Calculates the EIP-712 hash to check the signature against. */\n    function checksumHash (SdexRelayerCall memory call)\n        private view returns (bytes32) {\n        bytes32 hash = contentHash(call);\n        return keccak256(abi.encodePacked\n                         (\"\\x19\\x01\", domainHash(), hash));\n    }\n\n    bytes32 constant CALL_SIG_HASH = \n        keccak256(\"SdexRelayerCall(uint8 callpath,bytes cmd,bytes conds,bytes tip)\");\n    bytes32 constant DOMAIN_SIG_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 constant APP_NAME_HASH = keccak256(\"SdexSwap\");\n    bytes32 constant VERSION_HASH = keccak256(\"1.0\");\n\n    /* @notice Calculates the EIP-712 typedStruct hash. */\n    function contentHash (SdexRelayerCall memory call)\n        private pure returns (bytes32) {\n        return keccak256(\n            abi.encode\n            (CALL_SIG_HASH, call.callpath,\n             keccak256(call.cmd),\n             keccak256(call.conds),\n             keccak256(call.tip)));\n    }\n\n    /* @notice Calculates the EIP-712 domain hash. */\n    function domainHash() private view returns (bytes32) {\n        return keccak256(\n            abi.encode\n            (DOMAIN_SIG_HASH, APP_NAME_HASH, VERSION_HASH, block.chainid, address(this)));\n    }\n\n    /* @notice Returns the payer and receiver of any settlement collateral flows.\n     * @return debit The address that will be paying any debits to the pool.\n     * @return credit The address that will receive any credits from the pool. */\n    function agentsSettle() internal view returns (address debit, address credit) {\n        (debit, credit) = (lockHolder_, lockHolder_);\n    }\n\n\n    /* @notice Approves an external router or agent to act on a user's behalf.\n     * @param router The address of the external agent.\n     * @param nCalls The number of calls the external router is authorized to make. Set\n     *               to uint32.max for unlimited.\n     * @param callPath The specific proxy sidecar callpath that the router is approved for */\n    function approveAgent (address router, uint32 nCalls, uint16 callPath) internal {\n        bytes32 key = agentKey(lockHolder_, router, callPath);\n        UserBalance storage bal = userBals_[key];\n        bal.agentCallsLeft_ = nCalls;\n    }\n\n    /* @notice Sets the nonce index related to EIP-712 off-chain calls. \n     * @param nonceSalt The nonce system is multi-dimensional, which allows relayers to\n     *                  pass along arbitrary ordered messages when they come from \n     *                  unrelated streams. This value corresponds to the specific nonce\n     *                  dimension.\n     * @param nonce The nonce index value the nonce will be reset to. */\n    function resetNonce (bytes32 nonceSalt, uint32 nonce) internal {\n        UserBalance storage bal = userBals_[nonceKey(lockHolder_, nonceSalt)];\n        require(nonce >= bal.nonce_, \"NI\");\n        bal.nonce_ = nonce;\n    }\n\n    /* @notice Same as resetNonce but conditions on the successful call return to an \n     *         external oracle. Useful for certain times that a user wants to pre-sign\n     *         a transaction, but not let it be executable unless an arbitrary condition\n     *         is met. \n     * @param nonceSalt The nonce system is multi-dimensional, which allows relayers to\n     *                  pass along arbitrary ordered messages when they come from \n     *                  unrelated streams. This value corresponds to the specific nonce\n     *                  dimension.\n     * @param nonce The nonce index value the nonce will be reset to.\n     * @param oracle The address of the external oracle (must conform to ISdexNonceOracle\n     *               interface.\n     * @param args Arbitrary calldata passed to the oracle condition call. */\n    function resetNonceCond (bytes32 salt, uint32 nonce, address oracle,\n                             bytes memory args) internal {\n        bool canProceed = ISdexNonceOracle(oracle).checkSdexNonceSet\n            (lockHolder_, salt, nonce, args);\n        require(canProceed, \"ON\");\n        resetNonce(salt, nonce);\n    }\n\n    /* @notice Flat call that checks an external oracle and reverts the transaction if the\n     *         oracle call fails. Useful in a multicall context, where we want to pre-\n     *         condition on some external requirement.\n     * @param oracle The address of the external oracle (must conform to ISdexCondOracle\n     *               interface.\n     * @param args Arbitrary calldata passed to the oracle condition call. */\n    function checkGateOracle (address oracle, bytes memory args) internal {\n        bool canProceed = ISdexCondOracle(oracle).checkSdexCond\n            (lockHolder_, args);\n        require(canProceed, \"OG\");\n    }\n\n    /* @notice Compare-and-swap the nCalls on a single external agent call. Checks that\n     *         the agent is authorized to perform another call, and if so decrements the\n     *         number of remaining calls.\n     * @param client The client the agent is making the call on behalf of.\n     * @param agent The address of the external agent making the call.\n     * @param callPath The proxy sidecar the call is being made on. */\n    function stepAgentNonce (address client, address agent, uint16 callPath) internal {\n        UserBalance storage bal = userBals_[agentKey(client, agent, callPath)];\n        if (bal.agentCallsLeft_ < type(uint32).max) {\n            require(bal.agentCallsLeft_ > 0);\n            --bal.agentCallsLeft_;\n        }\n    }\n\n    /* @notice Compare-and-swap the nonce on a single EIP-712 signed transaction. Checks\n     *         that the nonce matches the current nonce for the user/salt, and atomically\n     *         increments the nonce.\n     * @param client The client the agent is making the call on behalf of.\n     * @param salt The multidimensional nonce dimension the call is being applied to.\n     * @param nonce The nonce the EIP-712 message is signed for. This must match the \n     *              current nonce or the transaction will fail. */\n    function stepNonce (address client, bytes32 nonceSalt, uint32 nonce) internal {\n        UserBalance storage bal = userBals_[nonceKey(client, nonceSalt)];\n        require(bal.nonce_ == nonce);\n        ++bal.nonce_;\n    }\n\n    /* @notice Called within the context of an EIP-712 transaction, where the underlying\n     *         client pays the relayer for having mined the transaction. (If the cmd byte\n     *         data is empty, no tip is paid).\n     *\n     * @dev Thie call will always occur at the *end* of a transaction. So the user must \n     *      have sufficient balance in their surplus collateral to cover the tip by the\n     *      completion of the transaction.\n     *\n     * @param token The token the tip is being paid in. This will always be paid from the\n     *              user's surplus collateral balance.\n     * @param tip The amount the user is paying in tip. If protocol fee is turned on this\n     *            is the *total* amount paid. The relayer will receive this less protocol\n     *            fee. Tip can also be set to uint128.max, and will pay the full amount\n     *            of the client's surplus collateral balance.\n     * @param recv The receiver of the tip. This will always be paid to this account's\n     *             surplus collateral balance. Also supports generic magic values for \n     *             generic relayer payment:\n     *                 0x100 - Paid to the msg.sender, regardless of who made the dex call\n     *                 0x200 - Paid to the tx.origin, regardless of who sent tx. */\n    function tipRelayer (bytes memory tipCmd) internal {\n        if (tipCmd.length == 0) { return; }\n        \n        (address token, uint128 tip, address recv) =\n            abi.decode(tipCmd, (address, uint128, address));\n        \n        recv = maskTipRecv(recv);\n        bytes32 fromKey = tokenKey(lockHolder_, token);\n        bytes32 toKey = tokenKey(recv, token);\n        \n        if (tip == type(uint128).max) {\n            tip = userBals_[fromKey].surplusCollateral_;\n        }\n        require(userBals_[fromKey].surplusCollateral_ >= tip);\n        \n        uint128 protoFee = tip * relayerTakeRate_ / 256;\n        uint128 relayerTip = tip - protoFee;\n        \n        userBals_[fromKey].surplusCollateral_ -= tip;\n        userBals_[toKey].surplusCollateral_ += relayerTip;\n        if (protoFee > 0) {\n            feesAccum_[token] += protoFee;\n        }\n    }\n\n    address constant MAGIC_SENDER_TIP = address(256);\n    address constant MAGIC_ORIGIN_TIP = address(512);\n\n    /* @notice Converts the user's tip recv argument to the actual address to be paid.\n     *         In practice this means that the magic values for msg.sender and tx.origin\n     *         are converted to those value's actual address for the transaction. */\n    function maskTipRecv (address recv) view private returns (address) {\n        if (recv == MAGIC_SENDER_TIP) {\n            recv = msg.sender;\n        } else if (recv == MAGIC_ORIGIN_TIP) {\n            recv = tx.origin;\n        } \n        return recv;\n    }\n\n    /* @notice Given a user address and a salt returns a new virtualized user address. \n     *         Useful when we want multiple synthetic accounts tied to a single address.*/\n    function virtualizeUser (address client, uint256 salt) internal pure returns\n        (address) {\n        if (salt == 0) { return client; }\n        else {\n            return PoolSpecs.virtualizeAddress(client, salt);\n        }\n    }\n\n    /* @notice Returns the user balance key given a user account an an inner salt. */\n    function nonceKey (address user, bytes32 innerKey) pure internal returns (bytes32) {\n        return keccak256(abi.encode(user, innerKey));\n    }\n\n    /* @notice Returns a token balance key given a user and token address. */\n    function tokenKey (address user, address token) pure internal returns (bytes32) {\n        return keccak256(abi.encode(user, token));\n    }\n\n    /* @notice Returns a token balance key given a user, token and an arbitrary salt. */\n    function tokenKey (address user, address token, uint256 salt) pure internal\n        returns (bytes32) {\n        return tokenKey(user, PoolSpecs.virtualizeAddress(token, salt));\n    }\n\n    /* @notice Returns an agent key given a user, an agent address and a specific\n     *         call path. */\n    function agentKey (address user, address agent, uint16 callPath) pure internal\n        returns (bytes32) {\n        return keccak256(abi.encode(user, agent, callPath));\n    }\n\n}\n"
    },
    "contracts/mixins/DepositDesk.sol": {
      "content": "// SPDX-License-Identifier: GPL-3                                                          \npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport './StorageLayout.sol';\nimport './SettleLayer.sol';\nimport '../interfaces/IERC20Minimal.sol';\n\ncontract DepositDesk is SettleLayer {\n    using SafeCast for uint256;\n\n    /* @notice Directly deposits a certain amount of surplus collateral to a user's\n     *         account.\n     *\n     * @dev    This call can be used both for token and native Ether collateral. For\n     *         tokens, each call initiates a token transfer call to the ERC20 contract,\n     *         and it's safe to call repeatedly in the same transaction even for the same\n     *         token. \n     * \n     *         For native Ether deposits, the call consumes the value in msg.value using the\n     *         popMsgVal() function. If called more than once in a single transction\n     *         popMsgVal() will revert. Therefore if calling depositSurplus() on native ETH\n     *         be aware than calling more than once in a single transaction result in the top-\n     *         level SdexSwapDex contract call failing and reverting.\n     *\n     * @param recv The address of the owner associated with the account.\n     * @param value The amount to be collected from owner and deposited.\n     * @param token The ERC20 address of the token (or native Ether if set to 0x0) being\n     *              deposited. */\n    function depositSurplus (address recv, uint128 value, address token) internal {\n        debitTransfer(lockHolder_, value, token, popMsgVal());\n        bytes32 key = tokenKey(recv, token);\n        userBals_[key].surplusCollateral_ += value;\n    }\n\n    /* @notice Same as deposit surplus, but used with EIP-2612 compliant tokens that have\n     *         a permit function. Allows the user to avoid needing to approve() the DEX\n     *         contract.\n     *\n     * @param recv  The address which will receive the surplus collateral balance\n     * @param value The amount of tokens being deposited\n     * @param token The address of the token deposited\n     * @param deadline The deadline that this ERC20 permit call is valid for\n     * @param v,r,s  The EIP-712 signature approviing Permit of the token underlying \n     *               token to be deposited. */\n    function depositSurplusPermit (address recv, uint128 value, address token,\n                                   uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        internal {\n        IERC20Permit(token).permit(recv, address(this), value, deadline, v, r, s);\n        depositSurplus(recv, value, token);\n    }\n\n    /* @notice Pays out surplus collateral held by the owner at the exchange.\n     *\n     * @dev There is no security check associated with this call. It's the caller's \n     *      responsibility of the caller to make sure the receiver is authorized to\n     *      to collect the owner's balance.\n     *\n     * @param recv  The receiver where the collateral will be sent to.\n     * @param size  The amount to be paid out. Owner's balance will be decremented \n     *              accordingly. Be aware this uses the following convention:\n     *                  Positive - pay out the fixed size amount\n     *                  Zero     - pays out the entire balance\n     *                  Negative - pays out the entire balance *excluding* the size amount\n     * @param token The ERC20 address of the token (or native Ether if set to 0x0) being\n     *              disbursed. */\n    function disburseSurplus (address recv, int128 size, address token) internal {\n        bytes32 key = tokenKey(lockHolder_, token);\n        uint128 balance = userBals_[key].surplusCollateral_;\n        uint128 value = applyTransactVal(size, balance);\n\n        // No need to use msg.value, because unlike trading there's no logical reason\n        // we'd expect it to be set on this call.\n        userBals_[key].surplusCollateral_ -= value;\n        creditTransfer(recv, value, token, 0);\n    }\n\n    /* @notice Transfers surplus collateral from one user to another.\n     * @param to The user account the surplus collateral will be sent from\n     * @param size The total amount of surplus collateral to send. \n     *             Be aware this uses the following convention:\n     *                  Positive - pay out the fixed size amount\n     *                  Zero     - pays out the entire balance\n     *                  Negative - pays out the entire balance *excluding* the size amount\n     * @param token The address of the token the surplus collateral is sent for. */\n    function transferSurplus (address to, int128 size, address token) internal {\n        bytes32 fromKey = tokenKey(lockHolder_, token);\n        bytes32 toKey = tokenKey(to, token);\n        moveSurplus(fromKey, toKey, size);\n    }\n\n    /* @notice Moves an existing surplus collateral balance to a \"side-pocket\" , or a \n     *         separate balance tied to an arbitrary salt.\n     *\n     * @dev    This is primarily useful for pre-signed transactions. For example a user\n     *         could move the bulk of their surplus collateral to a side-pocket to min\n     *         what was at risk in their primary balance.\n     *\n     * @param fromSalt The side pocket salt the surplus balance is being moved from. Use\n     *                 0 for the primary surplus collateral balance. \n     * @param toSalt The side pocket salt the surplus balance is being moved to. Use 0 for\n     *               the primary surplus collateral balance.\n     * @param size The total amount of surplus collateral to send.  \n     *             Be aware this uses the following convention:\n     *                  Positive - pay out the fixed size amount\n     *                  Zero     - pays out the entire balance\n     *                  Negative - pays out the entire balance *excluding* the size amount\n     * @param token The address of the token the surplus collateral is sent for. */\n    function sidePocketSurplus (uint256 fromSalt, uint256 toSalt, int128 size,\n                                address token) internal {\n        address from = virtualizeUser(lockHolder_, fromSalt);\n        address to = virtualizeUser(lockHolder_, toSalt);\n        bytes32 fromKey = tokenKey(from, token);\n        bytes32 toKey = tokenKey(to, token);\n        moveSurplus(fromKey, toKey, size);\n    }\n\n    /* @notice Lower level function to move surplus collateral from one fully salted \n     *         (user+token+side pocket) to another fully salted slot. */\n    function moveSurplus (bytes32 fromKey, bytes32 toKey, int128 size) private {\n        uint128 balance = userBals_[fromKey].surplusCollateral_;\n        uint128 value = applyTransactVal(size, balance);\n\n        userBals_[fromKey].surplusCollateral_ -= value;\n        userBals_[toKey].surplusCollateral_ += value;\n    }\n\n    /* @notice Converts an encoded transfer argument to the actual quantity to transfer.\n     *         Includes syntactic sugar for special transfer types including:\n     *            Positive Value - Transfer this specified amount\n     *            Zero Value - Transfer the full balance\n     *            Negative Value - Transfer everything *above* this specified amount. */\n    function applyTransactVal (int128 qty, uint128 balance) private pure\n        returns (uint128 value) {\n        if (qty < 0) {\n            value = balance - uint128(-qty);\n        } else if (qty == 0) {\n            value = balance;\n        } else {\n            value = uint128(qty);\n        }\n        require(value <= balance, \"SC\");        \n    }\n}\n\n"
    },
    "contracts/mixins/KnockoutCounter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3                                                          \npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport '../libraries/LiquidityMath.sol';\nimport '../libraries/KnockoutLiq.sol';\nimport './LevelBook.sol';\nimport './PoolRegistry.sol';\nimport './AgentMask.sol';\n\n/* @title Knockout Counter\n * @notice Manages the knockout liquidity pivots and positions. Responsible for minting\n *         burning, knocking out, and claiming knockout liquidity, and adjusting bump\n *         points in LevelBook accordingly. *Not* responsible for managing liquidity on \n *         the curve or debiting/creditiing collateral. Knockout liquidity positions \n *         should be separately managed from ordinary liquidity, but knockout liquidity \n *         should be aggregated with AMM/bump point liquidity. */\ncontract KnockoutCounter is LevelBook, PoolRegistry, AgentMask {\n    using SafeCast for uint128;\n    using LiquidityMath for uint128;\n    using LiquidityMath for uint96;\n    using LiquidityMath for uint64;\n    using KnockoutLiq for KnockoutLiq.KnockoutMerkle;\n    using KnockoutLiq for KnockoutLiq.KnockoutPivot;\n    using KnockoutLiq for KnockoutLiq.KnockoutPosLoc;\n\n    /* @notice Emitted at any point a pivot is knocked out. User can use the history\n     *         of these logs to reconstructo the Merkle history necessary to claim\n     *         their fees. */\n    event SdexKnockoutCross (bytes32 indexed pool, int24 indexed tick, bool isBid,\n                             uint32 pivotTime, uint64 feeMileage, uint160 commitEntropy);\n\n    \n    /* @notice Called when a given knockout pivot is crossed. Performs the book-keeping\n     *         related to reseting the pivot object and committing the Merkle history.\n     *         Does *not* adjust the liquidity on the bump point or curve, caller is\n     *         responsible for that upstream.\n     * \n     * @dev This function must only be called *after* the AMM curve has crossed the\n     *      tick and fee odometer on the tick has been updated to reflect the update.\n     *\n     * @param pool The hash index of the AMM pool.\n     * @param isBid If true, indicates that it's a bid pivot being knocked out (i.e.\n     *              that price is moving down through the pivot)\n     * @param tick The tick index of the knockout pivot.\n     * @param feeMileage The in range fee mileage at the point the pivot was crossed. */\n    function crossKnockout (bytes32 pool, bool isBid, int24 tick, \n                            uint64 feeGlobal) internal {\n        bytes32 lvlKey = KnockoutLiq.encodePivotKey(pool, isBid, tick);\n        KnockoutLiq.KnockoutPivot storage pivot = knockoutPivots_[lvlKey];\n        KnockoutLiq.KnockoutMerkle storage merkle = knockoutMerkles_[lvlKey];\n\n        unmarkPivot(pool, isBid, tick);\n        uint64 feeRange = knockoutRangeLiq(pool, pivot, isBid, tick, feeGlobal);\n\n        merkle.commitKnockout(pivot, feeRange);\n        emit SdexKnockoutCross(pool, tick, isBid, merkle.pivotTime_, merkle.feeMileage_,\n                               KnockoutLiq.commitEntropySalt());\n        pivot.deletePivot(); // Nice little SSTORE refund for the swapper\n    }\n\n    /* @notice Removes the liquidity at the AMM curve's bump points as part of a pivot\n     *         being knocked out by a level cross. */\n    function knockoutRangeLiq (bytes32 pool, KnockoutLiq.KnockoutPivot memory pivot,\n                               bool isBid, int24 tick, uint64 feeGlobal)\n        private returns (uint64 feeRange) {\n        // Unchecked because min/max tick are well within uint16 of int24 bounds\n        unchecked {            \n        int24 offset = int24(uint24(pivot.rangeTicks_));\n        int24 priceTick = isBid ? tick-1 : tick;\n        int24 lowerTick = isBid ? tick : tick - offset;\n        int24 upperTick = !isBid ? tick : tick + offset;\n        feeRange = removeBookLiq(pool, priceTick, lowerTick, upperTick,\n                                 pivot.lots_, feeGlobal);\n        }\n    }\n\n\n    /* @notice Mints a new knockout liquidity position (or adds liquidity to a pre-\n     *         existing position.\n     *\n     * @param pool The cursor for the pool knockout liquidity is being added to.\n     * @param knockoutBits The current knockout parameter flags in the pool's settings.\n     * @param curveTick The 24-bit tick index of the current curve price in the pool\n     * @param feeGlobal The global cumulative concentrated liquidity fee mileage for\n     *                  the curve at mint time.\n     * @param loc       The position on the curve the knockout liquidity is being added\n     *                  to. (See comments for struct for full explanation of fields)\n     * @param lots    The amount of liquidity lots (in lots of 1024-units of \n     *                sqrt(X*Y) liquidity) being added to the knockout position. \n     *\n     * @return pivotTime  The time tranche of the pivot the liquidity was added to.\n     * @return newPivot If true indicates that this is the first active liquidity at the\n     *                  pivot. */\n    function addKnockoutLiq (bytes32 pool, uint8 knockoutBits,\n                             int24 curveTick, uint64 feeGlobal,\n                             KnockoutLiq.KnockoutPosLoc memory loc, uint96 lots)\n        internal returns (uint32 pivotTime, bool newPivot) {\n        (pivotTime, newPivot) = injectPivot(pool, knockoutBits, loc, lots, curveTick);\n        uint64 feeRange = addBookLiq(pool, curveTick, loc.lowerTick_,\n                                     loc.upperTick_, lots, feeGlobal);\n        if (newPivot) {\n            markPivot(pool, loc);\n        }\n        insertPosition(pool, loc, lots, feeRange, pivotTime);\n    }\n\n    /* @notice Burns pre-exisitng knockout liquidity, but only if the liqudity is still\n     *         alive. (Knocked out positions should use claimKnockout() instead).\n     *\n     * @param pool The cursor for the pool knockout liquidity is being added to.\n     * @param curveTick The 24-bit tick index of the current curve price in the pool\n     * @param feeGlobal The global cumulative concentrated liquidity fee mileage for\n     *                  the curve at mint time.\n     * @param loc       The position on the curve the knockout liquidity is being claimed\n     *                  from. (See comments for struct for full explanation of fields)\n     *                  to. (See comments for struct for full explanation of fields)\n     * @param lots    The amount of liquidity lots (in lots of 1024-units of \n     *                sqrt(X*Y) liquidity) being added to the knockout position. \n     *\n     * @return killsPivot If true indicates that removing this liquidity means the pivot\n     *                    has no remaining liquidity.\n     * @return pivotTime The tranche time of the underlying pivot the liquidity was \n     *                   removed from.\n     * @return rewards  The concentrated liquidity rewards accumulated to the \n     *                  position. */\n    function rmKnockoutLiq (bytes32 pool, int24 curveTick, uint64 feeGlobal,\n                            KnockoutLiq.KnockoutPosLoc memory loc, uint96 lots)\n        internal returns (bool killsPivot, uint32 pivotTime, uint64 rewards) {\n        (pivotTime, killsPivot) = recallPivot(pool, loc, lots);\n        if (killsPivot) { unmarkPivot(pool, loc); }\n\n        uint64 feeRange = removeBookLiq(pool, curveTick, loc.lowerTick_,\n                                        loc.upperTick_, lots, feeGlobal);\n        rewards = removePosition(pool, loc, lots, feeRange, pivotTime);\n    }\n\n    /* @notice Marks the tick level as containing a knockout pivot.\n     * @dev This is done by switching on the least significant bit in the bump point.\n     *      Based on the spec of liquidity lots (see LiquidityMath.sol), this least \n     *      significant bit should *not* be treated as actual liquidity, but rather just\n     *      an unrelated flag indicating that the level has a corresponding active \n     *      knockout pivot. */\n    function markPivot (bytes32 pool, KnockoutLiq.KnockoutPosLoc memory loc) private {\n        if (loc.isBid_) {\n            BookLevel storage lvl = fetchLevel(pool, loc.lowerTick_);\n            lvl.bidLots_ = lvl.bidLots_ | uint96(0x1);\n        } else {\n            BookLevel storage lvl = fetchLevel(pool, loc.upperTick_);\n            lvl.askLots_ = lvl.askLots_ | uint96(0x1);\n        }\n    }\n\n    /* @notice Removes the mark on the book level related to the presence of knockout \n     *         liquidity. */\n    function unmarkPivot (bytes32 pool, KnockoutLiq.KnockoutPosLoc memory loc) private {\n        if (loc.isBid_) {\n            unmarkPivot(pool, true, loc.lowerTick_);\n        } else {\n            unmarkPivot(pool, false, loc.upperTick_);\n        }\n    }\n\n    /* @notice Removes the mark on the book level related to the presence of knockout \n     *         liquidity. */\n    function unmarkPivot (bytes32 pool, bool isBid, int24 tick) private {\n        BookLevel storage lvl = fetchLevel(pool, tick);\n        if (isBid) {\n            lvl.bidLots_ = lvl.bidLots_ & ~uint96(0x1);\n        } else {\n            lvl.askLots_ = lvl.askLots_ & ~uint96(0x1);\n        }        \n    }\n\n    /* @notice Claims the collateral and rewards for a position that has been fully \n     *         knocked out. (I.e. is no longer active because knockout tick was crossed)\n     * \n     * @param pool The cursor for the pool knockout liquidity is being added to.\n     * @param loc       The position on the curve the knockout liquidity is being claimed\n     *                  from. (See comments for struct for full explanation of fields)\n     * @param merkleRoot The root of the Merkle proof to recover the accumulted fees.\n     * @param merkleProof The user-supplied proof for the accumulated fees earned by\n     *                    the knockout pivot. (Transaction will revert if proof is bad)\n     *\n     * @return lots    The liquidity (in 1024-unit lots) claimable by the underlying \n     *                 position. Note that this liquidity should be converted to \n     *                 collateral at the knockout price *not* the current curve price).\n     * @return rewards The in-range concentrated liquidity rewards earned by the position.\n     */\n    function claimPostKnockout (bytes32 pool, KnockoutLiq.KnockoutPosLoc memory loc,\n                                uint160 merkleRoot, uint256[] memory merkleProof)\n        internal returns (uint96 lots, uint64 rewards) {\n        (uint32 pivotTime, uint64 feeSnap) =\n            proveKnockout(pool, loc, merkleRoot, merkleProof);\n        (lots, rewards) = claimPosition(pool, loc, feeSnap, pivotTime);\n    }\n\n    /* @notice Like claimKnockout(), but avoids the need for Merkle proof altogether.\n     *         This means the underlying collateral is recoverable, but user renounces\n     *         all claims to the accumulated rewards.\n     *\n     * @dev    This might be used when the calldata cost of the Merkle proof exceeds\n     *         the value of the accumulated rewards.\n     *\n     * @param pool The cursor for the pool knockout liquidity is being added to.\n     * @param loc       The position on the curve the knockout liquidity is being claimed\n     *                  from. (See comments for struct for full explanation of fields)\n     * @param pivotTime The pivot trache the position was minted at. User-supplied value\n     *                  must match the position's stored value. Used to verify that the\n     *                  tranche is no longer active (otherwise use burnKnockout())\n     * @return lots    The liquidity (in 1024-unit lots) claimable by the underlying \n     *                 position. Note that this liquidity should be converted to \n     *                 collateral at the knockout price *not* the current curve price).*/\n    function recoverPostKnockout (bytes32 pool, KnockoutLiq.KnockoutPosLoc memory loc,\n                                  uint32 pivotTime)\n        internal returns (uint96 lots) {\n        confirmPivotDead(pool, loc, pivotTime);\n        (lots, ) = claimPosition(pool, loc, 0, pivotTime);\n    }\n    \n\n    /* @notice Inserts the tracking data for the individual position being minted.\n     * @param pool The hash of the pool the liquidity applies to.\n     * @param loc The context/location data of the knockout liquidity position.\n     * @param lots The amount of liquidity minted to the position.\n     * @param feeRange The cumulative fee mileage for the concentrated liquidity range\n     *                 at current mint time.\n     * @param pivotTime The time corresponding to the underlying pivot creation. */\n    function insertPosition (bytes32 pool, KnockoutLiq.KnockoutPosLoc memory loc,\n                             uint96 lots, uint64 feeRange, uint32 pivotTime) private {\n        bytes32 posKey = loc.encodePosKey(pool, lockHolder_, pivotTime);\n        KnockoutLiq.KnockoutPos storage pos = knockoutPos_[posKey];\n\n        uint64 mileage = feeRange.blendMileage(lots, pos.feeMileage_, pos.lots_);\n        \n        pos.lots_ += lots;\n        pos.feeMileage_ = mileage;\n        pos.timestamp_ = SafeCast.timeUint32();\n    }\n\n    /* @notice Removes the tracking data for an individual knockout liquidity position.\n     * @dev Should only be called when the underlying knockout pivot *is still active*\n     * @param pool The hash of the pool the liquidity applies to.\n     * @param loc The context/location data of the knockout liquidity position.\n     * @param lots The amount of liquidity burned from the position.\n     * @param feeRange The cumulative fee mileage for the concentrated liquidity range\n     *                 at current mint time.\n     * @param pivotTime The time corresponding to the underlying pivot creation.\n     * @return feeRewards The accumulated fee rewards rate on the position. */\n    function removePosition (bytes32 pool, KnockoutLiq.KnockoutPosLoc memory loc,\n                             uint96 lots, uint64 feeRange, uint32 pivotTime)\n        private returns (uint64 feeRewards) {\n        bytes32 posKey = loc.encodePosKey(pool, lockHolder_, pivotTime);\n        KnockoutLiq.KnockoutPos storage pos = knockoutPos_[posKey];\n\n        feeRewards = feeRange.deltaRewardsRate(pos.feeMileage_);\n        assertJitSafe(pos.timestamp_, pool);\n        require(lots <= pos.lots_, \"KB\");\n        \n        if (lots == pos.lots_) {\n            // Get SSTORE refund on full burn\n            pos.lots_ = 0;\n            pos.feeMileage_ = 0;\n            pos.timestamp_ = 0;\n        } else {\n            pos.lots_ -= lots;\n        }\n    }\n\n    /* @notice Removes the tracking data for an individual knockout liquidity position \n     *         that's being claimed post knockout. \n     * @dev Should only be called *after* the underlying pivot is knocked out.\n     * @param pool The hash of the pool the liquidity applies to.\n     * @param loc The context/location data of the knockout liquidity position.\n     * @param feeRange The cumulative fee mileage for the concentrated liquidity range\n     *                 at current mint time.\n     * @param pivotTime The time corresponding to the underlying pivot creation.\n     * @return lots The amount of liquidity lots in the underlying position. \n     * @return feeRewards The accumulated fee rewards rate on the position. */\n    function claimPosition (bytes32 pool, KnockoutLiq.KnockoutPosLoc memory loc,\n                            uint64 feeRange, uint32 pivotTime)\n        private returns (uint96 lots, uint64 feeRewards) {\n        bytes32 posKey = loc.encodePosKey(pool, lockHolder_, pivotTime);\n        KnockoutLiq.KnockoutPos storage pos = knockoutPos_[posKey];\n\n        lots = pos.lots_;\n        if (feeRange > 0) {\n            feeRewards = feeRange - pos.feeMileage_;\n        }\n        \n        // Get SSTORE refund on full burn\n        pos.lots_ = 0;\n        pos.feeMileage_ = 0;\n        pos.timestamp_ = 0;\n    }\n\n    /* @notice Creates a new pivot or updates a previous pivot for newly minted knockout\n     *         liquidity.\n     * @param pool The pool the knockout liquidity applies to.\n     * @param loc The context/location of the newly minted knockout liquidity.\n     * @param liq The amount of liquidity being minted to the position.\n     * @param curveTick The tick index of the current price in the curve.\n     * @return bookLiq The amount of liquidity that must be contributed to the range in\n     *                 the book. This amount could possibly be different than liq, so \n     *                 it's very important that this value is used to adjust the curve \n     *                 and collect collateral.\n     * @return pivotTime The time tranche of the pivot the liquidity is added to. Either\n     *                   the current time if liquidity creates a new pivot, or the \n     *                   timestamp of when the previous tranche was created. */\n    function injectPivot (bytes32 pool, uint8 knockoutBits,\n                          KnockoutLiq.KnockoutPosLoc memory loc,\n                          uint96 lots, int24 curveTick) private returns\n        (uint32 pivotTime, bool newPivot) {\n        bytes32 lvlKey = loc.encodePivotKey(pool);\n        KnockoutLiq.KnockoutPivot storage pivot = knockoutPivots_[lvlKey];\n        newPivot = (pivot.lots_ == 0);\n\n        // If mint represents the first position in a new pivot perorm book keeping\n        // related to setting the time tranch, warming up the Merkle slot, and verifying\n        // that the pivot position is valid relative to the pool's current parameters.\n        if (newPivot) {            \n            pivotTime = SafeCast.timeUint32();\n            freshenMerkle(knockoutMerkles_[lvlKey]);\n            loc.assertValidPos(curveTick, knockoutBits);\n\n            // Should optimize to a single SSTORE call.\n            pivot.lots_ = lots;\n            pivot.pivotTime_ = pivotTime;\n            pivot.rangeTicks_ = loc.tickRange();\n            \n        } else {\n            pivot.lots_ += lots;\n            pivotTime = pivot.pivotTime_;\n            require(pivot.rangeTicks_ == loc.tickRange(), \"KR\");\n        }\n    }\n\n    /* @notice Called to withdraw liquidity from an open knockout pivot. (If pivot was\n     *         already knocked out, do not use this function.\n     * @param pool The pool the knockout liquidity applies to.\n     * @param loc The context/location of the newly minted knockout liquidity.\n     * @param liq The amount of liquidity being minted to the position.\n     * @return bookLiq The amount of liquidity that shoudl be removed from the book. \n     *                 This amount could possibly be different than liq, so it's very \n     *                 important that this value is used to adjust the AMM curve. \n     * @return pivotTime The tranche timestamp of the current knockout pivot. */\n    function recallPivot (bytes32 pool, KnockoutLiq.KnockoutPosLoc memory loc,\n                          uint96 lots) private returns\n        (uint32 pivotTime, bool killsPivot) {\n        bytes32 lvlKey = KnockoutLiq.encodePivotKey(pool, loc.isBid_,\n                                                    loc.knockoutTick());\n        KnockoutLiq.KnockoutPivot storage pivot = knockoutPivots_[lvlKey];\n        pivotTime = pivot.pivotTime_;\n        require(lots <= pivot.lots_, \"KB\");\n        killsPivot = (lots == pivot.lots_);\n\n        if (killsPivot) {\n            // Get the SSTORE refund when completely burning the level\n            pivot.lots_ = 0;\n            pivot.pivotTime_ = 0;\n            pivot.rangeTicks_ = 0;\n\n        } else {\n            pivot.lots_ -= lots;\n        }\n    }\n\n    /* @notice Call on the corresponding Merkle root when creating a new pivot at a \n     *         tick/time tranche. */\n    function freshenMerkle (KnockoutLiq.KnockoutMerkle storage merkle) private {\n        // Knockout tranches are uniquely identified by block times. There is a\n        // rare corner case where multiple knockouts are created, crossed and\n        // created again at the same tick all within the same block/time.\n        require(merkle.pivotTime_ != SafeCast.timeUint32(), \"KT\");\n            \n        // Warm up the slot so that the SSTORE fresh is paid by the LP, not\n        // the swapper. This means all Merkle histories begin with a root of 1\n        if(merkle.merkleRoot_ == 0) {\n            merkle.merkleRoot_ = 1;\n        }\n    }\n\n    /* @notice Asserts that a given pivot tranche being claimed as knocked out, was\n     *         in fact knocked out. Used when the user doesn't have or doesn't want to\n     *         present a Merkle proof.\n     *\n     * @dev    Relies on two guarantees. 1) base Merkle time is always increasing, \n     *         because pivots are created, and therefore knocked out, in monotonically\n     *         increasing time order. 2) Tranches will never be created at the same time-\n     *         stamp as the most recent Merkle commitment. Therefore a pivot tranche\n     *         has been knocked out if and only if the most recent Merkle commitment has\n     *         an equal of greater timestamp. */\n    function confirmPivotDead (bytes32 pool, KnockoutLiq.KnockoutPosLoc memory loc,\n                               uint32 pivotTime)\n        private view {\n        bytes32 lvlKey = KnockoutLiq.encodePivotKey(pool, loc.isBid_,\n                                                    loc.knockoutTick());\n        KnockoutLiq.KnockoutMerkle storage merkle = knockoutMerkles_[lvlKey];\n        require(merkle.pivotTime_ >= pivotTime, \"KA\");\n    }\n\n    /* @notice Verifies the user-supplied Merkle proof. (See proveHistory() in \n     *         KnockoutLiq library). If proof is wrong, transaction will revert.\n     *\n     * @return pivotTime The pivot time from the verified proof. Caller is responsible\n     *                   for making sure this matches the pivotTime in the position\n     *                   being claimed.\n     * @return feeSnap The in-range fee mileage at Merkle commitment time, i.e. when the\n     *                 pivot was knocked out. */\n    function proveKnockout (bytes32 pool, KnockoutLiq.KnockoutPosLoc memory loc,\n                            uint160 root, uint256[] memory proof)\n        private view returns (uint32 pivotTime, uint64 feeSnap) {\n        bytes32 lvlKey = KnockoutLiq.encodePivotKey(pool, loc.isBid_,\n                                                    loc.knockoutTick());\n        KnockoutLiq.KnockoutMerkle storage merkle = knockoutMerkles_[lvlKey];\n        (pivotTime, feeSnap) = merkle.proveHistory(root, proof);\n    }\n}\n\n"
    },
    "contracts/mixins/LevelBook.sol": {
      "content": "// SPDX-License-Identifier: GPL-3                                                          \npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport '../libraries/LiquidityMath.sol';\nimport '../libraries/TickMath.sol';\nimport './TickCensus.sol';\nimport './StorageLayout.sol';\nimport 'hardhat/console.sol';\n\n/* @title Level Book Mixin\n * @notice Mixin contract that tracks the aggregate liquidity bumps and in-range reward\n *         accumulators on a per-tick basis. */\ncontract LevelBook is TickCensus {\n    using SafeCast for uint128;\n    using LiquidityMath for uint128;\n    using LiquidityMath for uint96;\n\n    /* Book level structure exists one-to-one on a tick basis (though could possibly be\n     * zero-valued). For each tick we have to track three values:\n     *    bidLots_ - The change to concentrated liquidity that's added to the AMM curve when\n     *               price moves into the tick from below, and removed when price moves\n     *               into the tick from above. Denominated in lot-units which are 1024 multiples\n     *               of liquidity units.\n     *    askLots_ - The change to concentrated liquidity that's added to the AMM curve when\n     *               price moves into the tick from above, and removed when price moves\n     *               into the tick from below. Denominated in lot-units which are 1024 multiples\n     *               of liquidity units.\n     *    feeOdometer_ - The liquidity fee rewards accumulator that's checkpointed \n     *       whenever the price crosses the tick boundary. Used to calculate the \n     *       cumulative fee rewards on any arbitrary lower-upper tick range. This is\n     *       generically represented as a per-liquidity unit 128-bit fixed point \n     *       cumulative growth rate. */\n\n    /* @notice Called when the curve price moves through the tick boundary. Performs\n     *         the necessary accumulator checkpointing and deriving the liquidity bump.\n     *\n     * @dev    Note that this function call is *not* idempotent. It's the callers \n     *         responsibility to only call once per tick cross direction. Otherwise \n     *         behavior is undefined. This is safe to call with non-initialized zero\n     *         ticks but should generally be avoided for gas efficiency reasons.\n     *\n     * @param poolIdx - The hash index of the pool being traded on.\n     * @param tick - The 24-bit tick index being crossed.\n     * @param isBuy - If true indicates that price is crossing the tick boundary from \n     *                 below. If false, means tick is being crossed from above. \n     * @param feeGlobal - The up-to-date global fee reward accumulator value. Used to\n     *                    checkpoint the tick rewards for calculating accumulated rewards\n     *                    in a range. Represented as 128-bit fixed point cumulative \n     *                    growth rate per unit of liquidity.\n     *\n     * @return liqDelta - The net change in concentrated liquidity that should be applied\n     *                    to the AMM curve following this level cross.\n     * @return knockoutFlag - Indicates that the liquidity of the cross level has a \n     *                        knockout flag toggled. Upstream caller should handle \n     *                        appropriately */\n    function crossLevel (bytes32 poolIdx, int24 tick, bool isBuy, uint64 feeGlobal)\n        internal returns (int128 liqDelta, bool knockoutFlag) {\n        \n        BookLevel storage lvl = fetchLevel(poolIdx, tick);\n        int128 crossDelta = LiquidityMath.netLotsOnLiquidity\n            (lvl.bidLots_, lvl.askLots_);\n        \n        liqDelta = isBuy ? crossDelta : -crossDelta;\n\n        if (feeGlobal != lvl.feeOdometer_) {\n            lvl.feeOdometer_ = feeGlobal - lvl.feeOdometer_;\n        }                \n\n        knockoutFlag = isBuy ?\n            lvl.askLots_.hasKnockoutLiq() :\n            lvl.bidLots_.hasKnockoutLiq();\n    }\n\n    /* @notice Retrieves the level book state associated with the tick. */\n    function levelState (bytes32 poolIdx, int24 tick) internal view returns\n        (BookLevel memory) {\n        return levels_[keccak256(abi.encodePacked(poolIdx, tick))];\n    }\n\n    /* @notice Retrieves a storage pointer to the level associated with the tick. */\n    function fetchLevel (bytes32 poolIdx, int24 tick) internal view returns\n        (BookLevel storage) {\n        return levels_[keccak256(abi.encodePacked(poolIdx, tick))];\n    }\n\n    /* @notice Deletes the level at the tick. */\n    function deleteLevel (bytes32 poolIdx, int24 tick) private {\n        delete levels_[keccak256(abi.encodePacked(poolIdx, tick))];\n    }\n\n    /* @notice Adds the liquidity associated with a new range order into the associated\n     *         book levels, initializing the level structs if necessary.\n     * \n     * @param poolIdx - The index of the pool the liquidity is being added to.\n     * @param midTick - The tick index associated with the current price of the AMM curve\n     * @param bidTick - The tick index for the lower bound of the range order.\n     * @param askTick - The tick index for the upper bound of the range order.\n     * @param lots - The amount of liquidity (in 1024 unit lots) being added by the range order.\n     * @param feeGlobal - The up-to-date global fee rewards growth accumulator. \n     *    Represented as 128-bit fixed point growth rate.\n     *\n     * @return feeOdometer - Returns the current fee reward accumulator value for the\n     *    range specified by the order. This is necessary, so we consumers of this mixin\n     *    can subtract the rewards accumulated before the order was added. */\n    function addBookLiq (bytes32 poolIdx, int24 midTick, int24 bidTick, int24 askTick,\n                         uint96 lots, uint64 feeGlobal)\n        internal returns (uint64 feeOdometer) {\n\n        // Make sure to init before add, because init logic relies on pre-add liquidity\n        initLevel(poolIdx, midTick, bidTick, feeGlobal);\n        initLevel(poolIdx, midTick, askTick, feeGlobal);\n\n        addBid(poolIdx, bidTick, lots);\n        addAsk(poolIdx, askTick, lots);\n        feeOdometer = clockFeeOdometer(poolIdx, midTick, bidTick, askTick, feeGlobal);\n    }\n\n    /* @dev Near identical to addBookLiq() above but uses higher precision 72-bit \n     *      range positions and fee odometer values. */\n    function addBookLiq72 (bytes32 poolIdx, int24 midTick, int24 bidTick, int24 askTick,\n                           uint96 lots, uint64 feeGlobal)\n        internal returns (uint72 feeOdometer) {\n\n        // Make sure to init before add, because init logic relies on pre-add liquidity\n        initLevel(poolIdx, midTick, bidTick, feeGlobal);\n        initLevel(poolIdx, midTick, askTick, feeGlobal);\n\n        addBid(poolIdx, bidTick, lots);\n        addAsk(poolIdx, askTick, lots);\n        feeOdometer = clockFeeOdometer72(poolIdx, midTick, bidTick, askTick, feeGlobal);\n    }\n\n\n    /* @notice Call when removing liquidity associated with a specific range order.\n     *         Decrements the associated tick levels as necessary.\n     *\n     * @param poolIdx - The index of the pool the liquidity is being removed from.\n     * @param midTick - The tick index associated with the current price of the AMM curve\n     * @param bidTick - The tick index for the lower bound of the range order.\n     * @param askTick - The tick index for the upper bound of the range order.\n     * @param liq - The amount of liquidity being added by the range order.\n     * @param feeGlobal - The up-to-date global fee rewards growth accumulator. \n     *    Represented as 128-bit fixed point growth rate.\n     *\n     * @return feeOdometer - Returns the current fee reward accumulator value for the\n     *    range specified by the order. Note that this returns the accumulated rewards\n     *    from the range history, including *before* the order was added. It's the \n     *    downstream user's responsibility to adjust this value with the odometer clock\n     *    from addBookLiq to correctly calculate the rewards accumulated over the \n     *    lifetime of the order. */     \n    function removeBookLiq (bytes32 poolIdx, int24 midTick, int24 bidTick, int24 askTick,\n                            uint96 lots, uint64 feeGlobal)\n        internal returns (uint64 feeOdometer) {\n        bool deleteBid = removeBid(poolIdx, bidTick, lots);\n        bool deleteAsk = removeAsk(poolIdx, askTick, lots);\n        feeOdometer = clockFeeOdometer(poolIdx, midTick, bidTick, askTick, feeGlobal);\n\n        if (deleteBid) { deleteLevel(poolIdx, bidTick); }\n        if (deleteAsk) { deleteLevel(poolIdx, askTick); }\n    }\n\n    /* @dev Near identical to removeBookLiq() above but uses higher precision 72-bit \n     *      range positions and fee odometer values. */\n    function removeBookLiq72 (bytes32 poolIdx, int24 midTick, int24 bidTick, int24 askTick,\n                              uint96 lots, uint64 feeGlobal)\n        internal returns (uint72 feeOdometer) {\n        bool deleteBid = removeBid(poolIdx, bidTick, lots);\n        bool deleteAsk = removeAsk(poolIdx, askTick, lots);\n        feeOdometer = clockFeeOdometer72(poolIdx, midTick, bidTick, askTick, feeGlobal);\n\n        if (deleteBid) { deleteLevel(poolIdx, bidTick); }\n        if (deleteAsk) { deleteLevel(poolIdx, askTick); }\n    }\n\n    /* @notice Initializes a new level, including marking the tick as active in the \n     *         bitmap, if the level doesn't previously exist. */\n    function initLevel (bytes32 poolIdx, int24 midTick,\n                        int24 tick, uint64 feeGlobal) private {\n        BookLevel storage lvl = fetchLevel(poolIdx, tick);\n        if (lvl.bidLots_ == 0 && lvl.askLots_ == 0) {\n            if (tick >= midTick) {\n                lvl.feeOdometer_ = feeGlobal;\n            }\n            bookmarkTick(poolIdx, tick);\n        }\n    }\n\n    /* @notice Increments bid liquidity on a previously existing level. */\n    function addBid (bytes32 poolIdx, int24 tick, uint96 incrLots) private {\n        BookLevel storage lvl = fetchLevel(poolIdx, tick);\n        uint96 prevLiq = lvl.bidLots_;\n        uint96 newLiq = prevLiq.addLots(incrLots);\n        lvl.bidLots_ = newLiq;\n    }\n\n    /* @notice Increments ask liquidity on a previously existing level. */    \n    function addAsk (bytes32 poolIdx, int24 tick, uint96 incrLots) private {\n        BookLevel storage lvl = fetchLevel(poolIdx, tick);\n        uint96 prevLiq = lvl.askLots_;\n        uint96 newLiq = prevLiq.addLots(incrLots);\n        lvl.askLots_ = newLiq;\n    }\n\n    /* @notice Decrements bid liquidity on a level, and also removes the level from\n     *          the tick bitmap if necessary. */\n    function removeBid (bytes32 poolIdx, int24 tick,\n                        uint96 subLots) private returns (bool) {\n        BookLevel storage lvl = fetchLevel(poolIdx, tick);\n        uint96 prevLiq = lvl.bidLots_;\n        uint96 newLiq = prevLiq.minusLots(subLots);\n\n        // A level should only be marked inactive in the tick bitmap if *both* bid and\n        // ask liquidity are zero.\n        lvl.bidLots_ = newLiq;\n        if (newLiq == 0 && lvl.askLots_ == 0) {\n            forgetTick(poolIdx, tick);\n            return true;\n        }\n        return false;\n    }    \n\n    /* @notice Decrements ask liquidity on a level, and also removes the level from\n     *          the tick bitmap if necessary. */    \n    function removeAsk (bytes32 poolIdx, int24 tick,\n                        uint96 subLots) private returns (bool) {\n        BookLevel storage lvl = fetchLevel(poolIdx, tick);\n        uint96 prevLiq = lvl.askLots_;\n        uint96 newLiq = prevLiq.minusLots(subLots);\n        \n        lvl.askLots_ = newLiq;\n        if (newLiq == 0 && lvl.bidLots_ == 0) {\n            forgetTick(poolIdx, tick);\n            return true;\n        }\n        return false;\n    }    \n\n    /* @notice Calculates the current accumulated fee rewards in a given concentrated\n     *         liquidity tick range. The difference between this value at two different\n     *         times is guaranteed to reflect the accumulated rewards in the tick range\n     *         between those two times.\n     *\n     *         For more explanation on how the fee rewards accumulated is calculated for\n     *         a given range order, reference the documenation at [docs/FeeOdometer.md]\n     *         in the project repository.\n     *\n     * @dev This returned result only has meaning when compared against the result\n     *      from the same method call on the same range at a different time. Any\n     *      given range could have an arbitrary offset relative to the pool's actual\n     *      cumulative rewards.\n     *\n     * @param poolIdx The hash key specifying the pool being operated on.\n     * @param currentTick The price tick of the curve's current price\n     * @param lowerTick The prick tick of the lower boundary of the range order\n     * @param upperTick The prick tick of the upper boundary of the range order\n     * @param feeGlobal The cumulative rewards accumulated to a single unit of \n     *                  concentrated liquidity that was active since pool inception.\n     *\n     * @return The cumulative growth rate to a single unit of concentrated liquidity\n     *         within the range. (Adjusted for an arbitrary offset that stays consistent\n     *         over time. Only use this number to compare growth in the range over two\n     *         points in time) */\n    function clockFeeOdometer (bytes32 poolIdx, int24 currentTick,\n                               int24 lowerTick, int24 upperTick, uint64 feeGlobal)\n        internal view returns (uint64) {\n        uint64 feeLower = pivotFeeBelow(poolIdx, lowerTick, currentTick, feeGlobal);\n        uint64 feeUpper = pivotFeeBelow(poolIdx, upperTick, currentTick, feeGlobal);\n        \n        // This is unchecked because we often rely on circular overflow arithmetic\n        // when ticks are initialized at different times. Remember the output of this\n        // function is only used to compare across time.\n        unchecked {\n            return feeUpper - feeLower;\n        }\n    }\n\n    /* @notice Snapshots a value cumulative fee accumulation in a tick range to be\n     *         used when calculating the growth of a position over time. See description\n     *         in clockFeeOdomter() for more details.\n     *\n     * @dev  Unlike clockFeeOdomter() the returned snapshot is a 72-bit representation.\n     *       Each snapshot adds a uint64 max offset to avoid the possibility of underflow. \n     *       Because the offset is included on every calculation, it will always cancel out\n     *       in the rewards delta calculation. */\n    function clockFeeOdometer72 (bytes32 poolIdx, int24 currentTick,\n                                 int24 lowerTick, int24 upperTick, uint64 feeGlobal)\n        internal view returns (uint72) {\n        uint72 feeLower = pivotFeeBelow(poolIdx, lowerTick, currentTick, feeGlobal);\n        uint72 feeUpper = pivotFeeBelow(poolIdx, upperTick, currentTick, feeGlobal);\n        \n        // Set to be large enough, so the delta between the uint64 values from pivotFeeBelow()\n        // will never underflow the snapshot.\n        uint72 fixedOffset = type(uint64).max;\n        return (fixedOffset + feeUpper) - feeLower;\n    }\n\n    /* @dev Internally we checkpoint the last global accumulator value from the last\n     *      time the level was crossed. Because fees can only accumulate when price\n     *      is in range, the checkpoint represents the global fees that accumulated\n     *      on the outside of the tick level. (Though this may be faked for fees that\n     *      that accumulated prior to level initialization. It doesn't matter, because\n     *      all we use this value for is calculating the delta of fee accumulation \n     *      between two different post-initialization points in time.)\n     *\n     *      For more explanation on how the per-tick fee odometer related to the \n     *      cumulative fees in a give range, reference the documenation at \n     *      [docs/FeeOdometer.md] in the project repository. */\n    function pivotFeeBelow (bytes32 poolIdx, int24 lvlTick,\n                            int24 currentTick, uint64 feeGlobal)\n        private view returns (uint64) {\n        BookLevel storage lvl = fetchLevel(poolIdx, lvlTick);\n        return lvlTick <= currentTick ?\n            lvl.feeOdometer_ :\n            feeGlobal - lvl.feeOdometer_;            \n    }\n}\n\n"
    },
    "contracts/mixins/LiquidityCurve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport '../libraries/TickMath.sol';\nimport '../libraries/FixedPoint.sol';\nimport '../libraries/LiquidityMath.sol';\nimport '../libraries/SafeCast.sol';\nimport '../libraries/PoolSpecs.sol';\nimport '../libraries/CurveMath.sol';\nimport '../libraries/CurveCache.sol';\nimport './StorageLayout.sol';\n\n/* @title Liquidity Curve Mixin\n * @notice Tracks the state of the locally stable constant product AMM liquid curve\n *         for the pool. Applies any adjustment to the curve as needed, either from\n *         new or removed positions or pre-determined liquidity bumps that occur\n *         when crossing tick boundaries. */\ncontract LiquidityCurve is StorageLayout {\n    using SafeCast for uint128;\n    using SafeCast for uint192;\n    using SafeCast for uint144;\n    using LiquidityMath for uint128;\n    using CurveMath for uint128;\n    using CurveMath for CurveMath.CurveState;\n\n    /* @notice Copies the current state of the curve in EVM storage to a memory clone.\n     * @dev    Use for light-weight gas ergonomics when iterarively operating on the \n     *         curve. But it's the callers responsibility to persist the changes back\n     *         to storage when complete. */\n    function snapCurve (bytes32 poolIdx) view internal returns\n        (CurveMath.CurveState memory curve) {\n        curve = curves_[poolIdx];\n        require(curve.priceRoot_ > 0);\n    }\n\n    /* @notice Snapshots the curve for pool initialization operation.\n     * @dev    This only skips the initialization check from snapCurve() does *not* assert\n     *         that the curve was not previously initialized. That's the caller's \n     *         responsibility */\n    function snapCurveInit (bytes32 poolIdx) view internal returns\n        (CurveMath.CurveState memory) {\n        return curves_[poolIdx];\n    }\n\n    /* @notice Snapshots the curve to memory, but verifies that the price occurs within\n     *         a pre-specified price range. If not, reverts the entire transaction. */\n    function snapCurveInRange (bytes32 poolIdx, uint128 minPrice,\n                               uint128 maxPrice) view internal returns\n        (CurveMath.CurveState memory curve) {\n        curve = snapCurve(poolIdx);\n        require(curve.priceRoot_ >= minPrice && curve.priceRoot_ <= maxPrice, \"RC\");\n    }\n\n    /* @notice Writes a CurveState modified in memory back into persistent storage. \n     *         Use for the working copy from snapCurve when finalized. */\n    function commitCurve (bytes32 poolIdx, CurveMath.CurveState memory curve)\n        internal {\n        curves_[poolIdx] = curve;\n    }\n    \n    /* @notice Called whenever a user adds a fixed amount of concentrated liquidity\n     *         to the curve. This must be called regardless of whether the liquidity is\n     *         in-range at the current curve price or not.\n     * @dev After being called this will alter the curve to reflect the new liquidity, \n     *      but it's the callers responsibility to make sure that the required \n     *      collateral is actually collected.\n     *\n     * @param curve The liquidity curve object that range liquidity will be added to.\n     * @param liquidity The amount of liquidity being added. Represented in the form of\n     *                  sqrt(X*Y) where X,Y are the virtual reserves of the tokens in a\n     *                  constant product AMM. Calculate the same whether in-range or not.\n     * @param lowerTick The tick index corresponding to the bottom of the concentrated \n     *                  liquidity range.\n     * @param upperTick The tick index corresponding to the bottom of the concentrated \n     *                  liquidity range.\n     *\n     * @return base - The amount of base token collateral that must be collected \n     *                following the addition of this liquidity.\n     * @return quote - The amount of quote token collateral that must be collected \n     *                 following the addition of this liquidity. */\n    function liquidityReceivable (CurveMath.CurveState memory curve, uint128 liquidity,\n                                  int24 lowerTick, int24 upperTick)\n        internal pure returns (uint128, uint128) {\n        (uint128 base, uint128 quote, bool inRange) =\n            liquidityFlows(curve.priceRoot_, liquidity, lowerTick, upperTick);\n        bumpConcentrated(curve, liquidity, inRange);\n        return chargeConservative(base, quote, inRange);\n    }\n\n    /* @notice Equivalent to above, but used when adding non-range bound constant \n     *         product ambient liquidity.\n     * @dev Like above, it's the caller's responsibility to collect the necessary \n     *      collateral to add to the pool.\n     *\n     * @param curve The liquidity curve object that ambient liquidity will be added to.\n     * @param seeds The number of ambient seeds being added. Note that this is \n     *              denominated as seeds *not* liquidity. The amount of liquidity\n     *              contributed will be based on the current seed->liquidity conversion\n     *              rate on the curve. (See CurveMath.sol.)\n     * @return  The base and quote token flows from the user required to add this amount\n     *          of liquidity to the curve. */\n    function liquidityReceivable (CurveMath.CurveState memory curve, uint128 seeds) \n        internal pure returns (uint128, uint128) {\n        (uint128 base, uint128 quote) = liquidityFlows(curve, seeds);\n        bumpAmbient(curve, seeds);\n        return chargeConservative(base, quote, true);\n    }\n\n    /* @notice Called when liquidity is being removed from the pool Adjusts the curve\n     *         accordingly and calculates the amount of collateral payable to the user.\n     *         This must be called for all removes regardless of whether the liquidity\n     *         is in range or not.\n     * @dev It's the caller's responsibility to actually return the collateral to the \n     *      user. This method will only calculate what's owed, but won't actually pay it.\n     *\n     * \n     * @param curve The liquidity curve object that concentrated liquidity will be \n     *              removed from.\n     * @param liquidity The amount of liquidity being removed, whether in-range or not.\n     *                  Represented in the form of sqrt(X*Y) where x,Y are the virtual\n     *                  reserves of a constant product AMM.\n     * @param rewardRate The total cumulative earned but unclaimed rewards on the staked\n     *                   liquidity. Used to increment the payout with the rewards, and\n     *                   burn the ambient liquidity tied to the rewards. (See \n     *                   CurveMath.sol for more.) Represented as a 128-bit fixed point\n     *                   cumulative growth rate of ambient seeds per unit of liquidity.\n     * @param lowerTick The tick index corresponding to the bottom of the concentrated \n     *                  liquidity range.\n     * @param upperTick The tick index corresponding to the bottom of the concentrated \n     *                  liquidity range.\n     *\n     * @return base - The amount of base token collateral that can be paid out following\n     *                the removal of the liquidity. Always rounded down to favor \n     *                collateral stability.\n     * @return quote - The amount of base token collateral that can be paid out following\n     *                the removal of the liquidity. Always rounded down to favor \n     *                collateral stability. */\n    function liquidityPayable (CurveMath.CurveState memory curve, uint128 liquidity,\n                               uint64 rewardRate, int24 lowerTick, int24 upperTick)\n        internal pure returns (uint128 base, uint128 quote) {\n        (base, quote) = liquidityPayable(curve, liquidity, lowerTick, upperTick);\n        (base, quote) = stackRewards(base, quote, curve, liquidity, rewardRate);\n   }\n\n    function stackRewards (uint128 base, uint128 quote,\n                           CurveMath.CurveState memory curve,\n                           uint128 liquidity, uint64 rewardRate)\n        internal pure returns (uint128, uint128) {\n        if (rewardRate > 0) {\n            // Round down reward sees on payout, in contrast to rounding them up on\n            // incremental accumulation (see CurveAssimilate.sol). This mathematicaly\n            // guarantees that we never try to burn more tokens than exist on the curve.\n            uint128 rewards = FixedPoint.mulQ48(liquidity, rewardRate).toUint128By144();\n            \n            if (rewards > 0) {\n                (uint128 baseRewards, uint128 quoteRewards) =\n                    liquidityPayable(curve, rewards);\n                base += baseRewards;\n                quote += quoteRewards;\n            }\n        }\n        return (base, quote);\n    }\n\n    /* @notice The same as the above liquidityPayable() but called when accumulated \n     *         rewards are zero. */\n    function liquidityPayable (CurveMath.CurveState memory curve, uint128 liquidity,\n                               int24 lowerTick, int24 upperTick)\n        internal pure returns (uint128 base, uint128 quote) {\n        bool inRange;\n        (base, quote, inRange) = liquidityFlows(curve.priceRoot_, liquidity,\n                                                lowerTick, upperTick);\n        bumpConcentrated(curve, -(liquidity.toInt128Sign()), inRange);\n    }\n\n    /* @notice Same as above liquidityPayable() but used for non-range based ambient\n     *         constant product liquidity.\n     *\n     * @param curve The liquidity curve object that ambient liquidity will be \n     *              removed from.\n     * @param seeds The number of ambient seeds being added. Note that this is \n     *              denominated as seeds *not* liquidity. The amount of liquidity\n     *              contributed will be based on the current seed->liquidity conversion\n     *              rate on the curve. (See CurveMath.sol.) \n     * @return base - The amount of base token collateral that can be paid out following\n     *                the removal of the liquidity. Always rounded down to favor \n     *                collateral stability.\n     * @return quote - The amount of base token collateral that can be paid out following\n     *                the removal of the liquidity. Always rounded down to favor \n     *                collateral stability. */\n    function liquidityPayable (CurveMath.CurveState memory curve, uint128 seeds)\n        internal pure returns (uint128 base, uint128 quote) {\n        (base, quote) = liquidityFlows(curve, seeds);\n        bumpAmbient(curve, -(seeds.toInt128Sign()));\n    }\n\n    function liquidityHeldPayable (CurveMath.CurveState memory curve, uint128 liquidity,\n                                   uint64 rewards, KnockoutLiq.KnockoutPosLoc memory loc)\n        internal pure returns (uint128 base, uint128 quote) {\n        (base, quote) = liquidityHeldPayable(liquidity, loc);\n        (base, quote) = stackRewards(base, quote, curve, liquidity, rewards);\n    }\n\n    function liquidityHeldPayable (uint128 liquidity,\n                                   KnockoutLiq.KnockoutPosLoc memory loc)\n        internal pure returns (uint128 base, uint128 quote) {\n        (uint128 bidPrice, uint128 askPrice) = translateTickRange\n            (loc.lowerTick_, loc.upperTick_);\n        if (loc.isBid_) {\n            quote = liquidity.deltaQuote(bidPrice, askPrice);\n        } else {\n            base = liquidity.deltaBase(bidPrice, askPrice);\n        }\n    }\n\n    /* @notice Directly increments the ambient liquidity on the curve. */\n    function bumpAmbient (CurveMath.CurveState memory curve, uint128 seedDelta)\n        private pure {\n        bumpAmbient(curve, seedDelta.toInt128Sign());\n    }\n\n    /* @notice Directly increments the ambient liquidity on the curve. */\n    function bumpAmbient (CurveMath.CurveState memory curve, int128 seedDelta)\n        private pure {\n        curve.ambientSeeds_ = curve.ambientSeeds_.addDelta(seedDelta);\n    }\n\n    /* @notice Directly increments the concentrated liquidity on the curve, depending\n     *         on whether it's in range. */\n    function bumpConcentrated (CurveMath.CurveState memory curve,\n                               uint128 liqDelta, bool inRange) private pure {\n        bumpConcentrated(curve, liqDelta.toInt128Sign(), inRange);\n    }\n\n    /* @notice Directly increments the concentrated liquidity on the curve, depending\n     *         on whether it's in range. */    \n    function bumpConcentrated (CurveMath.CurveState memory curve,\n                               int128 liqDelta, bool inRange) private pure {\n        if (inRange) {\n            curve.concLiq_ = curve.concLiq_.addDelta(liqDelta);\n        }\n    }\n    \n\n    /* @notice Calculates the liquidity flows associated with the concentrated liquidity\n     *         from a range order.\n     * @dev Uses fixed-point math that rounds down up to 2 wei from the true real valued\n     *   flows. Safe to pay this flow, but when pool is receiving caller must make sure\n     *   to round up for collateral safety. */\n    function liquidityFlows (uint128 price, uint128 liquidity,\n                             int24 bidTick, int24 askTick)\n        private pure returns (uint128 baseDebit, uint128 quoteDebit, bool inRange) {\n        (uint128 bidPrice, uint128 askPrice) =\n            translateTickRange(bidTick, askTick);\n\n        if (price < bidPrice) {\n            quoteDebit = liquidity.deltaQuote(bidPrice, askPrice);\n        } else if (price >= askPrice) {\n            baseDebit = liquidity.deltaBase(bidPrice, askPrice);\n        } else {\n            quoteDebit = liquidity.deltaQuote(price, askPrice);\n            baseDebit = liquidity.deltaBase(bidPrice, price);\n            inRange = true;\n        }\n    }\n\n    /* @notice Calculates the liquidity flows associated with the concentrated liquidity\n     *         from a range order.    \n     * @dev Uses fixed-point math that rounds down at each division. Because there are\n     *   divisions, max precision loss is under 2 wei. Safe to pay this flow, but when\n     *   when pool is receiving, caller must make sure to round up for collateral \n     *   safety. */\n    function liquidityFlows (CurveMath.CurveState memory curve, uint128 seeds)\n        private pure returns (uint128 baseDebit, uint128 quoteDebit) {\n        uint128 liq = CompoundMath.inflateLiqSeed(seeds, curve.seedDeflator_);\n        baseDebit = FixedPoint.mulQ64(liq, curve.priceRoot_).toUint128By192();\n        quoteDebit = FixedPoint.divQ64(liq, curve.priceRoot_).toUint128By192();\n    }\n\n    /* @notice Called exactly once at the initializing of the pool. Initializes the\n     *         liquidity curve at an arbitrary price.\n     * @dev Throws error if price was already initialized. \n     *\n     * @param curve   The liquidity curve for the pool being initialized.\n     * @param priceRoot - Square root of the price. Represented as Q64.64 fixed point. */\n    function initPrice (CurveMath.CurveState memory curve, uint128 priceRoot)\n        internal pure {\n        int24 tick = TickMath.getTickAtSqrtRatio(priceRoot);\n        require(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK, \"R\");\n        \n        require(curve.priceRoot_ == 0, \"N\");\n        curve.priceRoot_ = priceRoot;\n    }\n\n    /* @notice Converts a price tick index range into a range of prices. */\n    function translateTickRange (int24 lowerTick, int24 upperTick)\n        private pure returns (uint128 bidPrice, uint128 askPrice) {\n        require(upperTick > lowerTick);\n        require(lowerTick >= TickMath.MIN_TICK);\n        require(upperTick <= TickMath.MAX_TICK);\n        bidPrice = TickMath.getSqrtRatioAtTick(lowerTick);\n        askPrice = TickMath.getSqrtRatioAtTick(upperTick);\n    }\n\n    // Need to support at least 2 wei of precision round down when calculating quote\n    // token reserve deltas. (See CurveMath's deltaPriceQuote() function.) 4 gives us a\n    // safe cushion and is economically meaningless.\n    uint8 constant TOKEN_ROUND = 4;\n\n    /* @notice Rounds liquidity flows up in cases where we want to be conservative with\n     *         collateral. */\n    function chargeConservative (uint128 liqBase, uint128 liqQuote, bool inRange)\n        private pure returns (uint128, uint128) {\n        return ((liqBase > 0 || inRange) ? liqBase + TOKEN_ROUND : 0,\n                (liqQuote > 0 || inRange) ? liqQuote + TOKEN_ROUND : 0);\n    }\n}\n"
    },
    "contracts/mixins/MarketSequencer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport '../libraries/Directives.sol';\nimport '../libraries/PoolSpecs.sol';\nimport '../libraries/PriceGrid.sol';\nimport '../libraries/SwapCurve.sol';\nimport '../libraries/CurveMath.sol';\nimport '../libraries/CurveRoll.sol';\nimport '../libraries/CurveCache.sol';\nimport '../libraries/Chaining.sol';\nimport './PositionRegistrar.sol';\nimport './LiquidityCurve.sol';\nimport './LevelBook.sol';\nimport './TradeMatcher.sol';\n\n/* @title Market sequencer.\n * @notice Mixin class that's responsibile for coordinating one or multiple sequetial\n *         trade actions within a single liqudity pool. */\ncontract MarketSequencer is TradeMatcher {\n\n    using SafeCast for int256;\n    using SafeCast for int128;\n    using SafeCast for uint256;\n    using SafeCast for uint128;\n    using TickMath for uint128;\n    using PoolSpecs for PoolSpecs.Pool;\n    using SwapCurve for CurveMath.CurveState;\n    using CurveRoll for CurveMath.CurveState;\n    using CurveMath for CurveMath.CurveState;\n    using CurveCache for CurveCache.Cache;\n    using Directives for Directives.ConcentratedDirective;\n    using PriceGrid for PriceGrid.ImproveSettings;\n    using Chaining for Chaining.PairFlow;\n    using Chaining for Chaining.RollTarget;\n\n    /* @notice Performs a sequence of an arbitrary potential combination of mints, \n     *         burns, and swaps on a single pool. \n     *\n     * @param flow Output accumulator, into which we'll net and and add the token flows \n     *             associated with the trade actions in this call.\n     * @param dir A directive specifying an arbitrary sequences of action.\n     * @param cntx Provides the execution context for the operation, including the pool\n     *             to execute on and it's pre-loaded specs, off-grid price improvement\n     *             settings, and parameters for rolling gap-failled quantities if they\n     *             appear in the directive. */\n    function tradeOverPool (Chaining.PairFlow memory flow,\n                            Directives.PoolDirective memory dir,\n                            Chaining.ExecCntx memory cntx) internal {\n        // To avoid repeatedly loading and storing the curve on each operation, we load\n        // it once into memory...\n        CurveCache.Cache memory curve;\n        curve.curve_ = snapCurve(cntx.pool_.hash_);\n        applyToCurve(flow, dir, curve, cntx);\n        /// ...Then check it back into storage when complete\n        commitCurve(cntx.pool_.hash_, curve.curve_);\n    }\n\n    /* @notice Performs a single swap over the pool.\n     * @param dir The user-specified directive governing the size, direction and limit\n     *            price of the swap to be performed.\n     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.\n     * @return flow The net token flows generated by the swap. */\n    function swapOverPool (Directives.SwapDirective memory dir,\n                           PoolSpecs.PoolCursor memory pool)\n        internal returns (Chaining.PairFlow memory flow) {\n        CurveMath.CurveState memory curve = snapCurve(pool.hash_);\n        sweepSwapLiq(flow, curve, curve.priceRoot_.getTickAtSqrtRatio(), dir, pool);\n        commitCurve(pool.hash_, curve);\n    }\n\n    /* @notice Mints concentrated liquidity in the form of a range order on to the pool.\n     *\n     * @param bidTick The price tick associated with the lower boundary of the range\n     *                order.\n     * @param askTick The price tick associated with the upper boundary of the range\n     *                order.\n     * @param liq The amount of liquidity being minted represented as the equivalent to\n     *            sqrt(X*Y) in a constant product AMM pool.\n     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.\n     * @param minPrice The minimum acceptable curve price to mint liquidity. If curve\n     *                 price falls outside this point, the transaction is reverted.\n     * @param maxPrice The maximum acceptable curve price to mint liquidity. If curve\n     *                 price falls outside this point, the transaction is reverted.\n     * @param lpConduit The address of the ISdexLpConduit that the liquidity will be\n     *                  assigned to (0 for user owned liquidity).\n     *\n     * @return baseFlow The total amount of base-side token collateral that must be\n     *                  committed to the pool as part of the mint. Will always be\n     *                  positive as it's paid to the pool from the user.\n     * @return quoteFlow The total amount of quote-side token collateral that must be\n     *                   committed to the pool as part of the mint. */\n    function mintOverPool (int24 bidTick, int24 askTick, uint128 liq,\n                           PoolSpecs.PoolCursor memory pool,\n                           uint128 minPrice, uint128 maxPrice,\n                           address lpConduit)\n        internal returns (int128 baseFlow, int128 quoteFlow) {\n        CurveMath.CurveState memory curve = snapCurveInRange\n            (pool.hash_, minPrice, maxPrice);\n        (baseFlow, quoteFlow) =\n            mintRange(curve, curve.priceRoot_.getTickAtSqrtRatio(),\n                      bidTick, askTick, liq, pool.hash_, lpConduit);\n        PriceGrid.verifyFit(bidTick, askTick, pool.head_.tickSize_);\n        commitCurve(pool.hash_, curve);\n    }\n\n    /* @notice Burns concentrated liquidity in the form of a range order on to the pool.\n     *\n     * @param bidTick The price tick associated with the lower boundary of the range\n     *                order.\n     * @param askTick The price tick associated with the upper boundary of the range\n     *                order.\n     * @param liq The amount of liquidity to burn represented as the equivalent to\n     *            sqrt(X*Y) in a constant product AMM pool.\n     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.\n     * @param minPrice The minimum acceptable curve price to mint liquidity. If curve\n     *                 price falls outside this point, the transaction is reverted.\n     * @param maxPrice The maximum acceptable curve price to mint liquidity. If curve\n     *                 price falls outside this point, the transaction is reverted.\n     *\n     * @return baseFlow The total amount of base-side token collateral that is returned\n     *                  from the pool as part of the burn. Will always be\n     *                  negative as it's paid from the pool to the user.\n     * @return quoteFlow The total amount of quote-side token collateral that is returned\n     *                   from the pool as part of the burn. */\n    function burnOverPool (int24 bidTick, int24 askTick, uint128 liq,\n                           PoolSpecs.PoolCursor memory pool,\n                           uint128 minPrice, uint128 maxPrice, address lpConduit)\n        internal returns (int128 baseFlow, int128 quoteFlow) {\n        CurveMath.CurveState memory curve = snapCurveInRange\n            (pool.hash_, minPrice, maxPrice);\n        (baseFlow, quoteFlow) =\n            burnRange(curve, curve.priceRoot_.getTickAtSqrtRatio(),\n                      bidTick, askTick, liq, pool.hash_, lpConduit);\n        commitCurve(pool.hash_, curve);\n    }\n\n    /* @notice Harvests rewards from a concentrated liquidity position.\n     *\n     * @param bidTick The price tick associated with the lower boundary of the range\n     *                order.\n     * @param askTick The price tick associated with the upper boundary of the range\n     *                order.\n     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.\n     * @param minPrice The minimum acceptable curve price to mint liquidity. If curve\n     *                 price falls outside this point, the transaction is reverted.\n     * @param maxPrice The maximum acceptable curve price to mint liquidity. If curve\n     *                 price falls outside this point, the transaction is reverted.\n     *\n     * @return baseFlow The total amount of base-side token collateral that is returned\n     *                  from the pool as part of the burn. Will always be\n     *                  negative as it's paid from the pool to the user.\n     * @return quoteFlow The total amount of quote-side token collateral that is returned\n     *                   from the pool as part of the burn. */\n    function harvestOverPool (int24 bidTick, int24 askTick,\n                              PoolSpecs.PoolCursor memory pool,\n                              uint128 minPrice, uint128 maxPrice, address lpConduit)\n        internal returns (int128 baseFlow, int128 quoteFlow) {\n        CurveMath.CurveState memory curve = snapCurveInRange\n            (pool.hash_, minPrice, maxPrice);\n        (baseFlow, quoteFlow) =\n            harvestRange(curve, curve.priceRoot_.getTickAtSqrtRatio(),\n                         bidTick, askTick, pool.hash_, lpConduit);\n        commitCurve(pool.hash_, curve);\n    }\n\n    /* @notice Mints ambient liquidity on to the pool's curve.\n     *\n     * @param liq The amount of liquidity being minted represented as the equivalent to\n     *            sqrt(X*Y) in a constant product AMM pool.\n     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.\n     * @param minPrice The minimum acceptable curve price to mint liquidity. If curve\n     *                 price falls outside this point, the transaction is reverted.\n     * @param maxPrice The maximum acceptable curve price to mint liquidity. If curve\n     *                 price falls outside this point, the transaction is reverted.\n     * @param lpConduit The address of the ISdexLpConduit that the liquidity will be\n     *                  assigned to (0 for user owned liquidity).\n     *\n     * @return baseFlow The total amount of base-side token collateral that must be\n     *                  committed to the pool as part of the mint. Will always be\n     *                  positive as it's paid to the pool from the user.\n     * @return quoteFlow The total amount of quote-side token collateral that must be\n     *                   committed to the pool as part of the mint. */\n    function mintOverPool (uint128 liq, PoolSpecs.PoolCursor memory pool,\n                           uint128 minPrice, uint128 maxPrice, address lpConduit)\n        internal returns (int128 baseFlow, int128 quoteFlow) {\n        CurveMath.CurveState memory curve = snapCurveInRange\n            (pool.hash_, minPrice, maxPrice);\n        (baseFlow, quoteFlow) =\n            mintAmbient(curve, liq, pool.hash_, lpConduit);\n        commitCurve(pool.hash_, curve);\n    }\n\n    \n    /* @notice Burns ambient liquidity on to the pool's curve.\n     *\n     * @param liq The amount of liquidity to burn represented as the equivalent to\n     *            sqrt(X*Y) in a constant product AMM pool.\n     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.\n     * @param minPrice The minimum acceptable curve price to mint liquidity. If curve\n     *                 price falls outside this point, the transaction is reverted.\n     * @param maxPrice The maximum acceptable curve price to mint liquidity. If curve\n     *                 price falls outside this point, the transaction is reverted.\n     *\n     * @return baseFlow The total amount of base-side token collateral that is returned\n     *                  from the pool as part of the burn. Will always be negative\n     *                  as it's paid from the pool to the user.\n     * @return quoteFlow The total amount of quote-side token collateral that is returned\n     *                   from the pool as part of the burn. */\n    function burnOverPool (uint128 liq, PoolSpecs.PoolCursor memory pool,\n                           uint128 minPrice, uint128 maxPrice, address lpConduit)\n        internal returns (int128 baseFlow, int128 quoteFlow) {\n        CurveMath.CurveState memory curve = snapCurveInRange\n            (pool.hash_, minPrice, maxPrice);\n        (baseFlow, quoteFlow) =\n            burnAmbient(curve, liq, pool.hash_, lpConduit);\n        commitCurve(pool.hash_, curve);\n    }\n\n    /* @notice Initializes a new liquidity curve for the pool.\n       \n     * @dev This does *not* check whether the curve was previously initialized. It's\n     *      the caller's responsibility to make sure this is never called on an already\n     *      initialized pool.\n     *\n     * @param pool The pre-loaded speciication and hash of the pool to be swapped against.\n     * @param price The initial price to set the curve at. Represented as the square root\n     *              of price in Q64.64 fixed point.\n     * @param initLiq The initial ambient liquidity commitment that will be permanetely \n     *                locked in the pool. Represeted as sqrt(X*Y) constant-product AMM\n     *                liquidity.\n     *\n     * @return baseFlow The total amount of base-side token collateral that must be\n     *                  committed to the pool as part of the mint. Will always be\n     *                  positive as it's paid to the pool from the user.\n     * @return quoteFlow The total amount of quote-side token collateral that must be\n     *                   committed to the pool as part of the mint. */     \n    function initCurve (PoolSpecs.PoolCursor memory pool,\n                        uint128 price, uint128 initLiq)\n        internal returns (int128 baseFlow, int128 quoteFlow) {\n        CurveMath.CurveState memory curve = snapCurveInit(pool.hash_);\n        initPrice(curve, price);\n        if (initLiq == 0) { initLiq = 1; }\n        (baseFlow, quoteFlow) = lockAmbient(curve, initLiq);\n        commitCurve(pool.hash_, curve);\n    }\n\n    /* @notice Appplies the pool directive on to a pre-loaded liquidity curve. */\n    function applyToCurve (Chaining.PairFlow memory flow,\n                           Directives.PoolDirective memory dir,\n                           CurveCache.Cache memory curve,\n                           Chaining.ExecCntx memory cntx) private {\n        if (!dir.chain_.swapDefer_) {\n            applySwap(flow, dir.swap_, curve, cntx);\n        }\n        applyAmbient(flow, dir.ambient_, curve, cntx);\n        applyConcentrated(flow, dir.conc_, curve, cntx);\n        if (dir.chain_.swapDefer_) {\n            applySwap(flow, dir.swap_, curve, cntx);\n        }\n    }\n\n    /* @notice Applies the swap directive on to a pre-loaded liquidity curve. */\n    function applySwap (Chaining.PairFlow memory flow,\n                        Directives.SwapDirective memory dir,\n                        CurveCache.Cache memory curve,\n                        Chaining.ExecCntx memory cntx) private {\n        cntx.roll_.plugSwapGap(dir, flow);\n        if (dir.qty_ != 0) {\n            callSwap(flow, curve, dir, cntx.pool_);            \n        }\n    }\n\n    /* @notice Applies an ambient liquidity directive to a pre-loaded liquidity curve. */\n    function applyAmbient (Chaining.PairFlow memory flow,\n                           Directives.AmbientDirective memory dir,\n                           CurveCache.Cache memory curve,\n                           Chaining.ExecCntx memory cntx) private {\n        cntx.roll_.plugLiquidity(dir, curve.curve_, flow);\n        \n        if (dir.liquidity_ > 0) {\n            (int128 base, int128 quote) = dir.isAdd_ ?\n                callMintAmbient(curve, dir.liquidity_, cntx.pool_.hash_) :\n                callBurnAmbient(curve, dir.liquidity_, cntx.pool_.hash_);\n        \n            flow.accumFlow(base, quote);\n        }\n    }\n\n    /* @notice Applies zero, one or a series of concentrated liquidity directives to a \n     *         pre-loaded liquidity curve. */\n    function applyConcentrated (Chaining.PairFlow memory flow,\n                                 Directives.ConcentratedDirective[] memory dirs,\n                                 CurveCache.Cache memory curve,\n                                 Chaining.ExecCntx memory cntx) private {\n        unchecked { // Only arithmetic in block is ++i which will never overflow\n        for (uint i = 0; i < dirs.length; ++i) {\n            (int128 nextBase, int128 nextQuote) = applyConcentrated\n                (curve, flow, cntx, dirs[i]);\n            flow.accumFlow(nextBase, nextQuote);\n        }\n        }\n    }\n\n    /* Applies a single concentrated liquidity range order to the liquidity curve. */\n    function applyConcentrated (CurveCache.Cache memory curve,\n                                Chaining.PairFlow memory flow,\n                                Chaining.ExecCntx memory cntx,\n                                Directives.ConcentratedDirective memory bend)\n        private returns (int128, int128) {\n\n        // If ticks are relative, normalize against current pool price.\n        if (bend.isTickRel_) {\n            int24 priceTick = curve.pullPriceTick();\n            bend.lowTick_ = priceTick + bend.lowTick_;\n            bend.highTick_ = priceTick + bend.highTick_;\n            require((bend.lowTick_ >= TickMath.MIN_TICK) &&\n                    (bend.highTick_ <= TickMath.MAX_TICK) &&\n                    (bend.lowTick_ <= bend.highTick_), \"RT\");\n        }\n\n        // If liquidity is set based on rolling balance, dynamically set in base\n        // liquidity space.\n        cntx.roll_.plugLiquidity(bend, curve.curve_, bend.lowTick_,\n                                 bend.highTick_, flow);\n\n        if (bend.isAdd_) {\n            bool offGrid = cntx.improve_.verifyFit(bend.lowTick_, bend.highTick_,\n                                                   bend.liquidity_,\n                                                   cntx.pool_.head_.tickSize_,\n                                                   curve.pullPriceTick());\n\n            // Off-grid positions are only eligible when the LP has committed\n            // to a minimum liquidity commitment above some threshold. This opens\n            // up the possibility of a user minting an off-grid LP position above the\n            // the threshold, then partially burning the position to resize the position *below*\n            // the threhsold. \n            // To prevent this all off-grid positions are marked as atomic which prevents partial \n            // (but not full) burns. An off-grid LP wishing to reduce their position must fully \n            // burn the position, then mint a new position, which will be checked that it meets \n            // the size threshold at mint time.\n            if (offGrid) {\n                markPosAtomic(lockHolder_, cntx.pool_.hash_,\n                              bend.lowTick_, bend.highTick_);\n            }\n        }\n\n        if (bend.liquidity_ == 0) { return (0, 0); }\n        return bend.isAdd_ ?\n            callMintRange(curve, bend.lowTick_, bend.highTick_,\n                          bend.liquidity_, cntx.pool_.hash_) :\n            callBurnRange(curve, bend.lowTick_, bend.highTick_,\n                          bend.liquidity_, cntx.pool_.hash_);\n    }\n\n}\n"
    },
    "contracts/mixins/PoolRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport '../libraries/Directives.sol';\nimport '../libraries/PoolSpecs.sol';\nimport '../libraries/PriceGrid.sol';\nimport '../interfaces/ISdexPermitOracle.sol';\nimport './StorageLayout.sol';\n\n/* @title Pool registry mixin\n * @notice Provides a facility for registering and querying pool types on pairs and\n *         generalized pool templates for pools yet to be initialized. */\ncontract PoolRegistry is StorageLayout {\n    using PoolSpecs for uint8;\n    using PoolSpecs for PoolSpecs.Pool;\n\n    uint8 constant SWAP_ACT_CODE = 1;\n    uint8 constant MINT_ACT_CODE = 2;\n    uint8 constant BURN_ACT_CODE = 3;\n    uint8 constant COMP_ACT_CODE = 4;\n\n    /* @notice Tests whether the given swap by the given user is authorized on this\n     *         specific pool. If not, reverts the transaction. If pool is permissionless\n     *         this function will just noop. */\n    function verifyPermitSwap (PoolSpecs.PoolCursor memory pool,\n                               address base, address quote,\n                               bool isBuy, bool inBaseQty, uint128 qty) internal {\n        if (pool.oracle_ != address(0)) {\n            uint16 discount =\n                ISdexPermitOracle(pool.oracle_)\n                .checkApprovedForSdexSwap(lockHolder_, msg.sender, base, quote,\n                                          isBuy, inBaseQty, qty, pool.head_.feeRate_);\n            applyDiscount(pool, discount);\n        }\n    }\n\n    /* @notice Tests whether the given mint by the given user is authorized on this\n     *         specific pool. If not, reverts the transaction. If pool is permissionless\n     *         this function will just noop. */\n    function verifyPermitMint (PoolSpecs.PoolCursor memory pool,\n                               address base, address quote,\n                               int24 bidTick, int24 askTick, uint128 liq) internal {\n        if (pool.oracle_ != address(0)) {\n            bool approved = ISdexPermitOracle(pool.oracle_)\n                .checkApprovedForSdexMint(lockHolder_, msg.sender, base, quote,\n                                          bidTick, askTick, liq);\n            require(approved, \"Z\");\n        }\n    }\n\n    /* @notice Tests whether the given burn by the given user is authorized on this\n     *         specific pool. If not, reverts the transaction. If pool is permissionless\n     *         this function will just noop. */\n    function verifyPermitBurn (PoolSpecs.PoolCursor memory pool,\n                               address base, address quote,\n                               int24 bidTick, int24 askTick, uint128 liq) internal {\n        if (pool.oracle_ != address(0)) {\n            bool approved = ISdexPermitOracle(pool.oracle_)\n                .checkApprovedForSdexBurn(lockHolder_, msg.sender, base, quote,\n                                          bidTick, askTick, liq);\n            require(approved, \"Z\");\n        }\n    }\n\n    /* @notice Tests whether the given pool directive by the given user is authorized on \n     *         this specific pool. If not, reverts the transaction. If pool is \n     *         permissionless this function will just noop. */\n    function verifyPermit (PoolSpecs.PoolCursor memory pool,\n                           address base, address quote,\n                           Directives.AmbientDirective memory ambient,\n                           Directives.SwapDirective memory swap,\n                           Directives.ConcentratedDirective[] memory concs) internal {\n        if (pool.oracle_ != address(0)) {\n            uint16 discount = ISdexPermitOracle(pool.oracle_)\n                .checkApprovedForSdexPool(lockHolder_, msg.sender, base, quote, ambient,\n                                          swap, concs, pool.head_.feeRate_);\n            applyDiscount(pool, discount);\n        }\n    }\n\n    function applyDiscount (PoolSpecs.PoolCursor memory pool, uint16 discount) private pure {\n        // Convention from permit oracle return value. Uses 0 for non-approved (meaning we \n        // should rever), 1 for 0 discount, 2 for 0.0001% discount, and so on\n        uint16 DISCOUNT_OFFSET = 1;\n        require(discount > 0, \"Z\");\n        pool.head_.feeRate_ -= (discount - DISCOUNT_OFFSET);\n    }\n    \n    /* @notice Tests whether the given initialization by the given user is authorized on this\n     *         specific pool. If not, reverts the transaction. If pool is permissionless\n     *         this function will just noop. */\n    function verifyPermitInit (PoolSpecs.PoolCursor memory pool,\n                               address base, address quote, uint256 poolIdx) internal {\n        if (pool.oracle_ != address(0)) {\n            bool approved = ISdexPermitOracle(pool.oracle_).\n                checkApprovedForSdexInit(lockHolder_, msg.sender, base, quote, poolIdx);\n            require(approved, \"Z\");\n        }\n    }\n    \n\n    /* @notice Creates (or resets if previously existed) a new pool template associated\n     *         with an arbitrary pool index. After calling, any pair's pool initialized\n     *         at this index will be created using this template.\n     *\n     * @dev    Previously existing pools at this index will *not* be updated by this \n     *         call, and must be individually reset. This is only a consideration if the\n     *         template is being reset, as a pool can't be created at an index beore a\n     *         template exists.\n     *\n     * @param poolIdx The arbitrary index for which this template will be created. After\n     *                calling, any user will be able to initialize a pool with this \n     *                template in any pair by using this pool index.\n     * @param feeRate The pool's exchange fee as a percent of notional swapped. \n     *                Represented as a multiple of 0.0001%.\n     * @param tickSize The tick grid size for range orders in the pool. (Template can\n     *                 also be disabled by setting this to zero.)\n     * @param jitThresh The minimum time (in seconds) a concentrated LP position must \n     *                  rest before it can be burned.\n     * @param knockout  The knockout liquidity bit flags for the pool. (See KnockoutLiq library)\n     * @param oracleFlags The permissioned oracle flags for the pool. */\n    function setPoolTemplate (uint256 poolIdx, uint16 feeRate, uint16 tickSize,\n                              uint8 jitThresh, uint8 knockout, uint8 oracleFlags)\n        internal {\n        PoolSpecs.Pool storage templ = templates_[poolIdx];\n        templ.schema_ = PoolSpecs.BASE_SCHEMA;\n        templ.feeRate_ = feeRate;\n        templ.tickSize_ = tickSize;\n        templ.jitThresh_ = jitThresh;\n        templ.knockoutBits_ = knockout;\n        templ.oracleFlags_ = oracleFlags;\n\n        // If template is set to use a permissioned oracle, validate that the oracle address is a\n        // valid oracle contract\n        address oracle = PoolSpecs.oracleForPool(poolIdx, oracleFlags);\n        if (oracle != address(0)) {\n            require(oracle.code.length > 0 && ISdexPermitOracle(oracle).acceptsPermitOracle(),\n                \"Oracle\");    \n        }\n    }\n\n    function disablePoolTemplate (uint256 poolIdx) internal {\n        PoolSpecs.Pool storage templ = templates_[poolIdx];\n        templ.schema_ = PoolSpecs.DISABLED_SCHEMA;\n    }\n\n    /* @notice Resets the parameters on a previously existing pool in a specific pair.\n     *\n     * @dev We do not allow the permitOracle to be changed after the pool has been \n     *      initialized. That would give the protocol authority too much power to \n     *      arbitrarily lock LPs out of their funds. \n     *\n     * @param base The base-side token specification of the pair containing the pool.\n     * @param quote The quote-side token specification of the pair containing the pool.\n     * @param poolIdx The pool type index value. \n     * @param feeRate The pool's exchange fee as a percent of notional swapped. \n     *                Represented as a multiple of 0.0001%.\n     * @param tickSize The tick grid size for range orders in the pool.\n     * @param jitThresh The minimum time (in seconds) a concentrated LP position must \n     *                  rest before it can be burned.\n     * @param knockoutBits The knockout liquiidity parameter bit flags for the pool. */\n    function setPoolSpecs (address base, address quote, uint256 poolIdx,\n                           uint16 feeRate, uint16 tickSize, uint8 jitThresh,\n                           uint8 knockoutBits) internal {\n        PoolSpecs.Pool storage pool = selectPool(base, quote, poolIdx);\n        pool.feeRate_ = feeRate;\n        pool.tickSize_ = tickSize;\n        pool.jitThresh_ = jitThresh;\n        pool.knockoutBits_ = knockoutBits;\n    }\n\n    // 10 million represents a sensible upper bound on initial pool, considering that the highest\n    // price token per wei is USDC and similar 6-digit stablecoins. So 10 million in that context\n    // represents about $10 worth of burned value. Considering that the initial liquidity commitment\n    // should be economic de minims, because it's permenately locked, we wouldn't want to be much \n    // higher than this.\n    uint128 constant MAX_INIT_POOL_LIQ = 10_000_000;\n\n    /* @notice The creation of every new pool requires the pool initializer to \n     *         permanetely lock in a token amount of liquidity (possibly zero). This is\n     *         set to be economically meaningless for normal cases but prevent the \n     *         creation of pools for tokens that don't exist or make it expensive to \n     *         create pools at extremely wrong prices. This function sets that liquidity\n     *         ante value that determines how much liquidity must be locked at \n     *         initialization time. */\n    function setNewPoolLiq (uint128 liqAnte) internal {\n        require(liqAnte > 0 && liqAnte < MAX_INIT_POOL_LIQ, \"Init liq\");\n        newPoolLiq_ = liqAnte;\n\n    }\n\n    function setProtocolTakeRate (uint8 takeRate) internal {\n        require(takeRate <= MAX_TAKE_RATE, \"TR\");\n        protocolTakeRate_ = takeRate;\n    }\n\n    function setRelayerTakeRate (uint8 takeRate) internal {\n        require(takeRate <= MAX_TAKE_RATE, \"TR\");\n        relayerTakeRate_ = takeRate;\n    }\n\n    function resyncProtocolTake (address base, address quote,\n                                  uint256 poolIdx) internal {\n        PoolSpecs.Pool storage pool = selectPool(base, quote, poolIdx);\n        pool.protocolTake_ = protocolTakeRate_;\n    }\n\n    /* @notice Sets the off-grid price improvement thresholds for a specific token. Once\n     *         set this will apply to every pool in every pair over this token. The \n     *         stored settings for a token can be initialized, then later reset \n     *         arbitararily.\n     *\n     * @param token The token these settings apply to (if 0x0, they apply to native \n     *              Eth pairs)\n     * @param unitTickCollateral The collateral threshold per off-grid tick.\n     * @param awayTickTol The maximum ticks away from the current price that an off-grid\n     *                    range order can apply. */\n    function setPriceImprove (address token, uint128 unitTickCollateral,\n                              uint16 awayTickTol) internal {\n        improves_[token].unitCollateral_ = unitTickCollateral;\n        improves_[token].awayTicks_ = awayTickTol;\n    }\n\n    /* @notice This is called during the initialization of a new pool. It registers the\n     *         pool for this pair and type in storage for later access. Note that the\n     *         caller still needs to actually construct the curve, collect the required\n     *         collateral, etc. All this does is storage the pool specs.\n     * \n     * @param base The base-side token (or 0x0 for native Eth) defining the pair.\n     * @param quote The quote-side token defining the pair.\n     * @param poolIdx The pool type index for the newly created pool. The pool specs will\n     *                be created from the current template for this index. (If no \n     *                template exists, this call will revert the transaction.)\n     *\n     * @return pool The pool specs associated with the newly created pool.\n     * @return liqAnte The required amount of liquidity that the user must permanetely\n     *                 lock to create the pool. (See setNewPoolLiq() above) */\n    function registerPool (address base, address quote, uint256 poolIdx) internal\n        returns (PoolSpecs.PoolCursor memory, uint128) {\n        assertPoolFresh(base, quote, poolIdx);\n        PoolSpecs.Pool memory template = queryTemplate(poolIdx);\n        template.protocolTake_ = protocolTakeRate_;\n        PoolSpecs.writePool(pools_, base, quote, poolIdx, template);\n        return (queryPool(base, quote, poolIdx), newPoolLiq_);\n    }\n\n    /* @notice This returns the off-grid price improvement settings (if any) for the\n     *         the side of the pair the user requests. (Or none, to save on gas,\n     *         if the user doesn't explicitly request price improvement).\n     *\n     * @param req The user specificed price improvement request.\n     * @param base The base-side token defining the pair.\n     * @param quote The quote-side token defining the pair.\n     * @return The price grid improvement thresholds (if any) for off-grid liquidity \n     *         positions. */\n    function queryPriceImprove (Directives.PriceImproveReq memory req,\n                                address base, address quote)\n        view internal returns (PriceGrid.ImproveSettings memory dest) {\n        if (req.isEnabled_) {\n            address token = req.useBaseSide_ ? base : quote;\n            dest.inBase_ = req.useBaseSide_;\n            dest.unitCollateral_ = improves_[token].unitCollateral_;\n            dest.awayTicks_ = improves_[token].awayTicks_;\n        }\n    }\n\n    /* @notice Looks up and returns the pool specs associated with the pair and pool type\n     *\n     * @dev If no pool exists, this call reverts the transaction.\n     *\n     * @param base The base-side token defining the pair.\n     * @param quote The quote-side token defining the pair.\n     * @param poolIdx The pool type index.\n     * @return The current spec parameters for the pool. */\n    function queryPool (address base, address quote, uint256 poolIdx)\n        internal view returns (PoolSpecs.PoolCursor memory pool) {\n        pool = PoolSpecs.queryPool(pools_, base, quote, poolIdx);\n        require(isPoolInit(pool), \"PI\");\n    }\n\n    function assertPoolFresh (address base, address quote,\n                              uint256 poolIdx) internal view {\n        PoolSpecs.PoolCursor memory pool =\n            PoolSpecs.queryPool(pools_, base, quote, poolIdx);\n        require(!isPoolInit(pool), \"PF\");\n    }\n\n    /* @notice Checks if a given position is JIT eligible based on its mint timestamp.\n     *         If not, the transaction will revert.\n     * \n     * @dev Because JIT window is capped at 8-bit integers, we can avoid the SLOAD\n     *      for all positions older than 2550 seconds, which are the vast majority.\n     *\n     * @param posTime The block time the position was created or had its liquidity \n     *                increased.\n     * @param poolIdx The hash index of the AMM curve pool. */\n    function assertJitSafe (uint32 posTime, bytes32 poolIdx) internal view {\n        uint32 JIT_UNIT_SECONDS = 10;\n        uint32 elapsedSecs = SafeCast.timeUint32() - posTime;\n        uint32 elapsedUnits = elapsedSecs / JIT_UNIT_SECONDS;\n        if (elapsedUnits <= type(uint8).max) {\n            require(elapsedUnits >= pools_[poolIdx].jitThresh_, \"J\");\n        }\n    }\n\n    /* @notice Looks up and returns a storage pointer associated with the pair and pool \n     *         type.\n     *\n     * @param base The base-side token defining the pair.\n     * @param quote The quote-side token defining the pair.\n     * @param poolIdx The pool type index.\n     * @return Storage reference to the specs for the pool. */\n    function selectPool (address base, address quote, uint256 poolIdx)\n        private view returns (PoolSpecs.Pool storage pool) {\n        pool = PoolSpecs.selectPool(pools_, base, quote, poolIdx);\n        require(isPoolInit(pool), \"PI\");\n    }\n\n    /* @notice Looks up and returns the pool template associated with the pool type \n     *         index. If no template exists (or it was disabled after initialization)\n     *         this call reverts the transaction. */\n    function queryTemplate (uint256 poolIdx)\n        private view returns (PoolSpecs.Pool memory template) {\n        template = templates_[poolIdx];\n        require(isPoolInit(template), \"PT\");\n    }\n\n    /* @notice Returns true if the pool spec object represents an initailized pool \n     *         that hasn't been disabled. */\n    function isPoolInit (PoolSpecs.Pool memory pool)\n        private pure returns (bool) {\n        require(pool.schema_ <= PoolSpecs.BASE_SCHEMA, \"IPS\");\n        return pool.schema_ == PoolSpecs.BASE_SCHEMA;\n    }\n\n    /* @notice Returns true if the pool cursor represents an initailized pool that\n     *         hasn't been disabled. */\n    function isPoolInit (PoolSpecs.PoolCursor memory pool)\n        private pure returns (bool) {        \n        require(pool.head_.schema_ <= PoolSpecs.BASE_SCHEMA, \"IPS\");\n        return pool.head_.schema_ == PoolSpecs.BASE_SCHEMA;\n    }\n}\n"
    },
    "contracts/mixins/PositionRegistrar.sol": {
      "content": "// SPDX-License-Identifier: GPL-3 \n\npragma solidity 0.8.19;\n\nimport '../libraries/SafeCast.sol';\nimport '../libraries/LiquidityMath.sol';\nimport '../libraries/CompoundMath.sol';\nimport './StorageLayout.sol';\nimport './PoolRegistry.sol';\n\n/* @title Position registrar mixin\n * @notice Tracks the individual positions of liquidity miners, including fee \n *         accumulation checkpoints for fair distribution of rewards. */\ncontract PositionRegistrar is PoolRegistry {\n    using SafeCast for uint256;\n    using SafeCast for uint144;\n    using CompoundMath for uint128;\n    using LiquidityMath for uint64;\n    using LiquidityMath for uint72;\n    using LiquidityMath for uint128;\n\n    /* The six things we need to know for each concentrated liquidity position are:\n     *    1) Owner\n     *    2) The pool the position is on.\n     *    3) Lower tick bound on the range\n     *    4) Upper tick bound on the range\n     *    5) Total liquidity\n     *    6) Fee accumulation mileage for the position's range checkpointed at the last\n     *       update. Used to correctly distribute in-range liquidity rewards.\n     * Of these 1-4 constitute the unique key. If a user adds a new position with the\n     * same owner and the same range, it can be represented by incrementing 5 and \n     * updating 6. */\n\n    /* @notice Hashes the owner of an ambient liquidity position to the position key. */\n    function encodePosKey (address owner, bytes32 poolIdx)\n        internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(owner, poolIdx));\n    }\n\n    /* @notice Hashes the owner and concentrated liquidity range to the position key. */\n    function encodePosKey (address owner, bytes32 poolIdx,\n                           int24 lowerTick, int24 upperTick)\n        internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(owner, poolIdx, lowerTick, upperTick));\n    }\n\n    /* @notice Returns the current position associated with the owner/range. If nothing\n     *         exists the result will have zero liquidity. */\n    function lookupPosition (address owner, bytes32 poolIdx, int24 lowerTick,\n                               int24 upperTick)\n        internal view returns (RangePosition72 storage) {\n        return positions72_[encodePosKey(owner, poolIdx, lowerTick, upperTick)];\n    }\n\n    /* @notice Returns the current position associated with the owner's ambient \n     *         position. If nothing exists the result will have zero liquidity. */\n    function lookupPosition (address owner, bytes32 poolIdx)\n        internal view returns (AmbientPosition storage) {\n        return ambPositions_[encodePosKey(owner, poolIdx)];\n    }\n\n    /* @notice Removes all or some liquidity associated with a position. Calculates\n     *         the cumulative rewards since last update, and updates the fee mileage\n     *         (if position still have active liquidity).\n     *\n     * @param owner The bytes32 owning the position.\n     * @param poolIdx The hash key of the pool the position lives on.\n     * @param lowerTick The 24-bit tick index constituting the lower range of the \n     *                  concentrated liquidity position.\n     * @param upperTick The 24-bit tick index constituting the upper range of the \n     *                  concentrated liquidity position.\n     * @param burnLiq The amount of liquidity to remove from the position. Caller is\n     *                is responsible for making sure the position has at least this much\n     *                liquidity in place.\n     * @param feeMileage The up-to-date fee mileage associated with the range. If the\n     *                   position is still active after this call, this new value will\n     *                   be checkpointed on the position.\n     *\n     * @return rewards The rewards accumulated between the current and last checkpoined\n     *                 fee mileage. */\n    function burnPosLiq (address owner, bytes32 poolIdx, int24 lowerTick,\n                         int24 upperTick, uint128 burnLiq, uint72 feeMileage)\n        internal returns (uint64) {\n        RangePosition72 storage pos = lookupPosition(owner, poolIdx, lowerTick, upperTick);\n        assertJitSafe(pos.timestamp_, poolIdx);\n        return decrementLiq(pos, burnLiq, feeMileage);\n    }\n\n    /* @notice Removes all or some liquidity associated with a an ambient position. \n     *         \n     * @param owner The bytes32 owning the position.\n     * @param poolIdx The hash key of the pool the position lives on.\n     * @param burnLiq The amount of liquidity to remove from the position. Caller is free\n     *                to oversize this number and it will just cap at the position size.\n     * @param ambientGrowth The up-to-date ambient liquidity seed deflator for the curve.\n     *\n     * @return burnSeeds The total number of ambient seeds that have been removed with\n     *                   this operation. */\n    function burnPosLiq (address owner, bytes32 poolIdx, uint128 burnLiq,\n                         uint64 ambientGrowth)\n        internal returns (uint128 burnSeeds) {\n        AmbientPosition storage pos = lookupPosition(owner, poolIdx);\n        burnSeeds = burnLiq.deflateLiqSeed(ambientGrowth);\n\n        if (burnSeeds >= pos.seeds_) {\n            burnSeeds = pos.seeds_;\n            // Solidity optimizer should convert this to a single refunded SSTORE\n            pos.seeds_ = 0;\n            pos.timestamp_ = 0;\n        } else {\n            pos.seeds_ -= burnSeeds;\n            // Decreasing liquidity does not lose time priority\n        }\n    }\n\n    /* @notice Decrements a range order position with the amount of liquidity being\n     *         burned, and calculates the incremental rewards mileage. */\n    function decrementLiq (RangePosition72 storage pos,\n                           uint128 burnLiq, uint72 feeMileage) internal returns\n        (uint64 rewards) {\n        uint128 liq = pos.liquidity_;\n        uint128 nextLiq = LiquidityMath.minusDelta(liq, burnLiq);\n\n        rewards = feeMileage.deltaRewardsRate72(pos.feeMileage_);\n\n        if (nextLiq > 0) {\n            // Partial burn. Check that it's allowed on this position.\n            require(pos.atomicLiq_ == false, \"OR\");\n            pos.liquidity_ = nextLiq;\n            // No need to adjust the position's mileage checkpoint. Rewards are in per\n            // unit of liquidity, so the pro-rata rewards of the remaining liquidity\n            // (if any) remain unnaffected. \n        } else {\n            // Solidity optimizer should convert this to a single refunded SSTORE\n            pos.liquidity_ = 0;\n            pos.feeMileage_ = 0;\n            pos.timestamp_ = 0;\n            pos.atomicLiq_ = false;\n        }\n    }\n\n    /* @notice Harvests all of the rewards on a concentrated liquidity position and \n     *         resets the accumulated fees to zero.\n     *         \n     * @param owner The bytes32 owning the position.\n     * @param poolIdx The hash key of the pool the position lives on.\n     * @param lowerTick The lower tick of the LP position\n     * @param upperTick The upper tick of the LP position.\n     * @param feeMileage The current accumulated fee rewards rate for the position range\n     *\n     * @return rewards The total number of ambient seeds to collect as rewards */\n    function harvestPosLiq (address owner, bytes32 poolIdx, int24 lowerTick,\n                            int24 upperTick, uint72 feeMileage)\n        internal returns (uint128 rewards) {        \n        RangePosition72 storage pos = lookupPosition(owner, poolIdx, lowerTick, upperTick);\n        uint72 oldMileage = pos.feeMileage_;\n\n        // Technically feeMileage should never be less than oldMileage, but we need to\n        // handle it because it can happen due to fixed-point effects.\n        // (See blendMileage() function.)\n        if (feeMileage > oldMileage) {\n            uint64 rewardsRate = feeMileage.deltaRewardsRate72(oldMileage);\n            rewards = FixedPoint.mulQ48(pos.liquidity_, rewardsRate).toUint128By144();\n            pos.feeMileage_ = feeMileage;\n        }\n    }\n\n    /* @notice Marks a flag on a speciic position that indicates that it's liquidity\n     *         is atomic. I.e. the position size cannot be partially reduced, only\n     *         removed entirely. */\n    function markPosAtomic (address owner, bytes32 poolIdx,\n                            int24 lowTick, int24 highTick) internal {\n        RangePosition72 storage pos = lookupPosition(owner, poolIdx, lowTick, highTick);\n        pos.atomicLiq_ = true;\n    }\n\n    /* @notice Adds liquidity to a given concentrated liquidity position, creating the\n     *         position if necessary.\n     *\n     * @param owner The bytes32 owning the position.\n     * @param poolIdx The index of the pool the position belongs to\n     * @param lowerTick The 24-bit tick index constituting the lower range of the \n     *                  concentrated liquidity position.\n     * @param upperTick The 24-bit tick index constituting the upper range of the \n     *                  concentrated liquidity position.\n     * @param liqAdd The amount of liquidity to add to the position. If no liquidity \n     *               previously exists, position will be created.\n     * @param feeMileage The up-to-date fee mileage associated with the range. If the\n     *                   position will be checkpointed with this value. */\n    function mintPosLiq (address owner, bytes32 poolIdx, int24 lowerTick,\n                         int24 upperTick, uint128 liqAdd, uint72 feeMileage) internal {\n        RangePosition72 storage pos = lookupPosition(owner, poolIdx, lowerTick, upperTick);\n        incrementPosLiq(pos, liqAdd, feeMileage);\n    }\n    \n    /* @notice Adds ambient liquidity to a give position, creating a new position tracker\n     *         if necessry.\n     *         \n     * @param owner The address of the owner of the liquidity position.\n     * @param poolIdx The hash key of the pool the position lives on.\n     * @param liqAdd The amount of liquidity to add to the position.\n     * @param ambientGrowth The up-to-date ambient liquidity seed deflator for the curve.\n     *\n     * @return seeds The total number of ambient seeds that this incremental liquidity\n     *               corresponds to. */\n    function mintPosLiq (address owner, bytes32 poolIdx, uint128 liqAdd,\n                         uint64 ambientGrowth) internal returns (uint128 seeds) {\n        AmbientPosition storage pos = lookupPosition(owner, poolIdx);\n        seeds = liqAdd.deflateLiqSeed(ambientGrowth);\n        pos.seeds_ = pos.seeds_.addLiq(seeds);\n        pos.timestamp_ = SafeCast.timeUint32(); // Increase liquidity loses time priority.\n    }\n\n    function incrementPosLiq (RangePosition72 storage pos, uint128 liqAdd,\n                              uint72 feeMileage) private {\n        uint128 liq = pos.liquidity_;\n        uint72 oldMileage;\n\n        if (liq > 0) {\n            oldMileage = pos.feeMileage_;\n        } else {\n            oldMileage = 0;\n        }\n\n        uint128 liqNext = liq.addLiq(liqAdd);\n        uint72 mileage = feeMileage.blendMileage72(liqAdd, oldMileage, liq);\n        uint32 stamp = SafeCast.timeUint32();\n        \n        // Below should get optimized to a single SSTORE...\n        pos.liquidity_ = liqNext;\n        pos.feeMileage_ = mileage;\n        pos.timestamp_ = stamp;\n    }\n}\n"
    },
    "contracts/mixins/ProtocolAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport '../libraries/TransferHelper.sol';\nimport '../libraries/TokenFlow.sol';\nimport '../libraries/SafeCast.sol';\nimport './StorageLayout.sol';\n\n/* @title Protocol Account Mixin\n * @notice Tracks and pays out the accumulated protocol fees across the entire exchange \n *         These are the fees belonging to the SdexSwap protocol, not the liquidity \n *         miners.\n * @dev Unlike liquidity fees, protocol fees are accumulated as resting tokens \n *      instead of ambient liquidity. */\ncontract ProtocolAccount is StorageLayout  {\n    using SafeCast for uint256;\n    using TokenFlow for address;\n    \n    /* @notice Called at the completion of a swap event, incrementing any protocol\n     *         fees accumulated in the swap. */\n    function accumProtocolFees (TokenFlow.PairSeq memory accum) internal {\n        accumProtocolFees(accum.flow_, accum.baseToken_, accum.quoteToken_);\n    }\n\n    /* @notice Increments the protocol's account with the fees collected on the pair. */\n    function accumProtocolFees (Chaining.PairFlow memory accum,\n                                address base, address quote) internal {\n        if (accum.baseProto_ > 0) {\n            feesAccum_[base] += accum.baseProto_;\n        }\n        if (accum.quoteProto_ > 0) {\n            feesAccum_[quote] += accum.quoteProto_;\n        }\n    }\n\n    /* @notice Pays out the earned, but unclaimed protocol fees in the pool.\n     * @param recv - The receiver of the protocol fees.\n     * @param token - The token address of the quote token. */\n    function disburseProtocolFees (address recv, address token) internal {\n        uint128 collected = feesAccum_[token];\n        feesAccum_[token] = 0;\n        if (collected > 0) {\n            bytes32 payoutKey = keccak256(abi.encode(recv, token));\n            userBals_[payoutKey].surplusCollateral_ += collected;\n        }\n    }\n}\n"
    },
    "contracts/mixins/ProxyCaller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport './StorageLayout.sol';\nimport '../libraries/CurveCache.sol';\nimport '../libraries/Chaining.sol';\nimport '../libraries/Directives.sol';\n\n/* @title Proxy Caller\n * @notice Because of the Ethereum contract limit, much of the SdexSwap code is pushed\n *         into sidecar proxy contracts, which is involed with DELEGATECALLs. The code\n *         moved to these sidecars is less gas critical than the code in the core contract. \n *         This provides a facility for invoking proxy conjtracts in a consistent way by\n*          setting up the DELEGATECALLs in a standard and safe manner. */\ncontract ProxyCaller is StorageLayout {\n    using CurveCache for CurveCache.Cache;\n    using CurveMath for CurveMath.CurveState;\n    using Chaining for Chaining.PairFlow;\n\n    /* @notice Passes through the protocolCmd call to a sidecar proxy. */\n    function callProtocolCmd (uint16 proxyIdx, bytes calldata input) internal\n        returns (bytes memory) {\n        assertProxy(proxyIdx);\n        (bool success, bytes memory output) = proxyPaths_[proxyIdx].delegatecall(\n            abi.encodeWithSignature(\"protocolCmd(bytes)\", input));\n        return verifyCallResult(success, output);\n    }\n\n    /* @notice Passes through the userCmd call to a sidecar proxy. */\n    function callUserCmd (uint16 proxyIdx, bytes calldata input)\n        internal returns (bytes memory) {\n        assertProxy(proxyIdx);\n        (bool success, bytes memory output) = proxyPaths_[proxyIdx].delegatecall(\n            abi.encodeWithSignature(\"userCmd(bytes)\", input));\n        return verifyCallResult(success, output);\n    }\n\n    function callUserCmdMem (uint16 proxyIdx, bytes memory input)\n        internal returns (bytes memory) {\n        assertProxy(proxyIdx);\n        (bool success, bytes memory output) = proxyPaths_[proxyIdx].delegatecall(\n            abi.encodeWithSignature(\"userCmd(bytes)\", input));\n        return verifyCallResult(success, output);\n    }\n\n    function assertProxy (uint16 proxyIdx) private view {\n        require(proxyPaths_[proxyIdx] != address(0));\n        require(!inSafeMode_ || proxyIdx == SdexSlots.SAFE_MODE_PROXY_PATH || proxyIdx == SdexSlots.BOOT_PROXY_IDX);\n    }\n\n    function verifyCallResult (bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        // On success pass through the return data\n        if (success) {\n            return returndata;\n        } else if (returndata.length > 0) {\n            // If DELEGATECALL failed bubble up the error message\n            assembly {\n                 let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            // If failed with no  error, then bubble up the empty revert\n            revert();\n        }\n    }\n\n    /* @notice Invokes mintAmbient() call in MicroPaths sidecar and relays the result. */\n    function callMintAmbient (CurveCache.Cache memory curve, uint128 liq,\n                              bytes32 poolHash) internal\n        returns (int128 basePaid, int128 quotePaid) {\n        (bool success, bytes memory output) =\n            proxyPaths_[SdexSlots.MICRO_PROXY_IDX].delegatecall\n            (abi.encodeWithSignature\n             (\"mintAmbient(uint128,uint128,uint128,uint64,uint64,uint128,bytes32)\",\n              curve.curve_.priceRoot_, \n              curve.curve_.ambientSeeds_,\n              curve.curve_.concLiq_,\n              curve.curve_.seedDeflator_,\n              curve.curve_.concGrowth_,\n              liq, poolHash));\n        require(success);\n        \n        (basePaid, quotePaid,\n         curve.curve_.ambientSeeds_) = \n            abi.decode(output, (int128, int128, uint128));\n    }\n\n    /* @notice Invokes burnAmbient() call in MicroPaths sidecar and relays the result. */\n    function callBurnAmbient (CurveCache.Cache memory curve, uint128 liq,\n                              bytes32 poolHash) internal\n        returns (int128 basePaid, int128 quotePaid) {\n\n        (bool success, bytes memory output) =\n            proxyPaths_[SdexSlots.MICRO_PROXY_IDX].delegatecall\n            (abi.encodeWithSignature\n             (\"burnAmbient(uint128,uint128,uint128,uint64,uint64,uint128,bytes32)\",\n              curve.curve_.priceRoot_, \n              curve.curve_.ambientSeeds_,\n              curve.curve_.concLiq_,\n              curve.curve_.seedDeflator_,\n              curve.curve_.concGrowth_,\n              liq, poolHash));\n        require(success);\n        \n        (basePaid, quotePaid,\n         curve.curve_.ambientSeeds_) = \n            abi.decode(output, (int128, int128, uint128));\n    }\n\n    /* @notice Invokes mintRange() call in MicroPaths sidecar and relays the result. */\n    function callMintRange (CurveCache.Cache memory curve,\n                            int24 bidTick, int24 askTick, uint128 liq,\n                            bytes32 poolHash) internal\n        returns (int128 basePaid, int128 quotePaid) {\n\n        (bool success, bytes memory output) =\n            proxyPaths_[SdexSlots.MICRO_PROXY_IDX].delegatecall\n            (abi.encodeWithSignature\n             (\"mintRange(uint128,int24,uint128,uint128,uint64,uint64,int24,int24,uint128,bytes32)\",\n              curve.curve_.priceRoot_, curve.pullPriceTick(),\n              curve.curve_.ambientSeeds_,\n              curve.curve_.concLiq_,\n              curve.curve_.seedDeflator_,\n              curve.curve_.concGrowth_,\n              bidTick, askTick, liq, poolHash));\n        require(success);\n\n        (basePaid, quotePaid,\n         curve.curve_.ambientSeeds_,\n         curve.curve_.concLiq_) = \n            abi.decode(output, (int128, int128, uint128, uint128));\n    }\n    \n    /* @notice Invokes burnRange() call in MicroPaths sidecar and relays the result. */\n    function callBurnRange (CurveCache.Cache memory curve,\n                            int24 bidTick, int24 askTick, uint128 liq,\n                            bytes32 poolHash) internal\n        returns (int128 basePaid, int128 quotePaid) {\n        \n        (bool success, bytes memory output) =\n            proxyPaths_[SdexSlots.MICRO_PROXY_IDX].delegatecall\n            (abi.encodeWithSignature\n             (\"burnRange(uint128,int24,uint128,uint128,uint64,uint64,int24,int24,uint128,bytes32)\",\n              curve.curve_.priceRoot_, curve.pullPriceTick(),\n              curve.curve_.ambientSeeds_, curve.curve_.concLiq_,\n              curve.curve_.seedDeflator_, curve.curve_.concGrowth_,\n              bidTick, askTick, liq, poolHash));\n        require(success);\n        \n        (basePaid, quotePaid,\n         curve.curve_.ambientSeeds_,\n         curve.curve_.concLiq_) = \n            abi.decode(output, (int128, int128, uint128, uint128));\n    }\n\n    /* @notice Invokes sweepSwap() call in MicroPaths sidecar and relays the result. */\n    function callSwap (Chaining.PairFlow memory accum,\n                       CurveCache.Cache memory curve,\n                       Directives.SwapDirective memory swap,\n                       PoolSpecs.PoolCursor memory pool) internal {\n        (bool success, bytes memory output) =\n            proxyPaths_[SdexSlots.MICRO_PROXY_IDX].delegatecall\n            (abi.encodeWithSignature\n             (\"sweepSwap((uint128,uint128,uint128,uint64,uint64),int24,(bool,bool,uint8,uint128,uint128),((uint8,uint16,uint8,uint16,uint8,uint8,uint8),bytes32,address))\",\n              curve.curve_, curve.pullPriceTick(), swap, pool));\n        require(success);\n\n        Chaining.PairFlow memory swapFlow;\n        (swapFlow, curve.curve_.priceRoot_,\n         curve.curve_.ambientSeeds_,\n         curve.curve_.concLiq_,\n         curve.curve_.seedDeflator_,\n         curve.curve_.concGrowth_) = \n            abi.decode(output, (Chaining.PairFlow, uint128, uint128, uint128,\n                                uint64, uint64));\n\n        // swap() is the only operation that can change curve price, so have to mark\n        // the tick cache as dirty.\n        curve.dirtyPrice();\n        accum.foldFlow(swapFlow);\n    }\n\n    function callCrossFlag (bytes32 poolHash, int24 tick,\n                            bool isBuy, uint64 feeGlobal)\n        internal returns (int128 concLiqDelta) {\n        require(proxyPaths_[SdexSlots.FLAG_CROSS_PROXY_IDX] != address(0));\n        \n        (bool success, bytes memory cmd) =\n            proxyPaths_[SdexSlots.FLAG_CROSS_PROXY_IDX].delegatecall\n            (abi.encodeWithSignature\n             (\"crossCurveFlag(bytes32,int24,bool,uint64)\",\n              poolHash, tick, isBuy, feeGlobal));\n        require(success);\n\n        concLiqDelta = abi.decode(cmd, (int128));\n    }\n}\n"
    },
    "contracts/mixins/SettleLayer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3                                                          \npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport '../libraries/Directives.sol';\nimport '../libraries/TransferHelper.sol';\nimport '../libraries/TokenFlow.sol';\nimport './StorageLayout.sol';\nimport './AgentMask.sol';\n\n/* @title Settle layer mixin\n * @notice Provides facilities for settling, previously determined, collateral flows\n *         between the user and the exchange. Supports both ERC20 tokens as well as\n *         native Ethereum as asset collateral. */\ncontract SettleLayer is AgentMask {\n    using SafeCast for uint256;\n    using SafeCast for uint128;\n    using TokenFlow for address;\n\n    /* @notice Completes the user<->exchange collateral settlement at the final hop\n     *         in the transaction. Settles both the token from the last leg in the chain\n     *         as well as closes out the previous net Ether flows.\n     * \n     * @dev    This method settles any net Ether debits or credits in the ethFlows\n     *         argument, by consuming the native ETH attached in msg.value, using\n     *         popMsgVal(). popMsgVal() sets a transaction level flag, and to prevent\n     *         double spent will revert and fail the top level SdexSwapDex contract\n     *         call if ever called twice in the same transction. Therefore this method\n     *         must only be called at most once per transaction, otherwise the top-level\n     *         SdexSwapDex contract call will revert and fail.  \n     *\n     * @param flow The net flow for this settlement leg. Negative for credits paid to\n     *             user, positive for debits.\n     * @param dir The directive governing the details of how the user once the leg \n     *            settled.\n     * @param ethFlows Any prior Ether-specific flows from previous legs. (This final\n     *            leg may also be denominated in Eth, and this param should *not* include\n     *            the current leg's value.) */\n    function settleFinal (int128 flow, Directives.SettlementChannel memory dir,\n                          int128 ethFlows) internal {\n        (address debitor, address creditor) = agentsSettle();\n        settleFinal(debitor, creditor, flow, dir, ethFlows);\n    }\n\n    /* @notice Completes the user<->exchange collateral settlement on an intermediate hop\n     *         leg in the transaction. For ERC20 tokens the flow will be settled at this\n     *         call. For native Ether flows, the net flow will be returned to be deferred\n     *         until the settleFinal() call. This is because we potentially have multiple\n     *         native Eth settlement legs and want to avoid a msg.value double spend.\n     *\n     * @param flow The net flow for this settlement leg. Negative for credits paid to\n     *             user, positive for debits.\n     * @param dir The directive governing the details of how the user once the leg \n     *            settled.\n     * @return ethFlows Any native Eth flows associated with this leg. It's the caller's\n     *                  responsibility to accumulate and sum this value for all calls,\n     *                  then pass to settleFinal() at the end of the transaction. */\n    function settleLeg (int128 flow, Directives.SettlementChannel memory dir)\n        internal returns (int128 ethFlows) {\n        (address debitor, address creditor) = agentsSettle();\n        return settleLeg(debitor, creditor, flow, dir);\n    }\n\n    /* @notice Completes the user<->exchange collateral settlement at the final hop\n     *         in the transaction. Settles both the token from the last leg in the chain\n     *         as well as closes out the previous net Ether flows.\n     * \n     * @dev   This call is the point where any Ether debit \n     Because this actually collects any Ether debit (using msg.value), this\n     *         function must be called *exactly once* as the final settlement call in\n     *         a transaction. Otherwise, a double-spend is possible.\n     *\n     * @param debitor The address from which any debts to the exchange should be \n     *                collected.\n     * @param creditor The address to which any credits owed to the user should be paid.\n     * @param flow The net flow for this settlement leg. Negative for credits paid to\n     *             user, positive for debits.\n     * @param dir The directive governing the details of how the user once the leg \n     *            settled.\n     * @param ethFlows Any prior Ether-specific flows from previous legs. (This final\n     *            leg may also be denominated in Eth, and this param should *not* include\n     *            the current leg's value.) */\n    function settleFinal (address debitor, address creditor, int128 flow,\n                          Directives.SettlementChannel memory dir,\n                          int128 ethFlows) internal {\n        ethFlows += settleLeg(debitor, creditor, flow, dir);\n        transactEther(debitor, creditor, ethFlows, dir.useSurplus_);\n    }\n\n    /* @notice Completes the user<->exchange collateral settlement on an intermediate hop\n     *         leg in the transaction. For ERC20 tokens the flow will be settled at this\n     *         call. For native Ether flows, the net flow will be returned to be deferred\n     *         until the settleFinal() call. This is because we potentially have multiple\n     *         native Eth settlement legs and want to avoid a msg.value double spend.\n     *\n     * @param debitor The address from which any debts to the exchange should be \n     *                collected.\n     * @param creditor The address to which any credits owed to the user should be paid.\n     * @param flow The net flow for this settlement leg. Negative for credits paid to\n     *             user, positive for debits.\n     * @param dir The directive governing the details of how the user once the leg \n     *            settled.\n     * @return ethFlows Any native Eth flows associated with this leg. It's the caller's\n     *                  responsibility to accumulate and sum this value for all calls,\n     *                  then pass to settleFinal() at the end of the transaction. */\n    function settleLeg (address debitor, address creditor, int128 flow,\n                        Directives.SettlementChannel memory dir)\n        internal returns (int128 ethFlows) {\n        require(passesLimit(flow, dir.limitQty_), \"K\");\n        if (moreThanDust(flow, dir.dustThresh_)) {\n            ethFlows = pumpFlow(debitor, creditor, flow, dir.token_, dir.useSurplus_);\n        }\n    }\n\n    /* @notice Settle the collateral exchange associated with a single bilateral pair.\n     *         Useful and gas efficient when there's only one pair in the transaction.\n     * @param base The ERC20 address of the base token collateral in the pair (if 0x0 \n     *             indicates that the collateral is native Eth).\n     * @param quote The ERC20 address of the quote token collateral in the pair.\n     * @param baseFlow The amount of flow associated with the base side of the pair. \n     *                 Negative for credits paid to user, positive for debits.\n     * @param quoteFlow The flow associated with the quote side of the pair.\n     * @param reserveFlags Bitwise flags to indicate whether the base and/or quote flows\n     *                     should be settled from caller's surplus collateral */\n    function settleFlows (address base, address quote, int128 baseFlow, int128 quoteFlow,\n                          uint8 reserveFlags) internal {\n        (address debitor, address creditor) = agentsSettle();\n        settleFlat(debitor, creditor, base, baseFlow, quote, quoteFlow, reserveFlags);\n    }\n\n    /* @notice Settle the collateral exchange associated with a the initailization of\n     *         a new pool in the exchange.\n     * @oaran recv The address that will be covering any debits associated with the\n     *             initialization of the pool.\n     * @param base The ERC20 address of the base token collateral in the pair (if 0x0 \n     *             indicates that the collateral is native Eth).\n     * @param baseFlow The amount of flow associated with the base side of the pair. \n     *                 By convention negative for credits paid to user, positive for debits,\n     *                 but will always be positive/debit for this operation.\n     * @param quote The ERC20 address of the quote token collateral in the pair.\n     * @param quoteFlow The flow associated with the quote side of the pair. */\n    function settleInitFlow (address recv,\n                             address base, int128 baseFlow,\n                             address quote, int128 quoteFlow) internal {\n        (uint256 baseSnap, uint256 quoteSnap) = snapOpenBalance(base, quote);\n        settleFlat(recv, recv, base, baseFlow, quote, quoteFlow, BOTH_RESERVE_FLAGS);\n        assertCloseMatches(base, baseSnap, baseFlow);\n        assertCloseMatches(quote, quoteSnap, quoteFlow);\n    }\n\n    /* @notice Settles the collateral exchanged associated with the flow in a single \n     *         pair.\n     * @dev    This must only be used when no other pairs settle in the transaction. */\n    function settleFlat (address debitor, address creditor,\n                         address base, int128 baseFlow,\n                         address quote, int128 quoteFlow, uint8 reserveFlags) private {\n        if (base.isEtherNative()) {\n            transactEther(debitor, creditor, baseFlow, useReservesBase(reserveFlags));\n        } else {\n            transactToken(debitor, creditor, baseFlow, base,\n                          useReservesBase(reserveFlags));\n        }\n\n        // Because Ether native trapdoor is 0x0 address, and because base is always\n        // smaller of the two addresses, native ETH will always appear on the base\n        // side.\n        transactToken(debitor, creditor, quoteFlow, quote,\n                      useReservesQuote(reserveFlags));\n    }\n\n    function useReservesBase (uint8 reserveFlags) private pure returns (bool) {\n        return reserveFlags & BASE_RESERVE_FLAG > 0;\n    }\n    \n    function useReservesQuote (uint8 reserveFlags) private pure returns (bool) {\n        return reserveFlags & QUOTE_RESERVE_FLAG > 0;\n    }\n\n    uint8 constant NO_RESERVE_FLAGS = 0x0;\n    uint8 constant BASE_RESERVE_FLAG = 0x1;\n    uint8 constant QUOTE_RESERVE_FLAG = 0x2;    \n    uint8 constant BOTH_RESERVE_FLAGS = 0x3;\n\n    /* @notice Performs check to make sure the new balance matches the expected \n     * transfer amount. */\n    function assertCloseMatches (address token, uint256 open, int128 expected)\n        private view {\n        if (token != address(0)) {            \n            uint256 close = IERC20Minimal(token).balanceOf(address(this));\n            require(close >= open && expected >= 0 &&\n                    close - open >= uint128(expected), \"TD\");\n        }\n    }\n\n    /* @notice Snapshots the DEX contract's ERC20 token balance at call time. */\n    function snapOpenBalance (address base, address quote) private view returns\n        (uint256 openBase, uint256 openQuote) {\n        openBase = base == address(0) ? 0 :\n            IERC20Minimal(base).balanceOf(address(this));\n        openQuote = IERC20Minimal(quote).balanceOf(address(this));\n    }\n\n    /* @notice Given a pre-determined amount of flow, settles according to collateral \n     *         type and settlement specification. */\n    function pumpFlow (address debitor, address creditor, int128 flow,\n                       address token, bool useReserves)\n        private returns (int128) {\n        if (token.isEtherNative()) {\n            return flow;\n        } else {\n            transactToken(debitor, creditor, flow, token, useReserves);\n            return 0;\n        }\n    }\n\n    function querySurplus (address user, address token) internal view returns (uint128) {\n        bytes32 key = tokenKey(user, token);\n        return userBals_[key].surplusCollateral_;\n    }\n\n    /* @notice Returns true if the flow represents a debit owed from the user to the\n     *         exchange. */\n    function isDebit (int128 flow) private pure returns (bool) {\n        return flow > 0;\n    }\n    \n    /* @notice Returns true if the flow represents a credit owed from the exchange to the\n     *         user. */\n    function isCredit (int128 flow) private pure returns (bool) {\n        return flow < 0;\n    }\n\n    /* @notice Called to settle a net balance of native Ether.\n     * @dev Becaue this settles against msg.value, it's very important to *never* call\n     *      this twice in any single transaction, to avoid double-spend.\n     *\n     * @param debitor The address to collect any net debit from.\n     * @param creditor The address to pay out any net credit to.\n     * @param flow The total net balance to be settled. Negative indicates credit to the\n     *             user. Positive debit to the exchange.\n     * @para useReserves If true, any settlement is first done against the user's surplus\n     *                   collateral account at the exchange rather than sending Ether. */\n    function transactEther (address debitor, address creditor,\n                            int128 flow, bool useReserves)\n        private {\n        // This is the only point in a standard transaction where msg.value is accessed.\n        uint128 recvEth = popMsgVal();\n        if (flow != 0) {\n            transactFlow(debitor, creditor, flow, address(0), recvEth, useReserves);\n        } else {\n            refundEther(creditor, recvEth);\n        }\n    }\n\n    /* @notice Called to settle a net balance of ERC20 tokens\n     * @dev transactEther Unlike transactEther this can be called multiple times, even\n     *      on the same token.\n     *\n     * @param debitor The address to collect any net debit from.\n     * @param creditor The address to pay out any net credit to.\n     * @param flow The total net balance to be settled. Negative indicates credit to the\n     *             user. Positive debit to the exchange.\n     * @param token The address of the token's ERC20 tracker.\n     * @para useReserves If true, any settlement is first done against the user's surplus\n     *                   collateral account at the exchange. */\n    function transactToken (address debitor, address creditor, int128 flow,\n                           address token, bool useReserves) private {\n        require(!token.isEtherNative());\n        // Since this is a token settlement, we defer booking any native ETH in msg.value\n        uint128 bookedEth = 0;\n        transactFlow(debitor, creditor, flow, token, bookedEth, useReserves);\n    }\n\n    /* @notice Handles the single sided settlement of a token or native ETH flow. */\n    function transactFlow (address debitor, address creditor,\n                           int128 flow, address token,\n                           uint128 bookedEth, bool useReserves) private {\n        if (isDebit(flow)) {\n            debitUser(debitor, uint128(flow), token, bookedEth, useReserves);\n        } else if (isCredit(flow)) {\n            creditUser(creditor, uint128(-flow), token, bookedEth, useReserves);\n        }           \n    }\n\n    /* @notice Collects a collateral debit from the user depending on the asset type\n     *         and the settlement specifcation. */\n    function debitUser (address recv, uint128 value, address token,\n                        uint128 bookedEth, bool useReserves) private {\n        if (useReserves) {\n            uint128 remainder = debitSurplus(recv, value, token);\n            debitRemainder(recv, remainder, token, bookedEth);\n        } else {\n            debitTransfer(recv, value, token, bookedEth);\n        }\n    }\n\n    /* @notice Collects the remaining debit (if any) after the user's surplus collateral\n     *         balance has been exhausted. */\n    function debitRemainder (address recv, uint128 remainder, address token,\n                             uint128 bookedEth) private {\n        if (remainder > 0) {\n            debitTransfer(recv, remainder, token, bookedEth);\n        } else if (token.isEtherNative()) {\n            refundEther(recv, bookedEth);\n        }\n    }\n\n    /* @notice Pays out a collateral credit to the user depending on asset type and \n     *         settlement specification. */\n    function creditUser (address recv, uint128 value, address token,\n                         uint128 bookedEth, bool useReserves) private {\n        if (useReserves) {\n            creditSurplus(recv, value, token);\n            creditRemainder(recv, token, bookedEth);\n        } else {\n            creditTransfer(recv, value, token, bookedEth);\n        }\n    }\n\n    /* @notice Handles any refund necessary after a credit has been paid to the user's \n     *         surplus collateral balance. */\n    function creditRemainder (address recv, address token, uint128 bookedEth) private {\n        if (token.isEtherNative()) {\n            refundEther(recv, bookedEth);\n        }\n    }\n\n    /* @notice Settles a credit with an external transfer to user. */\n    function creditTransfer (address recv, uint128 value, address token,\n                             uint128 bookedEth) internal {\n        if (token.isEtherNative()) {\n            payEther(recv, value, bookedEth);\n        } else {\n            TransferHelper.safeTransfer(token, recv, value);\n        }\n    }\n\n    /* @notice Settles a debit with an external transfer from user. */\n    function debitTransfer (address recv, uint128 value, address token,\n                            uint128 bookedEth) internal {\n        if (token.isEtherNative()) {\n            collectEther(recv, value, bookedEth);\n        } else {\n            collectToken(recv, value, token);\n        }\n    }\n\n    /* @notice Pays a native Ethereum credit to the user (and refunds any overpay in\n     *         the transction, since by definition they have no debit.) */\n    function payEther (address recv, uint128 value, uint128 overpay) private {\n        TransferHelper.safeEtherSend(recv, value + overpay);\n    }\n\n    /* @notice Collects a debt in the form of native Ether. Since the only way to pay\n     *         Ether is as msg.value, this function checks that's sufficient to cover\n     *         the debt and pays the difference as a refund.\n     * @dev Because of the risk of double-spend, this must *never* be called more than\n     *      once in a transaction.\n     * @param recv The address to send any over-payment refunds to.\n     * @param value The amount of Ether owed to the exchange. msg.value must exceed\n     *              this threshold.\n     * @param paidEth The amount of Ether paid by the user in this transaction (usually\n     *                msg.value) */\n    function collectEther (address recv, uint128 value, uint128 paidEth) private {\n        require(paidEth >= value, \"EC\");\n        uint128 overpay = paidEth - value;\n        refundEther(recv, overpay);\n    }\n\n    /* @notice Refunds any overpaid native Eth (if any) */\n    function refundEther (address recv, uint128 overpay) private {\n        if (overpay > 0) {\n            TransferHelper.safeEtherSend(recv, overpay);\n        }\n    }\n\n    /* @notice Collects a token debt from a specfic debtor.\n     * @dev    Note that this function does *not* assert that the post-transfer balance\n     *         is correct. SdexSwap is not safe to use for any fee-on-transfer tokens\n     *         or any other tokens that break ERC20 transfer functionality.\n     *\n     * @param recv The address of the debtor being collected from.\n     * @param value The total amount of tokens being collected.\n     * @param token The address of the ERC20 token tracker. */\n    function collectToken (address recv, uint128 value, address token) private {\n        TransferHelper.safeTransferFrom(token, recv, address(this), value);\n    }\n\n    /* @notice Credits a user's surplus collateral account at the exchange (instead of\n     *         directly sending the tokens to their address) */\n    function creditSurplus (address recv, uint128 value, address token) private {\n        bytes32 key = tokenKey(recv, token);\n        userBals_[key].surplusCollateral_ += value;\n    }\n\n    /* @notice Debits the tokens owed from the user's pre-existing surplus collateral\n     *         balance at the exchange.\n     * @return remainder The amount of the debit that cannot be satisfied by surplus\n     *                   collateral alone (0 othersize). */\n    function debitSurplus (address recv, uint128 value, address token) private\n        returns (uint128 remainder) {\n        bytes32 key = tokenKey(recv, token);\n        UserBalance storage bal = userBals_[key];\n        uint128 balance = bal.surplusCollateral_;\n        \n        if (balance > value) {\n            bal.surplusCollateral_ -= value;\n        } else {\n            bal.surplusCollateral_ = 0;\n            remainder = value - balance;\n        }\n    }\n\n    /* @notice Returns true if the net settled flow is equal or better to the user's\n     *         minimum expected amount. (Otherwise upstream should revert the tx.) */     \n    function passesLimit (int128 flow, int128 limitQty)\n        private pure returns (bool) {\n        return flow <= limitQty;\n    }\n\n    /* @notice If true, determines that the settlement flow should be ignored because\n     *         it's economically meaningless and not worth transacting. */\n    function moreThanDust (int128 flow, uint128 dustThresh)\n        private pure returns (bool) {\n        if (isDebit(flow)) {\n            return true;\n        } else {\n            return uint128(-flow) > dustThresh;\n        }\n    }\n\n}\n\n"
    },
    "contracts/mixins/StorageLayout.sol": {
      "content": "// SPDX-License-Identifier: GPL-3                                                          \npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport '../libraries/Directives.sol';\nimport '../libraries/PoolSpecs.sol';\nimport '../libraries/PriceGrid.sol';\nimport '../libraries/KnockoutLiq.sol';\n\n/* @title Storage layout base layer\n * \n * @notice Only exists to enforce a single consistent storage layout. Not\n *    designed to be externally used. All storage in any SdexSwap contract\n *    is defined here. That allows easy use of delegatecall() to move code\n *    over the 24kb into proxy contracts.\n *\n * @dev Any contract or mixin with local defined storage variables *must*\n *    define those storage variables here and inherit this mixin. Failure\n *    to do this may lead to storage layout inconsistencies between proxy\n *    contracts. */\ncontract StorageLayout {\n\n    // Re-entrant lock. Should always be reset to 0x0 after the end of every\n    // top-level call. Any top-level call should fail on if this value is non-\n    // zero.\n    //\n    // Inside a call this address is always set to the beneficial owner that\n    // the call is being made on behalf of. Therefore any positions, tokens,\n    // or liquidity can only be accessed if and only if they're owned by the\n    // value lockHolder_ is currently set to.\n    //\n    // In the case of third party relayer or router calls, this value should\n    // always be set to the *client* that the call is being made for, and never\n    // the msg.sender caller that is acting on the client behalf's. (Of course\n    // for security, third party calls made on a client's behalf must always\n    // be authorized by the client either by pre-approval or signature.)\n    address internal lockHolder_;\n\n    // Indicates whether a given protocolCmd() call is operating in escalated\n    // privileged mode. *Must* always be reset to false after every call.\n    bool internal sudoMode_;\n\n    bool internal msgValSpent_;\n\n    // If set to false, then the embedded hot-path (swap()) is not enabled and\n    // users must use the hot proxy for the hot-path. By default set to true.\n    bool internal hotPathOpen_;\n    \n    bool internal inSafeMode_;\n\n    // The protocol take rate for relayer tips. Represented in 1/256 fractions\n    uint8 internal relayerTakeRate_;\n\n    // Slots for sidecar proxy contracts\n    address[65536] internal proxyPaths_;\n        \n    // Address of the current dex protocol authority. Can be transferred\n    address internal authority_;\n\n    /**************************************************************/\n    // LevelBook\n    /**************************************************************/\n    struct BookLevel {\n        uint96 bidLots_;\n        uint96 askLots_;\n        uint64 feeOdometer_;\n    }\n    mapping(bytes32 => BookLevel) internal levels_;\n    /**************************************************************/\n\n    \n    /**************************************************************/\n    // Knockout Counters\n    /**************************************************************/\n    mapping(bytes32 => KnockoutLiq.KnockoutPivot) internal knockoutPivots_;\n    mapping(bytes32 => KnockoutLiq.KnockoutMerkle) internal knockoutMerkles_;\n    mapping(bytes32 => KnockoutLiq.KnockoutPos) internal knockoutPos_;\n    /**************************************************************/\n\n    \n    /**************************************************************/\n    // TickCensus\n    /**************************************************************/\n    mapping(bytes32 => uint256) internal mezzanine_;\n    mapping(bytes32 => uint256) internal terminus_;\n    /**************************************************************/\n    \n\n    /**************************************************************/\n    // PoolRegistry\n    /**************************************************************/\n    mapping(uint256 => PoolSpecs.Pool) internal templates_;\n    mapping(bytes32 => PoolSpecs.Pool) internal pools_;\n    mapping(address => PriceGrid.ImproveSettings) internal improves_;\n    uint128 internal newPoolLiq_;\n    uint8 internal protocolTakeRate_;\n    /**************************************************************/\n\n    \n    /**************************************************************/\n    // ProtocolAccount\n    /**************************************************************/\n    mapping(address => uint128) internal feesAccum_;\n    /**************************************************************/\n\n\n    /**************************************************************/\n    // PositionRegistrar\n    /**************************************************************/\n    struct RangePosition {\n        uint128 liquidity_;\n        uint64 feeMileage_;\n        uint32 timestamp_;\n        bool atomicLiq_;\n    }\n\n    struct RangePosition72 {\n        uint128 liquidity_;\n        uint72 feeMileage_;\n        uint32 timestamp_;\n        bool atomicLiq_;\n    }\n\n    struct AmbientPosition {\n        uint128 seeds_;\n        uint32 timestamp_;\n    }\n    \n    mapping(bytes32 => RangePosition) internal positions_;\n    mapping(bytes32 => AmbientPosition) internal ambPositions_;\n    /**************************************************************/\n\n\n    /**************************************************************/\n    // LiquidityCurve\n    /**************************************************************/\n    mapping(bytes32 => CurveMath.CurveState) internal curves_;\n    /**************************************************************/\n\n    \n    /**************************************************************/\n    // UserBalance settings\n    /**************************************************************/\n    struct UserBalance {\n        // Multiple loosely related fields are grouped together to allow\n        // off-chain users to optimize calls to minimize cold SLOADS by\n        // hashing needed data to the same slots.\n        uint128 surplusCollateral_;\n        uint32 nonce_;\n        uint32 agentCallsLeft_;\n    }\n    \n    mapping(bytes32 => UserBalance) internal userBals_;\n    /**************************************************************/\n\n    address treasury_;\n    uint64 treasuryStartTime_;\n\n    // Since take rate is represented in 1/256, this represents a maximum possible take \n    // rate of 50%.\n    uint8 MAX_TAKE_RATE = 128;\n\n    mapping(bytes32 => RangePosition72) internal positions72_;\n}\n\n/* @notice Contains the storage or storage hash offsets of the fields and sidecars\n *         in StorageLayer.\n *\n * @dev Note that if the struct of StorageLayer changes, these slot locations *will*\n *      change, and the values below will have to be manually updated. */\nlibrary SdexSlots {\n\n    // Slot location of storage slots and/or hash map storage slot offsets. Values below\n    // can be used to directly read state in SdexSwapDex by other contracts.\n    uint constant public AUTHORITY_SLOT = 0;\n    uint constant public LVL_MAP_SLOT = 65538;\n    uint constant public KO_PIVOT_SLOT = 65539;\n    uint constant public KO_MERKLE_SLOT = 65540;\n    uint constant public KO_POS_SLOT = 65541;\n    uint constant public MEZZ_TICK_SLOT = 65542;\n    uint constant public TERMINUS_TICK_SLOT = 65543;\n    uint constant public POOL_TEMPL_SLOT = 65544;\n    uint constant public POOL_PARAM_SLOT = 65545;\n    uint constant public FEE_MAP_SLOT = 65548;\n    uint constant public POS_MAP_SLOT = 65549;\n    uint constant public AMB_MAP_SLOT = 65550;\n    uint constant public CURVE_MAP_SLOT = 65551;\n    uint constant public BAL_MAP_SLOT = 65552;\n    uint constant public POS_MAP_SLOT_72 = 65554;\n\n        \n    // The slots of the currently attached sidecar proxy contracts. These are set by\n    // covention and should be expanded over time as more sidecars are installed. For\n    // backwards compatibility, upgraders should never break existing interface on\n    // a pre-existing proxy sidecar.\n    uint16 constant BOOT_PROXY_IDX = 0;\n    uint16 constant SWAP_PROXY_IDX = 1;\n    uint16 constant LP_PROXY_IDX = 128;\n    uint16 constant COLD_PROXY_IDX = 3;\n    uint16 constant LONG_PROXY_IDX = 130;\n    uint16 constant MICRO_PROXY_IDX = 131;\n    uint16 constant MULTICALL_PROXY_IDX = 6;\n    uint16 constant KNOCKOUT_LP_PROXY_IDX = 7;\n    uint16 constant FLAG_CROSS_PROXY_IDX = 3500;\n    uint16 constant SAFE_MODE_PROXY_PATH = 9999;\n\n    // The slots below should were used for proxy contracts by previous deployments. \n    // These slots should not be re-used for backwards compatibility.\n\n}\n\n// Not used in production. Just used so we can easily check struct size in hardhat.\ncontract StoragePrototypes is StorageLayout {\n    UserBalance bal_;\n    CurveMath.CurveState curve_;\n    RangePosition pos_;\n    AmbientPosition amb_;\n    BookLevel lvl_;\n}\n"
    },
    "contracts/mixins/TickCensus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3                                         \npragma solidity 0.8.19;\n\nimport '../libraries/BitMath.sol';\nimport '../libraries/Bitmaps.sol';\nimport '../libraries/TickMath.sol';\nimport './StorageLayout.sol';\n\n/* @title Tick census mixin.\n * \n * @notice Tracks which tick indices have an active liquidity bump, making it gas\n *   efficient for random read and writes, and to find the next bump tick boundary\n *   on the curve. \n * \n * @dev Note that this mixin works with the full set of possible int24 values.\n *      Whereas other parts of the protocol set a MIN_TICK and MAX_TICK that are\n *      that well within the type bounds of int24. It's the responsibility of\n *      calling code to assure that ticks being set are within the MIN_TICK and\n *      MAX_TICK, and this library does *not* provide those checks. */\ncontract TickCensus is StorageLayout {\n    using Bitmaps for uint256;\n    using Bitmaps for int24;\n\n    /* Tick positions are stored in three layers of 8-bit/256-slot bitmaps. Recursively\n     * they indicate whether any given 24-bit tick index is active.\n\n     * The first layer (lobby) represents the 8-bit tick root. If we did store this\n     * layer, we'd only need a single 256-bit bitmap per pool. However we do *not*\n     * store this layer, because it adds an unnecessary SLOAD/SSTORE operation on\n     * almost all operations. Instead users can query this layer by checking whether\n     * mezzanine key is set for each bit. The tradeoff is that lobby bitmap queries\n     * are no longer O(1) random access but O(N) seeks. However at most there are 256\n     * SLOAD on a lobby-layer seek, and spills at the lobby layer are rare (moving \n     * between multiple lobby bits requires a 65,000% price change). This gas tradeoff\n     *  is virtually always justified. \n     *\n     * The second layer (mezzanine) maps whether each 16-bit tick root is set. An \n     * entry will be set if and only if *any* tick index in the 8-bit range is set. \n     * Because there are 256^2 slots, this is represented as a map from the first 8-\n     * bits in the root to individual 8-bit/256-slot bitmaps for the middle 8-bits \n     * at that root. \n     *\n     * The final layer (terminus) directly maps whether individual tick indices are\n     * set. Because there are 256^3 possible slots, this is represnted as a mapping \n     * from the first 16-bit tick root to individual 8-bit/256-slot bitmaps of the \n     * terminal 8-bits within that root. */\n\n    /* @notice Returns the associated bitmap for the terminus position (bottom layer) \n     *         of the tick index. \n     * @param poolIdx The hash key associated with the pool being queried.\n     * @param tick A price tick index within the neighborhood that we want the bitmap for.\n     * @return The bitmap of the 256-tick neighborhood. */\n    function terminusBitmap (bytes32 poolIdx, int24 tick)\n        internal view returns (uint256) {\n        bytes32 idx = encodeTerm(poolIdx, tick);\n        return terminus_[idx];\n    }\n    \n    /* @notice Returns the associated bitmap for the mezzanine position (middle layer) \n     *         of the tick index.\n     * @param poolIdx The hash key associated with the pool being queried.\n     * @param tick A price tick index within the neighborhood that we want the bitmap for.\n     * @return The mezzanine bitmap of the 65536-tick neighborhood. */\n    function mezzanineBitmap (bytes32 poolIdx, int24 tick)\n        internal view returns (uint256) {\n        bytes32 idx = encodeMezz(poolIdx, tick);\n        return mezzanine_[idx];\n    }\n\n    /* @notice Returns true if the tick index is currently set. Indicates an tick exists\n     *         at that index. \n     * @param poolIdx The hash key associated with the pool being queried.\n     * @param tick The price tick that we're querying. */\n    function hasTickBookmark (bytes32 poolIdx, int24 tick)\n        internal view returns (bool) {\n        uint256 bitmap = terminusBitmap(poolIdx, tick);\n        uint8 term = tick.termBit();\n        return bitmap.isBitSet(term);\n    }\n\n    /* @notice Mark the tick index as active.\n     * @dev Idempotent. Can be called repeatedly on previously initialized ticks.\n     * @param poolIdx The hash key associated with the pool being queried.\n     * @param tick The price tick that we're marking as enabled. */\n    function bookmarkTick (bytes32 poolIdx, int24 tick)\n        internal {\n        uint256 mezzMask = 1 << tick.mezzBit();\n        uint256 termMask = 1 << tick.termBit();\n        mezzanine_[encodeMezz(poolIdx, tick)] |= mezzMask;\n        terminus_[encodeTerm(poolIdx, tick)] |= termMask;\n    }\n\n    /* @notice Unset the tick index as no longer active. Take care of any book keeping\n     *   related to the recursive bitmap levels.\n     * @dev Idempontent. Can be called repeatedly even if tick was previously \n     *   forgotten.\n     * @param poolIdx The hash key associated with the pool being queried.\n     * @param tick The price tick that we're marking as disabled. */\n    function forgetTick (bytes32 poolIdx, int24 tick) internal {\n        uint256 mezzMask = ~(1 << tick.mezzBit());\n        uint256 termMask = ~(1 << tick.termBit());\n\n        bytes32 termIdx = encodeTerm(poolIdx, tick);\n        uint256 termUpdate = terminus_[termIdx] & termMask;\n        terminus_[termIdx] = termUpdate;\n        \n        if (termUpdate == 0) {\n            bytes32 mezzIdx = encodeMezz(poolIdx, tick);\n            uint256 mezzUpdate = mezzanine_[mezzIdx] & mezzMask;\n            mezzanine_[mezzIdx] = mezzUpdate;\n        }\n    }\n\n    /* @notice Finds an inner-bound conservative liquidity tick boundary based on\n     *   the terminus map at a starting tick point. Because liquidity actually bumps\n     *   at the bottom of the tick, the result is assymetric on direction. When seeking\n     *   an upper barrier, it'll be the tick that we cross into. For lower barriers, it's\n     *   the tick that we cross out of, and therefore could even be the starting tick.\n     * \n     * @dev For gas efficiency this method only looks at a previously loaded terminus\n     *   bitmap. Often for moves of that size we don't even need to look past the \n     *   terminus boundary. So there's no point doing a mezzanine layer seek unless we\n     *   end up needing it.\n     *\n     * @param poolIdx The hash key associated with the pool being queried.\n     * @param isUpper - If true indicates that we're looking for an upper boundary.\n     * @param startTick - The current tick index that we're finding the boundary from.\n     *\n     * @return boundTick - The tick index that we can conservatively move to without \n     *    potentially hitting any currently active liquidity bump points.\n     * @return isSpill - If true indicates that the boundary represents the end of the\n     *    inner terminus bitmap neighborhood. Based on this we have to actually check whether\n     *     we've reached teh true end of the liquidity range, or just the end of the known\n     *     neighborhood.  */\n    function pinBitmap (bytes32 poolIdx,\n                        bool isUpper, int24 startTick)\n        internal view returns (int24 boundTick, bool isSpill) {\n        uint256 termBitmap = terminusBitmap(poolIdx, startTick);\n        uint16 shiftTerm = startTick.termBump(isUpper);\n        int16 tickMezz = startTick.mezzKey();\n        (boundTick, isSpill) = pinTermMezz\n            (isUpper, shiftTerm, tickMezz, termBitmap);\n    }\n\n    /* @notice Formats the tick bit horizon index and sets the flag for whether it\n    *          represents whether the seeks spills over the terminus neighborhood */\n    function pinTermMezz (bool isUpper, uint16 shiftTerm, int16 tickMezz,\n                          uint256 termBitmap)\n        private pure returns (int24 nextTick, bool spillBit) {\n        (uint8 nextTerm, bool spillTrunc) =\n            termBitmap.bitAfterTrunc(shiftTerm, isUpper);\n        spillBit = doesSpillBit(isUpper, spillTrunc, termBitmap);\n        nextTick = spillBit ?\n            spillOverPin(isUpper, tickMezz) :\n            Bitmaps.weldMezzTerm(tickMezz, nextTerm);\n    }\n\n    /* @notice Returns true if the tick seek reaches the end of the inner terminus \n     *      bitmap neighborhood. If that happens, it's like reaching the end of the map.\n     *      It's returned as the boundary point, but the the user must be aware that the tick\n     *      may or may not represent an active liquidity tick and check accordingly. */\n    function doesSpillBit (bool isUpper, bool spillTrunc, uint256 termBitmap)\n        private pure returns (bool spillBit) {\n        if (isUpper) {\n            spillBit = spillTrunc;\n        } else {\n            bool bumpAtFloor = termBitmap.isBitSet(0);\n            spillBit = bumpAtFloor ? false :\n                spillTrunc;\n        }\n    }\n\n    /* @notice Formats the censored horizon tick index when the seek has spilled out of \n     *         the terminus bitmap neighborhood. */\n    function spillOverPin (bool isUpper, int16 tickMezz) private pure returns (int24) {\n        if (isUpper) {\n            return tickMezz == Bitmaps.zeroMezz(isUpper) ?\n                Bitmaps.zeroTick(isUpper) :\n                Bitmaps.weldMezzTerm(tickMezz + 1, Bitmaps.zeroTerm(!isUpper));\n        } else {\n            return Bitmaps.weldMezzTerm(tickMezz, 0);\n        }\n    }\n\n\n    /* @notice Determines the next tick bump boundary tick starting using recursive\n     *   bitmap lookup. Follows the same up/down assymetry as pinBitmap(). Upper bump\n     *   is the tick being crossed *into*, lower bump is the tick being crossed *out of*\n     *\n     * @dev This is a much more gas heavy operation because it recursively looks \n     *   though all three layers of bitmaps. It should only be called if pinBitmap()\n     *   can't find the boundary in the terminus layer.\n     *\n     * @param poolIdx The hash key associated with the pool being queried.\n     * @param borderTick - The current tick that we want to seek a tick liquidity\n     *   boundary from. For defined behavior this tick must occur at the border of\n     *   terminus bitmap. For lower borders, must be the tick from the start of the byte.\n     *   For upper borders, must be the tick past the end of the byte. Any spill result \n     *   from pinTermMezz() is safe.\n     * @param isUpper - The direction of the boundary. If true seek an upper boundary.\n     *\n     * @return (int24) - The tick index of the next tick boundary with an active \n     *   liquidity bump. The result is assymetric boundary for upper/lower ticks. */\n    function seekMezzSpill (bytes32 poolIdx, int24 borderTick, bool isUpper)\n        internal view returns (int24) {\n        if (isUpper && borderTick == type(int24).max) { return type(int24).max; }\n        if (!isUpper && borderTick == type(int24).min) { return type(int24).min; }\n\n        (uint8 lobbyBorder, uint8 mezzBorder) = rootsForBorder(borderTick, isUpper);\n\n        // Most common case is that the next neighboring bitmap on the border has\n        // an active tick. So first check here to save gas in the hotpath.\n        (int24 pin, bool spills) =\n            seekAtTerm(poolIdx, lobbyBorder, mezzBorder, isUpper);\n        if (!spills) { return pin; }                                      \n\n        // Next check to see if we can find a neighbor in the mezzanine. This almost\n        // always happens except for very sparse pools. \n        (pin, spills) =\n            seekAtMezz(poolIdx, lobbyBorder, mezzBorder, isUpper);\n        if (!spills) { return pin; }\n\n        // Finally iterate through the lobby layer.\n        return seekOverLobby(poolIdx, lobbyBorder, isUpper);\n    }\n\n    /* @notice Seeks the next tick bitmap by searching in the adjacent neighborhood. */\n    function seekAtTerm (bytes32 poolIdx, uint8 lobbyBit, uint8 mezzBit, bool isUpper)\n        private view returns (int24, bool) {\n        uint256 neighborBitmap = terminus_\n            [encodeTermWord(poolIdx, lobbyBit, mezzBit)];\n        (uint8 termBit, bool spills) = neighborBitmap.bitAfterTrunc(0, isUpper);\n        if (spills) { return (0, true); }\n        return (Bitmaps.weldLobbyPosMezzTerm(lobbyBit, mezzBit, termBit), false);\n    }\n\n    /* @notice Seeks the next tick bitmap by searching in the current mezzanine \n     *         neighborhood.\n     * @dev This covers a span of 65 thousand ticks, so should capture most cases. */\n    function seekAtMezz (bytes32 poolIdx, uint8 lobbyBit,\n                         uint8 mezzBorder, bool isUpper)\n        private view returns (int24, bool) {\n        uint256 neighborMezz = mezzanine_\n            [encodeMezzWord(poolIdx, lobbyBit)];\n        uint8 mezzShift = Bitmaps.bitRelate(mezzBorder, isUpper);\n        (uint8 mezzBit, bool spills) = neighborMezz.bitAfterTrunc(mezzShift, isUpper);\n        if (spills) { return (0, true); }\n        return seekAtTerm(poolIdx, lobbyBit, mezzBit, isUpper);\n    }\n\n    /* @notice Used when the tick is not contained in the mezzanine. We walk through the\n     *         the mezzanine tick bitmaps one by one until we find an active tick bit. */\n    function seekOverLobby (bytes32 poolIdx, uint8 lobbyBit, bool isUpper)\n        private view returns (int24) {\n        return isUpper ?\n            seekLobbyUp(poolIdx, lobbyBit) :\n            seekLobbyDown(poolIdx, lobbyBit);\n    }\n\n    /* Unlike the terminus and mezzanine layer, we don't store a bitmap at the lobby\n     * layer. Instead we iterate through the top-level bits until we find an active\n     * mezzanine. This requires a maximum of 256 iterations, and can be gas intensive.\n     * However moves at this level represent 65,000% price changes and are very rare. */\n    function seekLobbyUp (bytes32 poolIdx, uint8 lobbyBit)\n        private view returns (int24) {\n        uint8 MAX_MEZZ = 0;\n        unchecked {\n            // Unchecked because we want idx to wrap around to 0, to check all 256 bits\n            for (uint8 i = lobbyBit + 1; i > 0; ++i) {\n                (int24 tick, bool spills) = seekAtMezz(poolIdx, i, MAX_MEZZ, true);\n                if (!spills) { return tick; }\n            }\n        }\n        return Bitmaps.zeroTick(true);\n    }\n\n    /* Same logic as seekLobbyUp(), but the inverse direction. */\n    function seekLobbyDown (bytes32 poolIdx, uint8 lobbyBit)\n        private view returns (int24) {\n        uint8 MIN_MEZZ = 255;\n        unchecked {\n            // Unchecked because we want idx to wrap around to 255, to check all 256 bits\n            for (uint8 i = lobbyBit - 1; i < 255; --i) {\n                (int24 tick, bool spills) = seekAtMezz(poolIdx, i, MIN_MEZZ, false);\n                if (!spills) { return tick; }\n            }\n        }\n        return Bitmaps.zeroTick(false);\n    }\n\n    /* @notice Splits out the lobby bits and the mezzanine bits from the 24-bit price\n     *         tick index associated with the type of border tick used in seekMezzSpill()\n     *         call */\n    function rootsForBorder (int24 borderTick, bool isUpper) private pure\n        returns (uint8 lobbyBit, uint8 mezzBit) {\n        // Because pinTermMezz returns a border *on* the previous bitmap, we need to\n        // decrement by one to get the seek starting point.\n        int24 pinTick = isUpper ? borderTick : (borderTick - 1);\n        lobbyBit = pinTick.lobbyBit();\n        mezzBit = pinTick.mezzBit();\n    }\n\n    /* @notice Encodes the hash key for the mezzanine neighborhood of the tick. */\n    function encodeMezz (bytes32 poolIdx, int24 tick) private pure returns (bytes32) {\n        int8 wordPos = tick.lobbyKey();\n        return keccak256(abi.encodePacked(poolIdx, wordPos)); \n    }\n\n    /* @notice Encodes the hash key for the terminus neighborhood of the tick. */\n    function encodeTerm (bytes32 poolIdx, int24 tick) private pure returns (bytes32) {\n        int16 wordPos = tick.mezzKey();\n        return keccak256(abi.encodePacked(poolIdx, wordPos)); \n    }\n\n    /* @notice Encodes the hash key for the mezzanine neighborhood of the first 8-bits\n     *         of a tick index. (This is all that's needed to determine mezzanine.) */\n    function encodeMezzWord (bytes32 poolIdx, int8 lobbyPos)\n        private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(poolIdx, lobbyPos));  \n    }\n\n    /* @notice Encodes the hash key for the mezzanine neighborhood of the first 8-bits\n     *         of a tick index. (This is all that's needed to determine mezzanine.) */\n    function encodeMezzWord (bytes32 poolIdx, uint8 lobbyPos)\n        private pure returns (bytes32) {\n        return encodeMezzWord(poolIdx, Bitmaps.uncastBitmapIndex(lobbyPos));\n    }\n\n    /* @notice Encodes the hash key for the terminus neighborhood of the first 16-bits\n     *         of a tick index. (This is all that's needed to determine terminus.) */\n    function encodeTermWord (bytes32 poolIdx, uint8 lobbyPos, uint8 mezzPos)\n        private pure returns (bytes32) {\n        int16 mezzIdx = Bitmaps.weldLobbyMezz\n            (Bitmaps.uncastBitmapIndex(lobbyPos), mezzPos);\n        return keccak256(abi.encodePacked(poolIdx, mezzIdx)); \n    }\n}\n\n"
    },
    "contracts/mixins/TradeMatcher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport '../libraries/Directives.sol';\nimport '../libraries/PoolSpecs.sol';\nimport '../libraries/PriceGrid.sol';\nimport '../libraries/SwapCurve.sol';\nimport '../libraries/CurveMath.sol';\nimport '../libraries/CurveRoll.sol';\nimport '../libraries/Chaining.sol';\nimport '../interfaces/ISdexLpConduit.sol';\nimport './PositionRegistrar.sol';\nimport './LiquidityCurve.sol';\nimport './LevelBook.sol';\nimport './KnockoutCounter.sol';\nimport './ProxyCaller.sol';\nimport './AgentMask.sol';\n\n/* @title Trade matcher mixin\n * @notice Provides a unified facility for calling the core atomic trade actions\n *         on a pre-loaded liquidity curve:\n *           1) Mint amibent liquidity\n *           2) Mint range liquidity\n *           3) Burn ambient liquidity\n *           4) Burn range liquidity\n *           5) Swap                                                     */\ncontract TradeMatcher is PositionRegistrar, LiquidityCurve, KnockoutCounter,\n    ProxyCaller {\n\n    using SafeCast for int256;\n    using SafeCast for int128;\n    using SafeCast for uint256;\n    using SafeCast for uint128;\n    using TickMath for uint128;\n    using LiquidityMath for uint96;\n    using LiquidityMath for uint128;\n    using PoolSpecs for PoolSpecs.Pool;\n    using CurveRoll for CurveMath.CurveState;\n    using CurveMath for CurveMath.CurveState;\n    using SwapCurve for CurveMath.CurveState;\n    using Directives for Directives.ConcentratedDirective;\n    using Chaining for Chaining.PairFlow;\n\n    /* @notice Mints ambient liquidity (i.e. liquidity that stays active at every\n     *         price point) on to the curve.\n     * \n     * @param curve The object representing the pre-loaded liquidity curve. Will be\n     *              updated in memory after this call, but it's the caller's \n     *              responsbility to check it back into storage.\n     * @param liqAdded The amount of ambient liquidity being minted represented as\n     *                 sqrt(X*Y) where X,Y are the collateral reserves in a constant-\n     *                 product AMM\n     * @param poolHash The hash indexing the pool this liquidity curve applies to.\n     * @param lpOwner The address of the ISdexLpConduit the LP position will be \n     *                assigned to. (If zero the user will directly own the LP.)\n     *\n     * @return baseFlow The amount of base-side token collateral required by this\n     *                  operations. Will always be positive indicating, a debit from\n     *                  the user to the pool.\n     * @return quoteFlow The amount of quote-side token collateral required by thhis\n     *                   operation. */\n    function mintAmbient (CurveMath.CurveState memory curve, uint128 liqAdded, \n                          bytes32 poolHash, address lpOwner)\n        internal returns (int128 baseFlow, int128 quoteFlow) {\n        uint128 liqSeeds = mintPosLiq(lpOwner, poolHash, liqAdded,\n                                      curve.seedDeflator_);\n        depositConduit(poolHash, liqSeeds, curve.seedDeflator_, lpOwner);\n\n        (uint128 base, uint128 quote) = liquidityReceivable(curve, liqSeeds);\n        (baseFlow, quoteFlow) = signMintFlow(base, quote);\n    }\n\n    /* @notice Like mintAmbient(), but the liquidity is permanetely locked into the pool,\n     *         and therefore cannot be later burned by the user. */\n    function lockAmbient (CurveMath.CurveState memory curve, uint128 liqAdded)\n        internal pure returns (int128, int128) {\n        (uint128 base, uint128 quote) = liquidityReceivable(curve, liqAdded);\n        return signMintFlow(base, quote);        \n    }\n\n    /* @notice Burns ambient liquidity from the curve.\n     * \n     * @param curve The object representing the pre-loaded liquidity curve. Will be\n     *              updated in memory after this call, but it's the caller's \n     *              responsbility to check it back into storage.\n     * @param liqAdded The amount of ambient liquidity being minted represented as\n     *                 sqrt(X*Y) where X,Y are the collateral reserves in a constant-\n     *                 product AMM\n     * @param poolHash The hash indexing the pool this liquidity curve applies to.\n     *\n     * @return baseFlow The amount of base-side token collateral returned by this\n     *                  operations. Will always be negative indicating, a credit from\n     *                  the pool to the user.\n     * @return quoteFlow The amount of quote-side token collateral returned by this\n     *                   operation. */\n    function burnAmbient (CurveMath.CurveState memory curve, uint128 liqBurned, \n                          bytes32 poolHash, address lpOwner)\n        internal returns (int128, int128) {\n        uint128 liqSeeds = burnPosLiq(lpOwner, poolHash, liqBurned, curve.seedDeflator_);\n        withdrawConduit(poolHash, liqSeeds, curve.seedDeflator_, lpOwner);\n        \n        (uint128 base, uint128 quote) = liquidityPayable(curve, liqSeeds);\n        return signBurnFlow(base, quote);\n    }\n\n    /* @notice Mints concernated liquidity within a range on to the curve.\n     * \n     * @param curve The object representing the pre-loaded liquidity curve. Will be\n     *              updated in memory after this call, but it's the caller's \n     *              responsbility to check it back into storage.\n     * @param prickTick The tick index of the curve's current price.\n     * @param lowTick The tick index of the lower boundary of the range order.\n     * @param highTick The tick index of the upper boundary of the range order.\n     * @param liqAdded The amount of ambient liquidity being minted represented as\n     *                 sqrt(X*Y) where X,Y are the collateral reserves in a constant-\n     *                 product AMM\n     * @param poolHash The hash indexing the pool this liquidity curve applies to.\n     * @param lpConduit The address of the ISdexLpConduit the LP position will be \n     *                  assigned to. (If zero the user will directly own the LP.)\n     *\n     * @return baseFlow The amount of base-side token collateral required by this\n     *                  operations. Will always be positive indicating, a debit from\n     *                  the user to the pool.\n     * @return quoteFlow The amount of quote-side token collateral required by thhis\n     *                   operation. */\n    function mintRange (CurveMath.CurveState memory curve, int24 priceTick,\n                        int24 lowTick, int24 highTick, uint128 liquidity,\n                        bytes32 poolHash, address lpOwner)\n        internal returns (int128 baseFlow, int128 quoteFlow) {\n        uint72 feeMileage = addBookLiq72(poolHash, priceTick, lowTick, highTick,\n                                       liquidity.liquidityToLots(),\n                                       curve.concGrowth_);\n        \n        mintPosLiq(lpOwner, poolHash, lowTick, highTick,\n                     liquidity, feeMileage);\n        depositConduit(poolHash, lowTick, highTick, liquidity, feeMileage, lpOwner);\n\n        (uint128 base, uint128 quote) = liquidityReceivable\n            (curve, liquidity, lowTick, highTick);\n        (baseFlow, quoteFlow) = signMintFlow(base, quote);\n    }\n\n    /* @notice Burns concernated liquidity within a specific range off of the curve.\n     * \n     * @param curve The object representing the pre-loaded liquidity curve. Will be\n     *              updated in memory after this call, but it's the caller's \n     *              responsbility to check it back into storage.\n     * @param prickTick The tick index of the curve's current price.\n     * @param lowTick The tick index of the lower boundary of the range order.\n     * @param highTick The tick index of the upper boundary of the range order.\n     * @param liqAdded The amount of ambient liquidity being minted represented as\n     *                 sqrt(X*Y) where X,Y are the collateral reserves in a constant-\n     *                 product AMM\n     * @param poolHash The hash indexing the pool this liquidity curve applies to.\n     *\n     * @return baseFlow The amount of base-side token collateral returned by this\n     *                  operations. Will always be negative indicating, a credit from\n     *                  the pool to the user.\n     * @return quoteFlow The amount of quote-side token collateral returned by this\n     *                   operation. */\n    function burnRange (CurveMath.CurveState memory curve, int24 priceTick,\n                        int24 lowTick, int24 highTick, uint128 liquidity,\n                        bytes32 poolHash, address lpOwner)\n        internal returns (int128, int128) {\n        uint72 feeMileage = removeBookLiq72(poolHash, priceTick, lowTick, highTick,\n                                          liquidity.liquidityToLots(),\n                                          curve.concGrowth_);\n        uint64 rewards = burnPosLiq(lpOwner, poolHash, lowTick, highTick, liquidity,\n                                    feeMileage);\n        withdrawConduit(poolHash, lowTick, highTick,\n                        liquidity, feeMileage, lpOwner);\n        (uint128 base, uint128 quote) = liquidityPayable(curve, liquidity, rewards,\n                                                         lowTick, highTick);\n        return signBurnFlow(base, quote);\n    }\n\n    /* @notice Dispatches the call to the ISdexLpConduit with the ambient liquidity \n     *         LP position that was minted. */\n    function depositConduit (bytes32 poolHash, uint128 liqSeeds, uint72 deflator,\n                             address lpConduit) private {\n        // Equivalent to calling concentrated liquidity deposit with lowTick=0 and highTick=0\n        // Since a true range order can never have a width of zero, the receiving deposit\n        // contract should recognize these values as always representing ambient liquidity\n        int24 NA_LOW_TICK = 0;\n        int24 NA_HIGH_TICK = 0;\n        depositConduit(poolHash, NA_LOW_TICK, NA_HIGH_TICK, liqSeeds, deflator, lpConduit);\n    }\n\n    /* @notice Dispatches the call to the ISdexLpConduit with the concentrated liquidity \n     *         LP position that was minted. */\n    function depositConduit (bytes32 poolHash, int24 lowTick, int24 highTick,\n                             uint128 liq, uint72 mileage, address lpConduit) private {\n        if (lpConduit != lockHolder_) {\n            bool doesAccept = ISdexLpConduit(lpConduit).\n                depositSdexLiq(lockHolder_, poolHash, lowTick, highTick, liq, mileage);\n            require(doesAccept, \"LP\");\n        }\n    }\n\n    /* @notice Withdraws and sends ownership of the ambient liquidity to a third party conduit\n     *         explicitly nominated by the caller. */\n    function withdrawConduit (bytes32 poolHash, uint128 liqSeeds, uint72 deflator,\n                              address lpConduit) private {\n        withdrawConduit(poolHash, 0, 0, liqSeeds, deflator, lpConduit);\n    }\n\n    /* @notice Withdraws and sends ownership of the liquidity to a third party conduit\n     *         explicitly nominated by the caller. */\n    function withdrawConduit (bytes32 poolHash, int24 lowTick, int24 highTick,\n                              uint128 liq, uint72 mileage, address lpConduit) private {\n        if (lpConduit != lockHolder_) {\n            bool doesAccept = ISdexLpConduit(lpConduit).\n                withdrawSdexLiq(lockHolder_, poolHash, lowTick, highTick, liq, mileage);\n            require(doesAccept, \"LP\");\n        }\n    }\n\n    /* @notice Mints a new knockout liquidity position, or adds to a previous position, \n     *         and updates the curve and debit flows accordingly.\n     *\n     * @param curve The current state of the liquidity curve.\n     * @param priceTick The 24-bit tick of the pool's current price\n     * @param loc The location of where to mint the knockout liquidity\n     * @param liquidity The total amount of XY=K liquidity to mint.\n     * @param poolHash The hash of the pool the curve applies to\n     * @param knockoutBits The bitwise knockout parameters currently set on the pool.\n     *\n     * @return The incrmental base and quote debit flows from this action. */\n    function mintKnockout (CurveMath.CurveState memory curve, int24 priceTick,\n                           KnockoutLiq.KnockoutPosLoc memory loc,\n                           uint128 liquidity, bytes32 poolHash, uint8 knockoutBits)\n        internal returns (int128 baseFlow, int128 quoteFlow) {\n        addKnockoutLiq(poolHash, knockoutBits, priceTick, curve.concGrowth_, loc,\n                       liquidity.liquidityToLots());\n        \n        (uint128 base, uint128 quote) = liquidityReceivable\n            (curve, liquidity, loc.lowerTick_, loc.upperTick_);\n        (baseFlow, quoteFlow) = signMintFlow(base, quote);\n    }\n\n    /* @notice Burns an existing knockout liquidity position and updates the curve\n     *         and flows accordingly.\n     *\n     * @param curve The current state of the liquidity curve.\n     * @param priceTick The 24-bit tick of the pool's current price\n     * @param loc The location of where to burn the knockout liquidity from\n     * @param liquidity The total amount of XY=K liquidity to mint.\n     * @param poolHash The hash of the pool the curve applies to\n     *\n     * @return The incrmental base and quote debit flows from this action. */\n    function burnKnockout (CurveMath.CurveState memory curve, int24 priceTick,\n                           KnockoutLiq.KnockoutPosLoc memory loc,\n                           uint128 liquidity, bytes32 poolHash)\n        internal returns (int128 baseFlow, int128 quoteFlow) {\n        (, , uint64 rewards) = rmKnockoutLiq(poolHash, priceTick, curve.concGrowth_,\n                                             loc, liquidity.liquidityToLots());\n        \n        (uint128 base, uint128 quote) = liquidityPayable\n            (curve, liquidity, rewards, loc.lowerTick_, loc.upperTick_);\n        (baseFlow, quoteFlow) = signBurnFlow(base, quote);\n    }\n\n    /* @notice Claims a post-knockout liquidity position using the ownership Merkle proof\n     *         supplied by the caller.\n     *\n     * @param curve The current state of the liquidity curve.\n     * @param loc The location of where the post-knockout position was placed\n     * @param root The root of the supplied Merkle proof\n     * @param proof The Merkle proof that combined with the root must match the current\n     *              hash of the knockout slot\n     * @param poolHash The hash of the pool the curve applies to\n     *\n     * @return The incrmental base and quote debit flows from this action. */\n    function claimKnockout (CurveMath.CurveState memory curve, \n                            KnockoutLiq.KnockoutPosLoc memory loc,\n                            uint160 root, uint256[] memory proof, bytes32 poolHash)\n        internal returns (int128 baseFlow, int128 quoteFlow) {\n        (uint96 lots, uint64 rewards) = claimPostKnockout(poolHash, loc, root, proof);\n        uint128 liquidity = lots.lotsToLiquidity();\n        \n        (uint128 base, uint128 quote) = liquidityHeldPayable\n            (curve, liquidity, rewards, loc);\n        (baseFlow, quoteFlow) = signBurnFlow(base, quote);\n    }\n\n    /* @notice Claims a post-knockout liquidity position using the ownership Merkle proof\n     *         supplied by the caller.\n     *\n     * @param curve The current state of the liquidity curve.\n     * @param loc The location of where the post-knockout position was placed\n     * @param root The root of the supplied Merkle proof\n     * @param pivotTime The pivotTime of the knockout slot at the time the position was\n     *                  minted.\n     * @return The incrmental base and quote debit flows from this action. */\n    function recoverKnockout (KnockoutLiq.KnockoutPosLoc memory loc,\n                              uint32 pivotTime, bytes32 poolHash)\n        internal returns (int128 baseFlow, int128 quoteFlow) {\n        uint96 lots = recoverPostKnockout(poolHash, loc, pivotTime);\n        uint128 liquidity = lots.lotsToLiquidity();\n\n        (uint128 base, uint128 quote) = liquidityHeldPayable(liquidity, loc);\n        (baseFlow, quoteFlow) = signBurnFlow(base, quote);\n    }\n\n    /* @notice Harvests the accumulated rewards on a concentrated liquidity position.\n     * \n     * @param curve The object representing the pre-loaded liquidity curve. Will be\n     *              updated in memory after this call, but it's the caller's \n     *              responsbility to check it back into storage.\n     * @param prickTick The tick index of the curve's current price.\n     * @param lowTick The tick index of the lower boundary of the range order.\n     * @param highTick The tick index of the upper boundary of the range order.\n     * @param poolHash The hash indexing the pool this liquidity curve applies to.\n     *\n     * @return baseFlow The amount of base-side token collateral returned by this\n     *                  operations. Will always be negative indicating, a credit from\n     *                  the pool to the user.\n     * @return quoteFlow The amount of quote-side token collateral returned by this\n     *                   operation. */\n    function harvestRange (CurveMath.CurveState memory curve, int24 priceTick,\n                           int24 lowTick, int24 highTick, bytes32 poolHash,\n                           address lpOwner)\n        internal returns (int128, int128) {\n        uint72 feeMileage = clockFeeOdometer72(poolHash, priceTick, lowTick, highTick,\n                                               curve.concGrowth_);\n        uint128 rewards = harvestPosLiq(lpOwner, poolHash,\n                                        lowTick, highTick, feeMileage);\n        withdrawConduit(poolHash, lowTick, highTick, 0, feeMileage, lpOwner);\n        (uint128 base, uint128 quote) = liquidityPayable(curve, rewards);\n        return signBurnFlow(base, quote);\n    }\n    \n    /* @notice Converts the unsigned flow associated with a mint operation to a pair\n     *         net settlement flow. (Will always be positive because a mint requires use\n     *         to pay collateral to the pool.) */\n    function signMintFlow (uint128 base, uint128 quote) private pure\n        returns (int128, int128) {\n        return (base.toInt128Sign(), quote.toInt128Sign());\n    }\n\n    /* @notice Converts the unsigned flow associated with a burn operation to a pair\n     *         net settlement flow. (Will always be negative because a burn requires use\n     *         to pay collateral to the pool.) */\n    function signBurnFlow (uint128 base, uint128 quote) private pure\n        returns (int128, int128){\n        return (-(base.toInt128Sign()), -(quote.toInt128Sign()));\n    }\n\n    /* @notice Executes the pending swap through the order book, adjusting the\n     *         liquidity curve and level book as needed based on the swap's impact.\n     *\n     * @dev This is probably the most complex single function in the codebase. For\n     *      small local moves, which don't cross extant levels in the book, it acts\n     *      like a constant-product AMM curve. For large swaps which cross levels,\n     *      it iteratively re-adjusts the AMM curve on every level cross, and performs\n     *      the necessary book-keeping on each crossed level entry.\n     *\n     * @param accum The accumulator for the flows generated by the executable swap. \n     *              The realized flows on the swap will be written into the memory-based \n     *              accumulator fields of this struct. The caller is responsible for \n     *              ultaimtely paying and collecting those flows.\n     * @param curve The starting liquidity curve state. Any changes created by the \n     *              swap on this struct are updated in memory. But the caller is \n     *              responsible for committing the final state to EVM storage.\n     * @param midTick The price tick associated with the current price on the curve.\n     * @param swap The user specified directive governing the size, direction and limit\n     *             price of the swap to be executed.\n     * @param pool The pool's market specification notably its swap fee rate and the\n     *             protocol take rate. */\n    function sweepSwapLiq (Chaining.PairFlow memory accum,\n                           CurveMath.CurveState memory curve, int24 midTick,\n                           Directives.SwapDirective memory swap,\n                           PoolSpecs.PoolCursor memory pool) internal {\n        require(swap.isBuy_ ? curve.priceRoot_ <= swap.limitPrice_ : \n                              curve.priceRoot_ >= swap.limitPrice_, \"SD\");\n        \n        // Keep iteratively executing more quantity until we either reach our limit price\n        // or have zero quantity left to execute.\n        bool doMore = hasSwapLeft(curve, swap);\n        while (doMore) {\n            // Swap to furthest point we can based on the local bitmap. Don't bother\n            // seeking a bump outside the local neighborhood yet, because we're not sure\n            // if the swap will exhaust the bitmap.\n            (int24 bumpTick, bool spillsOver) = pinBitmap\n                (pool.hash_, swap.isBuy_, midTick);\n            curve.swapToLimit(accum, swap, pool.head_, bumpTick);\n            \n            \n            // The swap can be in one of four states at this point: 1) qty exhausted,\n            // 2) limit price reached, 3) bump or barrier point reached on the curve.\n            // The former two indicate the swap is complete. The latter means we have to\n            // find the next bump point and possibly adjust AMM liquidity.\n            doMore = hasSwapLeft(curve, swap);\n            if (doMore) {\n\n                // The spillsOver variable indicates that we reached stopped because we\n                // reached the end of the local bitmap, rather than actually hitting a\n                // level bump. Therefore we should query the global bitmap, find the next\n                // bump point, and keep swapping across the constant-product curve until\n                // if/when we hit that point.\n                if (spillsOver) {\n                    int24 liqTick = seekMezzSpill(pool.hash_, bumpTick, swap.isBuy_);\n                    bool tightSpill = (bumpTick == liqTick);\n                    bumpTick = liqTick;\n                    \n                    // In some corner cases the local bitmap border also happens to\n                    // be the next bump point. If so, we're done with this inner section.\n                    // Otherwise, we keep swapping since we still have some distance on\n                    // the curve to cover until we reach a bump point.\n                    if (!tightSpill) {\n                        curve.swapToLimit(accum, swap, pool.head_, bumpTick);\n                        doMore = hasSwapLeft(curve, swap);\n                    }\n                }\n                \n                // Perform book-keeping related to crossing the level bump, update\n                // the locally tracked tick of the curve price (rather than wastefully\n                // we calculating it since we already know it), then begin the swap\n                // loop again.\n                if (doMore) {\n                    midTick = knockInTick(accum, bumpTick, curve, swap, pool.hash_);\n                }\n            }\n        }\n    }\n\n    /* @notice Determines if we've terminated the swap execution. I.e. fully exhausted\n     *         the specified swap quantity *OR* hit the directive's limit price. */\n    function hasSwapLeft (CurveMath.CurveState memory curve,\n                          Directives.SwapDirective memory swap)\n        private pure returns (bool) {\n        bool inLimit = swap.isBuy_ ?\n            curve.priceRoot_ < swap.limitPrice_ :\n            curve.priceRoot_ > swap.limitPrice_;\n        return inLimit && (swap.qty_ > 0);\n    }\n\n    /* @notice Performs all the necessary book keeping related to crossing an extant \n     *         level bump on the curve. \n     *\n     * @dev Note that this function updates the level book data structure directly on\n     *      the EVM storage. But it only updates the liquidity curve state *in memory*.\n     *      This is for gas efficiency reasons, as the same curve struct may be updated\n     *      many times in a single swap. The caller must take responsibility for \n     *      committing the final curve state back to EVM storage. \n     *\n     * @params bumpTick The tick index where the bump occurs.\n     * @params isBuy The direction the bump happens from. If true, curve's price is \n     *               moving through the bump starting from a lower price and going to a\n     *               higher price. If false, the opposite.\n     * @params curve The pre-bump state of the local constant-product AMM curve. Updated\n     *               to reflect the liquidity added/removed from rolling through the\n     *               bump.\n     * @param swap The user directive governing the size, direction and limit price of the\n     *             swap to be executed.\n     * @param poolHash The key hash mapping to the pool we're executive over. \n     *\n     * @return The tick index that the curve and its price are living in after the call\n     *         completes. */\n    function knockInTick (Chaining.PairFlow memory accum, int24 bumpTick,\n                          CurveMath.CurveState memory curve,\n                          Directives.SwapDirective memory swap,\n                          bytes32 poolHash) private\n        returns (int24) {\n        unchecked {\n        if (!Bitmaps.isTickFinite(bumpTick)) { return bumpTick; }\n        bumpLiquidity(curve, bumpTick, swap.isBuy_, poolHash);\n\n        (int128 paidBase, int128 paidQuote, uint128 burnSwap) =\n            curve.shaveAtBump(swap.inBaseQty_, swap.isBuy_, swap.qty_);\n        accum.accumFlow(paidBase, paidQuote);\n\n        // burn down qty from shaveAtBump is always validated to be less than remaining swap.qty_\n        // so this will never underflow\n        swap.qty_ -= burnSwap;\n\n        // When selling down, the next tick leg actually occurs *below* the bump tick\n        // because the bump barrier is the first price on a tick.\n        return swap.isBuy_ ?\n            bumpTick :\n            bumpTick - 1; // Valid ticks are well above {min(int128)-1}, so will never underflow\n        }\n    }\n\n    /* @notice Performs the book-keeping related to crossing a concentrated liquidity \n     *         bump tick, and adjusts the in-memory curve object with the change of\n     *         AMM liquidity. */\n    function bumpLiquidity (CurveMath.CurveState memory curve,\n                            int24 bumpTick, bool isBuy, bytes32 poolHash) private {\n        (int128 liqDelta, bool knockoutFlag) =\n            crossLevel(poolHash, bumpTick, isBuy, curve.concGrowth_);\n        curve.concLiq_ = curve.concLiq_.addDelta(liqDelta);\n\n        if (knockoutFlag) {\n            int128 knockoutDelta = callCrossFlag\n                (poolHash, bumpTick, isBuy, curve.concGrowth_);\n            curve.concLiq_ = curve.concLiq_.addDelta(knockoutDelta);\n        }\n    }    \n}\n"
    },
    "contracts/periphery/SdexDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../SdexSwapDex.sol\";\n\n// This is the older way of doing it using assembly\ncontract SdexDeployer {\n    event SdexDeploy(address addr, uint salt);\n\n    address immutable owner_;\n    address public dex_;\n\n    constructor (address owner) {\n        owner_ = owner;\n    }\n\n    function protocolCmd (address dex, uint16 proxyPath,\n                          bytes calldata cmd, bool sudo) public {\n        require(msg.sender == owner_, \"Does not own deployer\");\n        SdexSwapDex(dex).protocolCmd(proxyPath, cmd, sudo);\n    }\n\n    function getAddress(\n        bytes memory bytecode,\n        uint _salt\n    ) public view returns (address) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(bytes1(0xff), address(this), _salt, keccak256(bytecode))\n        );\n\n        // NOTE: cast last 20 bytes of hash to address\n        return address(uint160(uint(hash)));\n    }\n\n    function deploy (bytes memory bytescode, uint salt) public returns (address) {\n        dex_ = createContract(bytescode, salt);\n        emit SdexDeploy(dex_, salt);\n        return dex_;\n    }\n\n    function createContract(bytes memory bytecode, uint _salt) internal returns (address addr) {\n        assembly {\n            addr := create2(\n                0, // No payment to constructor\n                // Actual code starts after skipping the first 32 bytes\n                add(bytecode, 0x20),\n                mload(bytecode), // Load the size of code contained in the first 32 bytes\n                _salt // Salt from function arguments\n            )\n\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n    }\n}"
    },
    "contracts/periphery/SdexLpErc20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../libraries/PoolSpecs.sol\";\nimport \"../interfaces/ISdexLpConduit.sol\";\nimport \"../interfaces/ISdexMinion.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\ncontract SdexLpErc20 is ERC20Upgradeable, ISdexLpConduit {\n\n    bytes32 public poolHash;\n    address public baseToken;\n    address public quoteToken;\n    uint256 public poolType;\n    address public sdex;\n\n    modifier onlySdex() {\n        require(msg.sender == sdex, \"SdexLpErc20: only Sdex\");\n        _;\n    }\n    \n    function initialize (address _base, address _quote, uint256 _poolIdx, address _sdex) public initializer {\n\n         //ERC20 (\"Sdex Ambient LP ERC20 Token\", \"LP-SdexAmb\", 18) {\n\n        // SdexSwap protocol uses 0x0 for native ETH, so it's possible that base\n        // token could be 0x0, which means the pair is against native ETH. quote\n        // will never be 0x0 because native ETH will always be the base side of\n        // the pair.\n        require(_quote != address(0) && _base != _quote && _quote > _base, \"Invalid Token Pair\");\n\n        bytes memory callData = abi.encodeWithSignature(\"acceptSdexDex()\");\n        (bool success, bytes memory data) = _sdex.call(callData);\n        require(success && abi.decode(data, (bool)), \"SdexLpErc20: Wrong _dex address - acceptSdexDex() failed\");\n\n        baseToken = _base;\n        quoteToken = _quote;\n        poolType = _poolIdx;\n        poolHash = PoolSpecs.encodeKey(_base, _quote, _poolIdx);\n        sdex = _sdex;\n\n        __ERC20_init(\"Sdex Ambient LP ERC20 Token\", \"LP-SdexAmb\");\n    }\n    \n    function depositSdexLiq (address sender, bytes32 pool,\n                             int24 lowerTick, int24 upperTick, uint128 seeds,\n                             uint72) public override onlySdex returns (bool) {\n        require(pool == poolHash, \"Wrong pool\");\n        require(lowerTick == 0 && upperTick == 0, \"Non-Ambient LP Deposit\");\n        _mint(sender, seeds);\n        return true;\n    }\n\n    function withdrawSdexLiq (address sender, bytes32 pool,\n                              int24 lowerTick, int24 upperTick, uint128 seeds,\n                              uint72) public override onlySdex returns (bool) {\n        require(pool == poolHash, \"Wrong pool\");\n        require(lowerTick == 0 && upperTick == 0, \"Non-Ambient LP Deposit\");\n        _burn(sender, seeds);\n        return true;\n    }\n\n}\n"
    },
    "contracts/periphery/SdexSwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../SdexSwapDex.sol\";\n\n/* @notice External router contract designed to provide ergonomic call interface to swap options\n *         without requiring SdexSwapDex approval. Relies on bilateral token transfers instead of\n *         user approved relayer calls. Flip side is the user will need to approve any tokens sold\n *         by this contract. */\ncontract SdexSwapRouter {\n\n    address lockHolder_;\n    address immutable dex_;\n    mapping(address => uint256) approvals_;\n\n    /* @param dex The address of the SdexSwapDex contract to route swaps through. */ \n    constructor (address dex) {\n        dex_ = dex;\n    }\n\n    receive() payable external { \n        require(lockHolder_ != address(0), \"Does not receive Ether outside lock\");\n        TransferHelper.safeEtherSend(lockHolder_, msg.value);\n    }\n\n    /* @notice ABI compatible with SdexSwapDex::swap() call but uses the swap proxy userCmd() call.\n     *         Useful when hot path is closed. */\n    function swap (address base, address quote,\n                   uint256 poolIdx, bool isBuy, bool inBaseQty, uint128 qty, uint16 tip,\n                   uint128 limitPrice, uint128 minOut,\n                   uint8 reserveFlags) public payable reEntrackLock\n        returns (int128 baseFlow, int128 quoteFlow) {\n        require(reserveFlags == 0, \"Router does not support surplus collateral\");\n\n        preLoadTokens(base, quote, isBuy, inBaseQty, qty, minOut);\n        (baseFlow, quoteFlow) = execSwap(base, quote, poolIdx, isBuy, inBaseQty, \n            qty, tip, limitPrice, minOut);\n        settleTokens(base, quote);\n    }\n\n    /* @notice Preemptively loads the max potential sell tokens the swap will need.\n     * \n     * @dev Note that this loads the worst-case quantity of sell tokens, in case of floating\n     *      sell side. So will have to refund any unspent at settlement. */\n    function preLoadTokens (address base, address quote, bool isBuy, bool inBaseQty, \n        uint128 qty, uint128 minOut) private {\n\n        bool baseSendToken = isBuy && base != address(0);\n        bool quoteSendToken = !isBuy;\n        uint256 qtySend = isBuy == inBaseQty ? qty : minOut;\n\n        if (baseSendToken) {\n            prepSellToken(base, qtySend);\n        } else if (quoteSendToken) {\n            prepSellToken(quote, qtySend);\n        }\n    }\n\n    function prepSellToken (address token, uint256 qty) private {\n        // Approve each token from router->dex once ever the first time it's used. Saves on unnecessary\n        // aproval calls. Since dex caps at uint128 spend, setting to uint256 means the approval will\n        // never run out.\n        if (approvals_[token] == 0) {\n            IERC20Minimal(token).approve(dex_, type(uint256).max);\n            approvals_[token] = 1;\n        }\n        TransferHelper.safeTransferFrom(token, msg.sender, address(this), qty);\n    }\n\n    /* @notice Makes the userCmd() swap proxy call.\n     * @dev This will make the swap call using the router contract's token balances. Therefore\n     *      the call needs to make sure to transfer tokens to/from the end user and this contract */\n    function execSwap (address base, address quote,\n                       uint256 poolIdx, bool isBuy, bool inBaseQty, uint128 qty, uint16 tip,\n                       uint128 limitPrice, uint128 minOut) \n        private returns (int128 baseFlow, int128 quoteFlow) {\n\n        bytes memory swapCall = abi.encode(base, quote, poolIdx, isBuy, inBaseQty, \n            qty, tip, limitPrice, minOut, 0x0);\n        bytes memory result = SdexSwapDex(dex_).userCmd\n            {value: msg.value}(SdexSlots.SWAP_PROXY_IDX, swapCall);\n\n        (baseFlow, quoteFlow) = abi.decode(result, (int128, int128));\n\n    }\n\n    /* @notice Returns any plausible tokens held by the router contract, post-swap, back to the\n     *         caller.\n     *\n     * @dev The router contract is designed to never hold any value outside a transaction. So we\n     *      safely assume that any token/ether balance remaining in the router belongs to the user. */\n    function settleTokens (address base, address quote) private {\n        // If buy-side is floating we have to refund both the buy and sell side\n        sendTokenBalance(base);\n        sendTokenBalance(quote);\n    }\n\n    /* @notice Transfers any remaining token balance held by the router back to the caller. */\n    function sendTokenBalance (address token) private {\n        if (token != address(0)) {\n            uint256 balance = IERC20Minimal(token).balanceOf(address(this));\n            if (balance > 0) {\n                TransferHelper.safeTransfer(token, msg.sender, balance);\n            }\n        }\n    }\n\n    modifier reEntrackLock() {\n        require(lockHolder_ == address(0), \"Re-entrant call\");\n        lockHolder_ = msg.sender;\n        _;\n        lockHolder_ = address(0);\n    }\n}\n\n/* @notice External router contract designed to provide ergonomic call interface to swap options\n *         by using SdexSwapDex approval for direct transfer of tokens to/from dex and end user. */\ncontract SdexSwapRouterBypass {\n    address immutable dex_;\n\n    /* @param dex The address of the SdexSwapDex contract to route swaps through. */ \n    constructor (address dex) {\n        dex_ = dex;\n    }\n\n    /* @notice ABI compatible with SdexSwapDex::swap() call but uses the swap proxy userCmdRouter()\n     *         call. Useful when hot path is closed.\n     * \n     * @dev Note that user will have to approve() this contract in SdexSwapDex. */\n    function swap (address base, address quote,\n                   uint256 poolIdx, bool isBuy, bool inBaseQty, uint128 qty, uint16 tip,\n                   uint128 limitPrice, uint128 minOut,\n                   uint8 reserveFlags) public payable\n        returns (int128 baseFlow, int128 quoteFlow) {\n        bytes memory swapCall = abi.encode(base, quote, poolIdx, isBuy, inBaseQty, \n            qty, tip, limitPrice, minOut, reserveFlags);\n        bytes memory result = SdexSwapDex(dex_).userCmdRouter\n            {value: msg.value}(SdexSlots.SWAP_PROXY_IDX, swapCall, msg.sender);\n\n        (baseFlow, quoteFlow) = abi.decode(result, (int128, int128));\n    }\n}"
    },
    "contracts/proxy/SdexBeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\n\ninterface IOwnable {\n    function owner() external view returns (address);\n}\n\ncontract SdexBeaconProxy is BeaconProxy {\n   constructor(address _beaconAddress, bytes memory _data) payable BeaconProxy(_beaconAddress, _data) {}\n\n   function getBeacon() external view returns (address) {\n      return _getBeacon();\n   }\n\n   modifier onlyBeaconOwner {\n      require(msg.sender == IOwnable(_getBeacon()).owner(), \"Only beacon owner\");\n      _;\n   }\n\n   function setBeacon(address _newBeacon, bytes memory _data) external virtual onlyBeaconOwner {\n      _setBeacon(_newBeacon, _data);\n   }\n\n}"
    },
    "contracts/proxy/SdexUpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\n\ncontract SdexUpgradeableBeacon is UpgradeableBeacon, Pausable {\n    constructor (address _implementation, address _owner) UpgradeableBeacon(_implementation) {\n        if(_owner != address(0)) {\n            _transferOwnership(_owner);\n        }\n    }\n    \n    function pause() external virtual onlyOwner{\n        _pause();\n    }\n    function unpause() external virtual onlyOwner{\n        _unpause();\n    }\n\n    function implementation() public view virtual override whenNotPaused() returns (address) {\n        return UpgradeableBeacon.implementation();\n    }\n}"
    },
    "contracts/SdexEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nlibrary SdexEvents {\n\n\n    /* @notice Emitted when governance authority for SdexSwapDex is transfered.\n     * @param The authority being transfered to. */\n    event AuthorityTransfer (address indexed authority);\n\n    /* @notice Indicates a new pool liquidity initialization value is set.\n     * @param liq The pool initialization value. */\n    event SetNewPoolLiq (uint128 liq);\n\n    /* @notice Emitted when a new protocol take rate is set.\n     * @param takeRate The take rate represents in units of 1/256. */     \n    event SetTakeRate (uint8 takeRate);\n\n    /* @notice Emitted when a new protocol relayer take rate is set.\n     * @param takeRate The relayer take rate represents in units of 1/256. */\n    event SetRelayerTakeRate (uint8 takeRate);\n\n    /* @notice Emitted when a new template is disabled, halting new creation of that pool type.\n     * @param poolIdx The pool type index being disabled. */\n    event DisablePoolTemplate (uint256 indexed poolIdx);\n\n    /* @notice Emitted when a new template is written or overwrriten.\n     * @param poolIdx The pool type index being disabled.\n     * @param feeRate The swap fee rate for the pool (represented in units of 0.0001%)\n     * @param tickSize The minimum tick size for range orders in the pool.\n     * @param jitThresh The JIT liquiidty TTL time in the pool (represented in 10s of seconds)\n     * @param knockout The knockout liquidity paramter bits (see KnockoutLiq library for more detail)\n     * @param oracleFlags The permissioned pool oracle flags if this is setup as a permissioned pool. */\n    event SetPoolTemplate (uint256 indexed poolIdx, uint16 feeRate, uint16 tickSize,\n                           uint8 jitThresh, uint8 knockout, uint8 oracleFlags);\n\n    /* @notice Emitted when a previously created pool with a pre-existing protocol take rate is re-\n     *         sychronized to the current dex-wide protocol take rate setting. \n     * @param base The base token of the pool.\n     * @param quote The quote token of the pool.\n     * @param poolIdx The pool type index of the pool.\n     * @param takeRate The newly set protocol take rate of the pool. */\n    event ResyncTakeRate (address indexed base, address indexed quote,\n                          uint256 indexed poolIdx, uint8 takeRate);\n\n    /* @notice Emitted when new minimum thresholds are set for off-grid price improvement liquidity\n     *         thresholds.\n     * @param token The token the thresholds apply to.\n     * @param unitTickCollateral The size of commited collateral required to mint positions off-grid\n     * @param awayTickTol The maximum distance away an off-grid range can be minted from the current\n     *                    price tick. */\n    event PriceImproveThresh (address indexed token, uint128 unitTickCollateral,\n                              uint16 awayTickTol);\n    \n    /* @notice Emitted when protocol governance sets a new teasury vault address\n     * @param treasury The address the treasury vault is set to\n     * @param startTime The earliest time that the vault will be eligible to collect protocol fees. */\n    event TreasurySet (address indexed treasury, uint64 indexed startTime);\n\n    /* @notice Emitted when accumulated protocol fees are collected by the treasury.\n     * @param token The token of the fees being collected.\n     * @param recv The vault the collected fees are being paid to. */\n    event ProtocolDividend (address indexed token, address indexed recv);\n\n    /* @notice Called when any proxy sidecar contract is upgraded.\n     * @param proxy The address of the new proxy smart contract.\n     * @param proxyIdx The proxy sidecar index slot the upgrade is applied to. */\n    event UpgradeProxy (address indexed proxy, uint16 proxyIdx);\n\n    /* @notice Called whenever the hot path open is toggled.\n     * @param If true indicates the hot-path is open and users can directly call the swap() function\n     *        If false, the hot path is closed and users must call the proxy contract to swap. */\n    event HotPathOpen (bool);\n\n    /* @notice Called whenever emergency safe mode is toggled\n     * @param If true indicates emergency safe mode is turned on\n     *        If false indicates emergency safe mode is turned off */\n    event SafeMode (bool);\n\n    event SdexSwap (address indexed base, address indexed quote,\n                    uint256 poolIdx, bool isBuy, bool inBaseQty, uint128 qty, uint16 tip,\n                    uint128 limitPrice, uint128 minOut,\n                    uint8 reserveFlags, int128 baseFlow, int128 quoteFlow);\n    \n    event SdexHotCmd (bytes input, int128 baseFlow, int128 quoteFlow);\n    event SdexColdCmd (bytes input);\n    event SdexColdProtocolCmd (bytes input);\n    event SdexWarmCmd (bytes input, int128 baseFlow, int128 quoteFlow);\n    event SdexKnockoutCmd (bytes input, int128 baseFlow, int128 quoteFlow);\n\n    event SdexMicroMintAmbient(bytes input, bytes output);\n    event SdexMicroMintRange(bytes input, bytes output);\n    event SdexMicroBurnAmbient(bytes input, bytes output);\n    event SdexMicroBurnRange(bytes input, bytes output);\n    event SdexMicroSwap(bytes input, bytes output);\n}\n"
    },
    "contracts/SdexSwapDex.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport './libraries/Directives.sol';\nimport './libraries/Encoding.sol';\nimport './libraries/TokenFlow.sol';\nimport './libraries/PriceGrid.sol';\nimport './mixins/MarketSequencer.sol';\nimport './mixins/SettleLayer.sol';\nimport './mixins/PoolRegistry.sol';\nimport './mixins/MarketSequencer.sol';\nimport './interfaces/ISdexMinion.sol';\nimport './callpaths/ColdPath.sol';\nimport './callpaths/BootPath.sol';\nimport './callpaths/WarmPath.sol';\nimport './callpaths/HotPath.sol';\nimport './callpaths/LongPath.sol';\nimport './callpaths/KnockoutPath.sol';\nimport './callpaths/MicroPaths.sol';\nimport './callpaths/SafeModePath.sol';\nimport './SdexEvents.sol';\n\n/* @title SdexSwap exchange contract\n * @notice Top-level SdexSwap contract. Contains all public facing methods and state\n *         for the entire dex across every pool.\n *\n * @dev    Sidecar proxy contracts exist to contain code that doesn't fit in the Ethereum\n *         limit, but this is the only contract that users need to directly interface \n *         with. */\ncontract SdexSwapDex is HotPath, ISdexMinion {\n\n    using SafeCast for uint128;\n    using TokenFlow for TokenFlow.PairSeq;\n    using CurveMath for CurveMath.CurveState;\n    using Chaining for Chaining.PairFlow;\n\n    constructor() {\n        // Authority is originally set to deployer address, which can then transfer to\n        // proper governance contract (if deployer already isn't)\n        authority_ = msg.sender;\n        hotPathOpen_ = true;\n        proxyPaths_[SdexSlots.BOOT_PROXY_IDX] = address(new BootPath());\n    }\n\n    /* @notice Swaps between two tokens within a single liquidity pool.\n     *\n     * @dev This is the most gas optimized swap call, since it avoids calling out to any\n     *      proxy contract. However there's a possibility in the future that this call \n     *      path could be disabled to support upgraded logic. In which case the caller \n     *      should be able to swap through using a userCmd() call on the HOT_PATH proxy\n     *      call path.\n     * \n     * @param base The base-side token of the pair. (For native Ethereum use 0x0)\n     * @param quote The quote-side token of the pair.\n     * @param poolIdx The index of the pool type to execute on.\n     * @param isBuy If true the direction of the swap is for the user to send base tokens\n     *              and receive back quote tokens.\n     * @param inBaseQty If true the quantity is denominated in base-side tokens. If not\n     *                  use quote-side tokens.\n     * @param qty The quantity of tokens to swap. End result could be less if the pool \n     *            price reaches limitPrice before exhausting.\n     * @param tip A user-designated liquidity fee paid to the LPs in the pool. If set to\n     *            0, just defaults to the standard pool rate. Otherwise represents the\n     *            proposed LP fee in units of 1/1,000,000. Not used in standard swap \n     *            calls, but may be used in certain permissioned or dynamic fee pools.\n     * @param limitPrice The worse price the user is willing to pay on the margin. Swap\n     *                   will execute up to this price, but not any worse. Average fill \n     *                   price will always be equal or better, because this is calculated\n     *                   at the marginal unit of quantity.\n     * @param minOut The minimum output the user expects from the swap. If less is \n     *               returned, the transaction will revert. (Alternatively if the swap\n     *               is fixed in terms of output, this is the maximum input.)\n     * @param reserveFlags Bitwise flags to indicate if the user wants to pay/receive in\n     *                     terms of surplus collateral balance held at the dex contract.\n     *                          0x1 - Base token is paid/received from surplus collateral\n     *                          0x2 - Quote token is paid/received from surplus collateral\n     * @return The token base and quote token flows associated with this swap action. \n     *         (Negative indicates a credit paid to the user, positive a debit collected\n     *         from the user) */\n    function swap (address base, address quote,\n                   uint256 poolIdx, bool isBuy, bool inBaseQty, uint128 qty, uint16 tip,\n                   uint128 limitPrice, uint128 minOut,\n                   uint8 reserveFlags) reEntrantLock public payable\n        returns (int128 baseFlow, int128 quoteFlow) {\n        bytes memory cmd = abi.encode(base, quote, poolIdx, isBuy, inBaseQty, qty, tip,\n                                      limitPrice, minOut, reserveFlags);\n        bytes memory result = callUserCmdMem(SdexSlots.SWAP_PROXY_IDX, cmd);\n        return abi.decode(result, (int128, int128));\n    }\n\n    /* @notice Consolidated method for protocol control related commands.\n     * @dev    We consolidate multiple protocol control types into a single method to \n     *         reduce the contract size in the main contract by paring down methods.\n     * \n     * @param callpath The proxy sidecar callpath called into. (Calls into proxyCmd() on\n     *                 the respective sidecare contract)\n     * @param cmd      The arbitrary byte calldata corresponding to the command. Format\n     *                 dependent on the specific callpath.\n     * @param sudo     If true, indicates that the command should be called with elevated\n     *                 privileges. */\n    function protocolCmd (uint16 callpath, bytes calldata cmd, bool sudo)\n        protocolOnly(sudo) public payable override {\n        callProtocolCmd(callpath, cmd);\n    }\n\n    /* @notice Calls an arbitrary command on one of the sidecar proxy contracts at a specific\n     *         index. Not all proxy slots may have a contract attached. If so, this call will\n     *         fail.\n     *\n     * @param callpath The index of the proxy sidecar the command is being called on.\n     * @param cmd The arbitrary call data the client is calling the proxy sidecar.\n     * @return Arbitrary byte data (if any) returned by the command. */\n    function userCmd (uint16 callpath, bytes calldata cmd) reEntrantLock\n        public payable returns (bytes memory) {\n        return callUserCmd(callpath, cmd);\n    }\n\n    /* @notice Calls an arbitrary command on behalf of another user who has signed an \n     *         EIP-712 off-chain transaction. Same general call logic as userCmd(), but\n     *         with additional args for conditions, and relayer payment.\n     *\n     * @param callpath The index of the proxy sidecar the command is being called on.\n     * @param cmd The arbitrary call data the client is calling the proxy sidecar.\n     * @param conds An ABI encoded list of evaluation conditions that are required for \n     *              this command to execute. See AgentMask.sol for format of this data.\n     * @param relayerTip An ABI encoded directive for tipping the relayer on behalf of\n     *                   the underlying client, for having mined the transaction. If this\n     *                   byte array is empty no calldata. See AgentMask.sol for format \n     *                   details.\n     * @param signature The ERC-712 signature of the above parameters signed by the \n     *                  private key of the public address the command is being executed \n     *                  for.\n     * @return Arbitrary byte data (if any) returned by the command. */\n    function userCmdRelayer (uint16 callpath, bytes calldata cmd,\n                             bytes calldata conds, bytes calldata relayerTip, \n                             bytes calldata signature)\n        reEntrantAgent(SdexRelayerCall(callpath, cmd, conds, relayerTip), signature)\n        public payable returns (bytes memory output) {\n        output = callUserCmd(callpath, cmd);\n        tipRelayer(relayerTip);\n    }\n\n    /* @notice Calls an arbitrary command on behalf of a user from a (pre-approved) \n     *         external router contract acting as an agent on the user's behalf.\n     *\n     * @dev This can only be called when the underlying user has previously approved the\n     *      msg.sender address as a router on its behalf.\n     *\n     * @param callpath The index of the proxy sidecar the command is being called on.\n     * @param cmd The arbitrary call data the client is calling the proxy sidecar.\n     * @param client The address of the client the router is calling on behalf of.\n     * @return Arbitrary byte data (if any) returned by the command. */\n    function userCmdRouter (uint16 callpath, bytes calldata cmd, address client)\n        reEntrantApproved(client, callpath) public payable\n        returns (bytes memory) {\n        return callUserCmd(callpath, cmd);\n    }\n\n    /* @notice General purpose query fuction for reading arbitrary data from the dex.\n     * @dev    This function is bare bones, because we're trying to keep the size \n     *         footprint of SdexSwapDex down. See SlotLocations.sol and QueryHelper.sol \n     *         for syntactic sugar around accessing/parsing specific data. */\n    function readSlot (uint256 slot) public view returns (uint256 data) {\n        assembly {\n            data := sload(slot)\n        }\n    }\n\n    /* @notice Validation function used by external contracts to verify an address is\n     *         a valid SdexSwapDex contract. */\n    function acceptSdexDex() pure public returns (bool) { return true; }\n}\n\n\n/* @notice Alternative constructor to SdexSwapDex that's more convenient. However\n *     the deploy transaction is several hundred kilobytes and will get droppped by \n *     geth. Useful for testing environments though. */\ncontract SdexSwapDexSeed  is SdexSwapDex {\n    \n    constructor() {\n        proxyPaths_[SdexSlots.LP_PROXY_IDX] = address(new WarmPath());\n        proxyPaths_[SdexSlots.COLD_PROXY_IDX] = address(new ColdPath());\n        proxyPaths_[SdexSlots.LONG_PROXY_IDX] = address(new LongPath());\n        proxyPaths_[SdexSlots.MICRO_PROXY_IDX] = address(new MicroPaths());\n        proxyPaths_[SdexSlots.FLAG_CROSS_PROXY_IDX] = address(new KnockoutFlagPath());\n        proxyPaths_[SdexSlots.KNOCKOUT_LP_PROXY_IDX] = address(new KnockoutLiqPath());\n        proxyPaths_[SdexSlots.SAFE_MODE_PROXY_PATH] = address(new SafeModePath());\n    }\n}\n\n"
    },
    "contracts/test/MockCond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/ISdexCondOracle.sol\";\n\ncontract MockSdexNonceOracle is ISdexNonceOracle,\n    ISdexCondOracle{\n\n    address public user_;\n    bytes32 public salt_;\n    uint32 public nonce_;\n    bytes public args_;\n    bool public accept_;\n\n    function setAccept (bool accept) public {\n        accept_ = accept;\n    }\n\n    function checkSdexNonceSet (address user, bytes32 nonceSalt, uint32 nonce,\n                                bytes calldata args) public override returns (bool) {\n        user_ = user;\n        salt_ = nonceSalt;\n        nonce_ = nonce;\n        args_ = args;\n        return accept_;\n    }\n\n    function checkSdexCond (address user, \n                            bytes calldata args) public override returns (bool) {\n        user_ = user;\n        args_ = args;\n        return accept_;\n    }\n\n}\n\n"
    },
    "contracts/test/MockConduit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/ISdexLpConduit.sol\";\nimport \"../libraries/PoolSpecs.sol\";\n\ncontract MockLpConduit is ISdexLpConduit {\n\n    bool accept_;\n\n    address public senderSnap_;\n    bytes32 public poolSnap_;\n    int24 public lowerSnap_;\n    int24 public upperSnap_;\n    uint128 public liqSnap_;\n    uint72 public mileageSnap_;\n    bool public isDeposit_;\n    \n    constructor (bool accept) {\n        accept_ = accept;\n    }\n\n    function setAccept (bool accept) public {\n        accept_ = accept;\n    }\n\n    function hashMatches (address base, address quote, uint256 poolIdx)\n        public view returns (bool){\n        return poolSnap_ == PoolSpecs.encodeKey(base, quote, poolIdx);\n    }\n\n    function depositSdexLiq (address sender, bytes32 poolHash,\n                             int24 lowerTick, int24 upperTick, uint128 liq,\n                             uint72 mileage) public override returns (bool) {\n        isDeposit_ = true;\n        senderSnap_ = sender;\n        poolSnap_ = poolHash;\n        lowerSnap_ = lowerTick;\n        upperSnap_ = upperTick;\n        liqSnap_ = liq;\n        mileageSnap_ = mileage;\n        return accept_;\n    }\n\n    function withdrawSdexLiq (address sender, bytes32 poolHash,\n                              int24 lowerTick, int24 upperTick, uint128 liq,\n                              uint72 mileage) public override returns (bool) {\n        isDeposit_ = false;\n        senderSnap_ = sender;\n        poolSnap_ = poolHash;\n        lowerSnap_ = lowerTick;\n        upperSnap_ = upperTick;\n        liqSnap_ = liq;\n        mileageSnap_ = mileage;\n        return accept_;\n    }\n\n}\n"
    },
    "contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/IERC20Minimal.sol\";\nimport \"hardhat/console.sol\";\n\ncontract MockERC20 is IERC20Permit {\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n    \n    uint8 public decimals;\n    string public symbol;\n\n    address public owner712;\n    address public spender712;\n    uint256 public amount712;\n    uint256 public deadline712;\n    uint8 public v712;\n    uint256 public r712;\n    uint256 public s712;\n\n    function deposit (address acct, uint256 qty) public {\n        balanceOf[acct] = balanceOf[acct] + qty;\n    }\n    \n    function transfer (address recip, uint256 qty) external override returns (bool) {\n        require(balanceOf[msg.sender] >= qty, \"Insufficient Balance\");\n        balanceOf[msg.sender] -= qty;\n        balanceOf[recip] += qty;\n        emit Transfer(msg.sender, recip, qty);\n        return true;\n    }\n\n    function transferFrom (address from, address to, uint256 qty)\n        external override returns (bool) {\n        require(allowance[from][msg.sender] >= qty, \"Insufficent Allowance\");\n        allowance[from][msg.sender] -= qty;\n\n        require(balanceOf[from] >= qty, \"Insufficient Balance\");\n        balanceOf[from] -= qty;\n        balanceOf[to] += qty;\n\n        emit Transfer(from, to, qty);\n        return true;\n    }\n\n    function approve (address agent, uint256 qty) external override returns (bool) {\n        allowance[msg.sender][agent] = qty;\n        emit Approval(msg.sender, agent, qty);\n        return true;\n    }\n\n    function approveFor (address owner, address agent, uint256 qty) external {\n        allowance[owner][agent] = qty;\n        emit Approval(owner, agent, qty);\n    }\n\n    function permit (address owner, address spender, uint256 amount, uint256 deadline,\n                     uint8 v, bytes32 r, bytes32 s) external override {\n        owner712 = owner;\n        spender712 = spender;\n        amount712 = amount;\n        deadline712 = deadline;\n        v712 = v;\n        r712 = uint256(r);\n        s712 = uint256(s);\n    }\n\n    function setDecimals (uint8 dec) public {\n        decimals = dec;\n    }\n\n    function setSymbol (string calldata sym) public {\n        symbol = sym;\n    }\n}\n"
    },
    "contracts/test/MockMinion.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/ISdexMinion.sol\";\n\ncontract MockMinion is ISdexMinion {\n\n    bytes[] public userCmds_;\n    bytes[] public protoCmds_;\n    uint16[] public paths_;\n    address[] public callers_;\n    bool[] public sudos_;\n\n    function protocolCmd (uint16 proxyPath, bytes calldata cmd, bool sudo) public payable\n        override {\n        paths_.push(proxyPath);\n        protoCmds_.push(cmd);\n        callers_.push(tx.origin);\n        sudos_.push(sudo);\n    }\n\n    function userCmd (uint16 proxyPath, bytes calldata cmd) public payable returns\n        (bytes memory) {\n        paths_.push(proxyPath);\n        userCmds_.push(cmd);\n        callers_.push(tx.origin);\n        return abi.encode();\n    }\n\n    function acceptSdexDex() public pure returns (bool) { return true; }\n}\n\ncontract MockMaster is ISdexMaster {\n\n    address dex_;\n\n    constructor (address dex) {\n        dex_ = dex;\n    }\n\n    function protocolCmd (uint16 proxyPath, bytes calldata cmd, bool sudo) public payable {\n        ISdexMinion(dex_).protocolCmd(proxyPath, cmd, sudo);\n    }\n\n    function acceptsSdexAuthority() override external pure returns (bool) { return true; }\n}\n"
    },
    "contracts/test/MockPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/ISdexPermitOracle.sol\";\n\ncontract MockPermit is ISdexPermitOracle {\n\n    address public user_;\n    address public base_;\n    address public quote_;\n    address public sender_;\n    bool public passThru_;\n\n    bool public isBuySnap_;\n    bool public inBaseQtySnap_;\n    uint128 public qtySnap_;\n    int24 public bidTickSnap_;\n    int24 public askTickSnap_;\n    uint128 public liqSnap_;\n    uint8 public codeSnap_;\n    uint16 public poolFee_;\n    uint256 public poolIdx_;\n    \n    function setMatching (address user, address base, address quote) public {\n        user_ = user;\n        base_ = base;\n        quote_ = quote;\n    }\n\n    function setPassThru (bool passThru) public {\n        passThru_ = passThru;\n    }\n        \n\n    function checkApprovedForSdexPool (address user, address sender,\n                                       address base, address quote,\n                                       Directives.AmbientDirective calldata,\n                                       Directives.SwapDirective calldata,\n                                       Directives.ConcentratedDirective[] calldata,\n                                       uint16 poolFee)\n        external override returns (uint16 discount) {\n        if (passThru_) { return 1; }\n        codeSnap_ = 1;\n        sender_ = sender;\n        poolFee_ = poolFee;\n        discount = (user == user_ && base == base_ && quote_ == quote) ? 1 : 0;\n     }\n\n    function checkApprovedForSdexSwap (address user, address sender,\n                                       address base, address quote,\n                                       bool isBuy, bool inBaseQty, uint128 qty,\n                                       uint16 poolFee)\n        external override returns (uint16 discount) {\n        if (passThru_) { return 1; }\n        sender_ = sender;\n        codeSnap_ = 2;\n        isBuySnap_ = isBuy;\n        inBaseQtySnap_ = inBaseQty;\n        qtySnap_ = qty;\n        poolFee_ = poolFee;\n        discount = (user == user_ && base == base_ && quote_ == quote) ? 1 : 0;\n    }\n\n    function checkApprovedForSdexMint (address user, address sender,\n                                       address base, address quote,\n                                       int24 bidTick, int24 askTick, uint128 liq)\n         external override returns (bool) {\n         if (passThru_) { return true; }\n         codeSnap_ = 3;\n         sender_ = sender;\n         bidTickSnap_ = bidTick;\n         askTickSnap_ = askTick;\n         liqSnap_ = liq;\n         return user == user_ && base == base_ && quote_ == quote;\n     }\n\n    function checkApprovedForSdexBurn (address user, address sender,\n                                       address base, address quote,\n                                       int24 bidTick, int24 askTick, uint128 liq)\n         external override returns (bool) {\n         if (passThru_) { return true; }\n         sender_ = sender;\n         bidTickSnap_ = bidTick;\n         askTickSnap_ = askTick;\n         liqSnap_ = liq;\n         codeSnap_ = 4;                 \n         return user == user_ && base == base_ && quote_ == quote;\n     }\n\n    function checkApprovedForSdexInit (address user, address sender,\n                                       address base, address quote, uint256 poolIdx)\n         external override returns (bool) {\n         if (passThru_) { return true; }\n         sender_ = sender;\n         codeSnap_ = 5;\n         poolIdx_ = poolIdx;\n         return user == user_ && base == base_ && quote_ == quote;\n     }\n\n     /* @notice Just used to validate the contract address at pool creation time. */\n    function acceptsPermitOracle() external pure override returns (bool) { return true; }\n}\n\n"
    },
    "contracts/test/MockProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"hardhat/console.sol\";\n\ncontract MockHotProxy {\n\n    event MockHotSwap();\n    \n    function swap (bytes calldata) public payable {\n        emit MockHotSwap();\n    }\n}\n"
    },
    "contracts/test/MockProxySidecar.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../interfaces/ISdexCondOracle.sol\";\n\ncontract MockProxySidecar {\n\n    uint16 public proxySlot_;\n    address public proxyDex_;\n\n    function setRole (uint16 slot, address proxyDex) public {\n        proxySlot_ = slot;\n        proxyDex_ = proxyDex;\n    }\n\n    /* @notice Used at upgrade time to verify that the contract is a valid Sdex sidecar proxy and used\n     *         in the correct slot. */\n    function acceptSdexProxyRole (address dex, uint16 slot) public payable returns (bool) {\n        return (proxyDex_ == address(0)) ||\n            (proxySlot_ == slot && proxyDex_ == dex);\n    }\n}\n\n"
    },
    "contracts/test/MockTimelock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\nimport \"../governance/SdexPolicy.sol\";\nimport \"hardhat/console.sol\";\n\ncontract MockTimelock {\n\n    address public policy_;\n\n    constructor (address policy) {\n        policy_ = policy;\n    }\n\n    function acceptAdmin() public payable { \n        require(msg.sender == policy_);\n    }\n\n    function treasuryResolution (address minion, uint16 proxyPath,\n                                 bytes calldata cmd, bool sudo) public {\n        return SdexPolicy(policy_).treasuryResolution(minion, proxyPath, cmd, sudo);\n    }\n\n    function opsResolution (address minion, uint16 proxyPath,\n                            bytes calldata cmd) public {\n        return SdexPolicy(policy_).opsResolution(minion, proxyPath, cmd);\n    }\n\n    function transferGovernance (address treasury, address ops, address emergency) public {\n        return SdexPolicy(policy_).transferGovernance(treasury, ops, emergency);\n    }\n\n    function emergencyHalt (address minion, string calldata reason) public {\n        return SdexPolicy(policy_).emergencyHalt(minion, reason);\n    }\n\n    function emergencyReset (address conduit, uint16 proxyPath, string calldata reason) public {\n        return SdexPolicy(policy_).emergencyReset(conduit, proxyPath, reason);\n    }\n\n    function forcePolicy (address conduit, uint16 proxyPath, SdexPolicy.PolicyRule calldata policy) public {\n        return SdexPolicy(policy_).forcePolicy(conduit, proxyPath, policy);\n    }\n\n    function setPolicy (address conduit, uint16 proxyPath, SdexPolicy.PolicyRule calldata policy) public {\n        return SdexPolicy(policy_).setPolicy(conduit, proxyPath, policy);\n    }\n\n}\n"
    },
    "contracts/test/QueryHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\nimport \"../SdexSwapDex.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract QueryHelper {\n    using CurveMath for CurveMath.CurveState;\n    \n    address public dex_;\n    \n    constructor (address dex) {\n        dex_ = dex;\n    }\n    \n    function queryCurve (address base, address quote, uint256 poolIdx)\n        public view returns (CurveMath.CurveState memory curve) {\n        bytes32 key = PoolSpecs.encodeKey(base, quote, poolIdx);\n        bytes32 slot = keccak256(abi.encode(key, SdexSlots.CURVE_MAP_SLOT));\n        uint256 valOne = SdexSwapDex(dex_).readSlot(uint256(slot));\n        uint256 valTwo = SdexSwapDex(dex_).readSlot(uint256(slot)+1);\n        \n        curve.priceRoot_ = uint128((valOne << 128) >> 128);\n        curve.ambientSeeds_ = uint128(valOne >> 128);\n        curve.concLiq_ = uint128((valTwo << 128) >> 128);\n        curve.seedDeflator_ = uint64((valTwo << 64) >> 192);\n        curve.concGrowth_ = uint64(valTwo >> 192);\n    }\n\n    function queryLiquidity (address base, address quote, uint256 poolIdx)\n        public view returns (uint128) {\n        \n        return queryCurve(base, quote, poolIdx).activeLiquidity();\n    }\n\n    function queryPrice (address base, address quote, uint256 poolIdx)\n        public view returns (uint128) {\n        return queryCurve(base, quote, poolIdx).priceRoot_;\n    }\n\n    function querySurplus (address owner, address token)\n        public view returns (uint128 surplus) {\n        bytes32 key = keccak256(abi.encode(owner, token));\n        bytes32 slot = keccak256(abi.encode(key, SdexSlots.BAL_MAP_SLOT));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n        surplus = uint128((val << 128) >> 128);\n    }\n\n    function queryProtocolAccum (address token) public view returns (uint128) {\n        bytes32 key = bytes32(uint256(uint160(token)));\n        bytes32 slot = keccak256(abi.encode(key, SdexSlots.FEE_MAP_SLOT));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n        return uint128(val);\n    }\n\n    function queryLevel (address base, address quote, uint256 poolIdx, int24 tick)\n        public view returns (uint96 bidLots, uint96 askLots, uint64 odometer) {\n        bytes32 poolHash = PoolSpecs.encodeKey(base, quote, poolIdx);\n        bytes32 key = keccak256(abi.encodePacked(poolHash, tick));\n        bytes32 slot = keccak256(abi.encode(key, SdexSlots.LVL_MAP_SLOT));\n        uint256 val = SdexSwapDex(dex_).readSlot(uint256(slot));\n\n        odometer = uint64(val >> 192);\n        askLots = uint96((val << 64) >> 160);\n        bidLots = uint96((val << 160) >> 160);\n    }\n}\n"
    },
    "contracts/test/SdexShell.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\n\n/* @title Empty implementation of SdexSwap interface */\ncontract SdexShell {\n\n    function swap (address base, address quote,\n                   uint256 poolIdx, bool isBuy, bool inBaseQty, uint128 qty, uint16 tip,\n                   uint128 limitPrice, uint128 minOut,\n                   uint8 settleFlags) public payable returns (int128) { }\n\n    function protocolCmd (uint16 callpath, bytes calldata cmd, bool sudo)\n        public payable { }\n\n    function userCmd (uint16 callpath, bytes calldata cmd) \n        public payable returns (bytes memory) { }\n\n    function userCmdRelayer (uint16 callpath, bytes calldata cmd,\n                             bytes calldata conds, bytes calldata relayerTip, \n                             bytes calldata signature)\n        public payable returns (bytes memory output) { }\n\n    function userCmdRouter (uint16 callpath, bytes calldata cmd, address client,\n                            uint256 salt)\n        public payable returns (bytes memory) { }\n    \n    function readSlot (uint256 slot) public view returns (uint256) { }\n}\n\n"
    },
    "contracts/test/TestAgentMask.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n    \nimport \"../mixins/AgentMask.sol\";\n\ncontract TestAgentMask is AgentMask {\n\n    address public signer_;\n\n    function addressToNum (address x) public pure returns (uint256) {\n        return uint256(uint160(x));\n    }\n\n    function joinKey (address x, address y) public pure returns (uint256) {\n        return uint256(keccak256(abi.encode(x, y)));\n    }\n\n    function testVerifySignature (uint16 callpath, bytes memory cmd,\n                                  bytes calldata conds,\n                                  bytes memory tip,\n                                  bytes calldata signature) public {\n        SdexRelayerCall memory call = SdexRelayerCall(callpath, cmd, conds, tip);\n        signer_ = verifySignature(call, signature);\n    }\n\n    function testRelayConds (address client, bytes calldata conds) public {\n        checkRelayConditions(client, conds);\n    }\n\n    function getNonce (address client, uint256 salt) public view returns (uint32) {\n        return userBals_[nonceKey(client, bytes32(salt))].nonce_;\n    }\n\n    function setNonce (address client, uint256 salt, uint32 nonce) public {\n        userBals_[nonceKey(client, bytes32(salt))].nonce_ = nonce;\n    }\n}\n\n\ncontract TestAgentMaskRouter {\n    \n    address public mask_;\n    \n    constructor (address mask) {\n        mask_ = mask;\n    }\n\n    function testRelayConds (address client, bool deadPast, bool aliveEarly,\n                             uint256 salt, uint32 nonce, address relayer) public {\n        uint48 deadline = deadPast ? uint48(block.timestamp) - 1 :\n            uint48(block.timestamp);\n        uint48 alive = aliveEarly ? uint48(block.timestamp) + 1 :\n            uint48(block.timestamp);\n        \n        bytes memory conds = abi.encode(deadline, alive, salt, nonce, relayer);\n        TestAgentMask(mask_).testRelayConds(client, conds);\n    }\n}\n"
    },
    "contracts/test/TestBitmaps.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n    \nimport \"../libraries/Bitmaps.sol\";\n\ncontract TestBitmapsLib {\n    using Bitmaps for uint256;\n    using Bitmaps for int24;\n\n    function testTruncateLeft (uint256 bitmap, uint8 shift)\n        pure public returns (uint256) {\n        return bitmap.truncateBitmap(shift, false);\n    }\n\n    function testTruncateRight (uint256 bitmap, uint8 shift)\n        pure public returns (uint256) {\n        return bitmap.truncateBitmap(shift, true);\n    }\n    \n    function testBitLeft (uint256 bitmap, uint8 shift)\n        pure public returns (uint8, bool) {\n        return bitmap.bitAfterTrunc(shift, false);\n    }\n\n    function testBitRight (uint256 bitmap, uint8 shift)\n        pure public returns (uint8, bool) {\n        return bitmap.bitAfterTrunc(shift, true);\n    }\n\n    function testBitSet (uint256 bitmap, uint8 pos) pure public returns (bool) {\n        return bitmap.isBitSet(pos);\n    }\n\n    function testShiftBump (int24 tick, bool isBuy)\n        pure public returns (uint16) {\n        return tick.termBump(isBuy);\n    }\n    \n    function testCastIndex (int8 x) pure public returns (uint8) {\n        return Bitmaps.castBitmapIndex(x);\n    }\n\n    function testUncastIndex (uint8 x) pure public returns (int8) {\n        return Bitmaps.uncastBitmapIndex(x);\n    }\n\n    function testDecomp (int24 tick) pure public returns\n        (int8 lobbyKey, int16 mezzKey, uint8 lobbyBit, uint8 mezzBit, uint8 termBit) {\n        lobbyKey = tick.lobbyKey();\n        mezzKey = tick.mezzKey();\n        lobbyBit = tick.lobbyBit();\n        mezzBit = tick.mezzBit();\n        termBit = tick.termBit();\n    }\n\n    function testWeld (int8 lobbyIdx, uint8 mezzBit, uint8 termBit) public pure returns\n        (int24 fullWeld, int16 mezzWeld, int24 termWeld) {\n        fullWeld = Bitmaps.weldLobbyMezzTerm(lobbyIdx, mezzBit, termBit);\n        mezzWeld = Bitmaps.weldLobbyMezz(lobbyIdx, mezzBit);\n        termWeld = Bitmaps.weldMezzTerm(mezzWeld, termBit);\n    }\n}\n"
    },
    "contracts/test/TestCompoundMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n    \nimport \"../libraries/CompoundMath.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract TestCompoundMath {\n    using CompoundMath for uint256;\n    using CompoundMath for uint160;\n    using CompoundMath for uint128;\n    using CompoundMath for uint64;\n    \n    function testApproxSqrt (uint64 x) public pure returns (uint64) {\n        return x.approxSqrtCompound();\n    }\n\n    function testStack (uint64 x, uint64 y) public pure returns (uint64) {\n        return x.compoundStack(y);\n    }\n\n    function testDivide (uint128 x, uint128 y) public pure returns (uint64) {\n        return x.compoundDivide(y);\n    }\n\n    function testShrink (uint64 x, uint64 y) public pure returns (uint256) {\n        return x.compoundShrink(y);\n    }\n\n    function testPrice (uint128 price, uint64 growth, bool up)\n        public pure returns (uint256) {\n        return price.compoundPrice(growth, up);\n    }\n\n    function testInflate (uint128 x, uint64 y) public pure returns (uint128) {\n        return x.inflateLiqSeed(y);\n    }\n\n    function testDeflate (uint128 x, uint64 y) public pure returns (uint128) {\n        return x.deflateLiqSeed(y);\n    }\n\n    function testMulQ64 (uint128 x, uint128 y) public pure returns (uint192) {\n        return FixedPoint.mulQ64(x, y);\n    }\n\n    function testMulQ48 (uint128 x, uint64 y) public pure returns (uint144) {\n        return FixedPoint.mulQ48(x, y);\n    }\n\n    function testDivQ64 (uint128 x, uint128 y) public pure returns (uint256) {\n        return FixedPoint.divQ64(x, y);\n    }\n\n    function testRecipQ64 (uint128 x) public pure returns (uint128) {\n        return FixedPoint.recipQ64(x);\n    }\n}\n"
    },
    "contracts/test/TestCurveMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n\nimport \"../libraries/CurveMath.sol\";\nimport \"../libraries/CurveAssimilate.sol\";\nimport \"../libraries/CurveRoll.sol\";\nimport \"../libraries/SwapCurve.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract TestCurveMath {\n    function testActiveLiq (uint128 seed, uint64 growth, uint128 concentrated)\n        public pure returns (uint128) {\n        return CurveMath.activeLiquidity(\n            buildCurve(seed, growth, concentrated, 0));\n    }\n\n    function testVig (uint128 liq, uint128 swapQty, uint16 feeRate, uint8 protoCut,\n                      bool, bool inBase, uint128 curvePrice, uint128 limitPrice)\n        public pure returns (uint128, uint128) {\n        CurveMath.CurveState memory curve = buildCurve(liq, 0, 0, curvePrice);\n        return SwapCurve.calcFeeOverSwap(curve, swapQty, feeRate, protoCut, inBase,\n                                     limitPrice);\n    }\n\n    function testVigMin (uint128 liq, uint16 feeRate, uint8 protoCut,\n                         bool inBase, uint128 curvePrice)\n        public pure returns (uint128, uint128) {\n        uint128 swapQty = type(uint128).max;\n        bool isBuy = inBase ? false : true;\n        return testVig(liq, swapQty, feeRate, protoCut, isBuy, inBase, curvePrice,\n                       TickMath.MIN_SQRT_RATIO);\n    }\n\n    function testVigMax (uint128 liq, uint16 feeRate, uint8 protoCut,\n                         bool inBase, uint128 curvePrice)\n        public pure returns (uint128, uint128) {\n        uint128 swapQty = type(uint128).max;\n        bool isBuy = inBase ? true : false;\n        return testVig(liq, swapQty, feeRate, protoCut, isBuy, inBase, curvePrice,\n                       TickMath.MAX_SQRT_RATIO);\n    }\n\n    function testLimitBase (uint128 price, uint128 limitPrice, uint128 liq)\n        public pure returns (uint128) {\n        CurveMath.CurveState memory curve = buildCurve(liq, 0, 0, price);\n        return CurveMath.calcLimitFlows(curve, 1000000, true, limitPrice);\n    }\n\n    function testLimitQuote (uint128 price, uint128 limitPrice, uint128 liq)\n        public pure returns (uint128) {\n        CurveMath.CurveState memory curve = buildCurve(liq, 0, 0, price);\n        return CurveMath.calcLimitFlows(curve, 1000000, false, limitPrice);\n    }\n\n    function testCounterBase (uint128 price, uint128 limitPrice, uint128 liq)\n        public pure returns (uint128) {\n        CurveMath.CurveState memory curve = buildCurve(liq, 0, 0, price);\n        return CurveMath.calcLimitCounter(curve, 1000000, true, limitPrice);\n    }\n\n    function testCounterQuote (uint128 price, uint128 limitPrice, uint128 liq)\n        public pure returns (uint128) {\n        CurveMath.CurveState memory curve = buildCurve(liq, 0, 0, price);\n        return CurveMath.calcLimitCounter(curve, 1000000, false, limitPrice);\n    }\n\n    function testLimitBaseMax (uint128 price, uint128 liq)\n        public pure returns (uint128) {\n        return testLimitBase(price, TickMath.MAX_SQRT_RATIO, liq);\n    }    \n\n    function testLimitBaseMin (uint128 price, uint128 liq)\n        public pure returns (uint128) {\n        return testLimitBase(price, TickMath.MIN_SQRT_RATIO, liq);\n    }    \n\n    function testLimitQuoteMax (uint128 price, uint128 liq)\n        public pure returns (uint128) {\n        return testLimitQuote(price, TickMath.MAX_SQRT_RATIO, liq);\n    }    \n\n    function testLimitQuoteMin (uint128 price, uint128 liq)\n        public pure returns (uint128) {\n        return testLimitQuote(price, TickMath.MIN_SQRT_RATIO, liq);\n    }    \n\n    function testCounterBaseMax (uint128 price, uint128 liq)\n        public pure returns (uint128) {\n        return testCounterBase(price, TickMath.MAX_SQRT_RATIO, liq);\n    }    \n\n    function testCounterBaseMin (uint128 price, uint128 liq)\n        public pure returns (uint128) {\n        return testCounterBase(price, TickMath.MIN_SQRT_RATIO, liq);\n    }    \n\n    function testCounterQuoteMax (uint128 price, uint128 liq)\n        public pure returns (uint128) {\n        return testCounterQuote(price, TickMath.MAX_SQRT_RATIO, liq);\n    }    \n\n    function testCounterQuoteMin (uint128 price, uint128 liq)\n        public pure returns (uint128) {\n        return testCounterQuote(price, TickMath.MIN_SQRT_RATIO, liq);\n    }    \n\n    function testLimitQtyLeft (uint128 price, uint128 limitPrice, uint128 liq,\n                               uint128 swapQty)\n        public pure returns (uint128) {\n        CurveMath.CurveState memory curve = buildCurve(liq, 0, 0, price);\n        return CurveMath.calcLimitFlows(curve, swapQty, true, limitPrice);\n    }\n\n    function testCounterQtyLeft (uint128 price, uint128 limitPrice, uint128 liq,\n                                 uint128 swapQty)\n        public pure returns (uint128) {\n        CurveMath.CurveState memory curve = buildCurve(liq, 0, 0, price);\n        return CurveMath.calcLimitCounter(curve, swapQty, true, limitPrice);\n    }\n\n    function testRoll (uint128 flow, uint128 price, uint128 liq,\n                       bool isBuy, bool inBase)\n        public pure returns (uint128 rollPrice, uint128 qtyLeft,\n                             int128 paidBase, int128 paidQuote) {\n        CurveMath.CurveState memory curve = buildCurve(liq, 0, 0, price);\n        (paidBase, paidQuote, qtyLeft) = CurveRoll.rollFlow\n            (curve, flow, inBase, isBuy, flow);\n        rollPrice = curve.priceRoot_;\n    }\n\n    function testRollInf (uint128 liq, uint128 price, bool isBuy, bool inBase)\n        public pure returns (uint128 rollPrice, uint128 qtyLeft,\n                             int128 paidBase, int128 paidQuote) {\n        uint128 flow = (isBuy == inBase) ? uint128(type(int128).max) :\n            SafeCast.toUint128(inBase ?\n                               FixedPoint.mulQ64(liq, price) :\n                               FixedPoint.divQ64(liq, price));\n        (rollPrice, qtyLeft, paidBase, paidQuote) =\n            testRoll(flow, price, liq, isBuy, inBase);\n    }\n\n    function testAssimilate (uint128 feesPaid, uint128 price,\n                             uint128 seed, uint128 conc, uint64 growth, bool inBase)\n        public pure returns (uint128 shiftPrice, uint128 shiftSeed,\n                             uint128 shiftGrowth, uint128 concGrowth) {\n        CurveMath.CurveState memory curve = buildCurve(seed, growth, conc, price);\n        CurveAssimilate.assimilateLiq(curve, feesPaid, inBase);\n        \n        (shiftPrice, shiftSeed) = (curve.priceRoot_, curve.ambientSeeds_);\n        (shiftGrowth, concGrowth) = (curve.seedDeflator_,\n                                     curve.concGrowth_);\n    }\n\n    function testDeriveImpact (uint128 price, uint128 seed, uint64 growth,\n                               uint128 conc, uint128 flow, \n                               bool isBuy, bool inBase)\n        public pure returns (uint128, uint128) {\n        CurveMath.CurveState memory curve = buildCurve(seed, growth, conc, price);\n        return CurveRoll.deriveImpact(curve, flow, inBase, isBuy);\n    }\n    \n    function buildCurve (uint128 seed, uint64 growth, uint128 conc, uint128 price)\n        private pure returns (CurveMath.CurveState memory) {\n        return CurveMath.CurveState(price, seed, conc, growth, 0);\n    }\n\n    function testTokenPrecision (uint128 liq, uint128 price,\n                                 bool inBase) public pure returns (uint128) {\n        return CurveMath.priceToTokenPrecision(liq, price, inBase);\n    }\n}\n"
    },
    "contracts/test/TestEncoding.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n    \nimport \"../libraries/Encoding.sol\";\nimport \"../libraries/Directives.sol\";\n\ncontract TestEncoding {\n    Directives.SettlementChannel public settleOpen;\n    Directives.SettlementChannel public settleHop;\n    Directives.PriceImproveReq public priceImprove;\n    Directives.ChainingFlags public chaining;\n    Directives.SwapDirective public swap;\n    Directives.AmbientDirective public ambientOpen;\n    Directives.ConcentratedDirective public bookend;\n    \n    uint256 public poolIdx;\n    int24 public openTick;\n    \n    \n    function testEncodeHop (uint8 idx, bytes calldata input) public {\n        Directives.OrderDirective memory directive = OrderEncoding.decodeOrder(input);\n        settleHop = directive.hops_[idx].settle_;\n        priceImprove = directive.hops_[idx].improve_;\n    }\n\n    function testEncodePool (uint8 pairPos, uint8 poolPos,\n                             bytes calldata input) public {\n        Directives.OrderDirective memory dir = OrderEncoding.decodeOrder(input);\n        poolIdx = dir.hops_[pairPos].pools_[poolPos].poolIdx_;\n        swap = dir.hops_[pairPos].pools_[poolPos].swap_;\n        ambientOpen = dir.hops_[pairPos].pools_[poolPos].ambient_;\n        chaining = dir.hops_[pairPos].pools_[poolPos].chain_;\n    }\n\n    function testEncodePassive (uint8 pairPos, uint8 poolPos, uint8 concPos,\n                                bytes calldata input) public {\n        Directives.OrderDirective memory dir = OrderEncoding.decodeOrder(input);\n        bookend = dir.hops_[pairPos].pools_[poolPos].conc_[concPos];\n    }\n\n    function testEncodeOpen (bytes calldata input) public {\n        Directives.OrderDirective memory directive = OrderEncoding.decodeOrder(input);\n        settleOpen = directive.open_;        \n    }\n}\n"
    },
    "contracts/test/TestKnockoutCounter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport \"../mixins/KnockoutCounter.sol\";\n\ncontract TestKnockoutCounter is KnockoutCounter {\n    using KnockoutLiq for KnockoutLiq.KnockoutPos;\n    using KnockoutLiq for KnockoutLiq.KnockoutPosLoc;\n\n    uint96 public bookLots_;\n    uint32 public pivotTime_;\n    uint64 public rewards_;\n    uint32 public callTime_;\n    bool public togglesPivot_;\n    \n    function testCross (uint256 pool, bool isBid, int24 tick,\n                        uint64 feeGlobal) public {\n        crossLevel(bytes32(pool), tick, !isBid, feeGlobal);\n        crossKnockout(bytes32(pool), isBid, tick, feeGlobal);\n    }\n\n    function testMint (uint256 poolIdx, uint8 knockoutBits,\n                       int24 tick, uint64 feeGlobal, uint96 lots,\n                       bool isBid, int24 lower, int24 upper) public {\n        KnockoutLiq.KnockoutPosLoc memory loc;\n        loc.isBid_ = isBid;\n        loc.lowerTick_ = lower;\n        loc.upperTick_ = upper;\n        \n        (pivotTime_, togglesPivot_) = addKnockoutLiq\n            (bytes32(poolIdx), knockoutBits, tick, feeGlobal, loc, lots);\n\n        callTime_ = uint32(block.timestamp);\n    }\n\n    // Mints a bid and an ask at the same time\n    function testMintArch (uint256 poolIdx, uint8 knockoutBits,\n                           int24 tick, uint64 feeGlobal, uint96 lots,\n                           int24 lower, int24 upper) public {\n        testMint(poolIdx, knockoutBits, tick, feeGlobal, lots, true, lower, upper);\n        testMint(poolIdx, knockoutBits, tick, feeGlobal, lots, false, lower, upper);\n    }\n\n    function testBurn (uint256 poolIdx, int24 tick, uint64 feeGlobal, uint96 lots,\n                       bool isBid, int24 lower, int24 upper) public {\n        KnockoutLiq.KnockoutPosLoc memory loc;\n        loc.isBid_ = isBid;\n        loc.lowerTick_ = lower;\n        loc.upperTick_ = upper;\n        \n        (togglesPivot_, pivotTime_, rewards_) =\n            rmKnockoutLiq(bytes32(poolIdx), tick, feeGlobal, loc, lots);\n    }\n\n    function testClaim (uint256 poolIdx, bool isBid, int24 lower, int24 upper,\n                        uint160 merkleRoot, uint256[] calldata merkleProof) public {\n        KnockoutLiq.KnockoutPosLoc memory loc;\n        loc.isBid_ = isBid;\n        loc.lowerTick_ = lower;\n        loc.upperTick_ = upper;\n        \n        (bookLots_, rewards_) = claimPostKnockout\n            (bytes32(poolIdx), loc, merkleRoot, merkleProof);\n    }\n\n    function testRecover (uint256 poolIdx, bool isBid, int24 lower, int24 upper,\n                          uint32 pivotTime) public {\n        KnockoutLiq.KnockoutPosLoc memory loc;\n        loc.isBid_ = isBid;\n        loc.lowerTick_ = lower;\n        loc.upperTick_ = upper;\n        \n        (bookLots_) = recoverPostKnockout(bytes32(poolIdx), loc, pivotTime);\n    }\n\n    function getPivot (uint256 poolIdx, bool isBid, int24 lower, int24 upper)\n        public view returns (uint96 lots, uint32 pivotTime, uint16 range) {\n        KnockoutLiq.KnockoutPosLoc memory loc;\n        loc.isBid_ = isBid;\n        loc.lowerTick_ = lower;\n        loc.upperTick_ = upper;\n        \n        bytes32 key = loc.encodePivotKey(bytes32(poolIdx));\n        KnockoutLiq.KnockoutPivot memory pivot = knockoutPivots_[key];\n        lots = pivot.lots_;\n        pivotTime = pivot.pivotTime_;\n        range = pivot.rangeTicks_;\n    }\n\n    function getMerkle (uint256 poolIdx, bool isBid, int24 lower, int24 upper)\n        public view returns (uint160 root, uint32 pivotTime, uint64 feeMileage) {\n        KnockoutLiq.KnockoutPosLoc memory loc;\n        loc.isBid_ = isBid;\n        loc.lowerTick_ = lower;\n        loc.upperTick_ = upper;\n        \n        bytes32 key = loc.encodePivotKey(bytes32(poolIdx));\n        KnockoutLiq.KnockoutMerkle memory merkle = knockoutMerkles_[key];\n        root = merkle.merkleRoot_;\n        pivotTime = merkle.pivotTime_;\n        feeMileage = merkle.feeMileage_;\n    }\n\n    function getPosition (uint256 poolIdx, bool isBid, int24 lower, int24 upper,\n                          uint32 pivotTime) public view returns\n        (uint96 lots, uint64 feeMileage, uint32 timestamp) {\n        KnockoutLiq.KnockoutPosLoc memory loc;\n        loc.isBid_ = isBid;\n        loc.lowerTick_ = lower;\n        loc.upperTick_ = upper;\n\n        bytes32 key = loc.encodePosKey(bytes32(poolIdx), lockHolder_, pivotTime);\n        KnockoutLiq.KnockoutPos memory pos = knockoutPos_[key];\n        lots = pos.lots_;\n        timestamp = pos.timestamp_;\n        feeMileage = pos.feeMileage_;\n    }\n\n    function getLevelState (uint256 poolIdx, int24 tick) public view returns\n        (BookLevel memory) {\n        return levelState(bytes32(poolIdx), tick);\n    }\n\n    function setLockholder (uint160 lockholder) public {\n        lockHolder_ = address(lockholder);\n    }\n}\n"
    },
    "contracts/test/TestKnockoutLiq.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n    \nimport \"../libraries/KnockoutLiq.sol\";\n\ncontract TestKnockoutLiq {\n    using KnockoutLiq for KnockoutLiq.KnockoutMerkle;\n    using KnockoutLiq for KnockoutLiq.KnockoutPivot;\n\n    KnockoutLiq.KnockoutMerkle public merkle_;\n\n    function testEncodePivotKey (uint256 pool, bool isBid, int24 tick) \n        public pure returns (bytes32) {\n        return KnockoutLiq.encodePivotKey(bytes32(pool), isBid, tick);\n    }\n\n    function testEncodePosKey (uint256 pool, uint160 owner, bool isBid, int24 lower,\n                               int24 upper, uint32 pivotTime)\n        public pure returns (bytes32) {\n        KnockoutLiq.KnockoutPosLoc memory pos;\n        pos.isBid_ = isBid;\n        pos.lowerTick_ = lower;\n        pos.upperTick_ = upper;\n        return KnockoutLiq.encodePosKey(pos, bytes32(pool), address(owner), pivotTime);\n    }\n\n    function testCommit (uint96 lots, uint32 time, uint16 range,\n                         uint64 feeMileage) public {\n        KnockoutLiq.KnockoutPivot memory pivot;\n        pivot.lots_ = lots;\n        pivot.rangeTicks_ = range;\n        pivot.pivotTime_ = time;\n        merkle_.commitKnockout(pivot, feeMileage);\n    }\n\n    function testProof (uint160 root, uint256[] calldata proof)\n        view public returns (uint32, uint64) {\n        return merkle_.proveHistory(root, proof);\n    }\n\n    function testAssertValid (bool isBid, int24 lower, int24 upper,\n                              int24 priceTick, uint8 knockoutBits) public pure {\n        KnockoutLiq.KnockoutPosLoc memory pos;\n        pos.isBid_ = isBid;\n        pos.lowerTick_ = lower;\n        pos.upperTick_ = upper;        \n        KnockoutLiq.assertValidPos(pos, priceTick, knockoutBits);\n    }\n}\n"
    },
    "contracts/test/TestLevelBook.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\n\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport \"../mixins/LevelBook.sol\";\n\ncontract TestLevelBook is LevelBook {\n    using TickMath for uint160;\n\n    int256 public liqDelta;\n    bool public knockoutFlag;\n    uint256 public odometer;\n\n    function getLevelState (uint256 poolIdx, int24 tick) public view returns\n        (BookLevel memory) {\n        return levelState(bytes32(poolIdx), tick);\n    }\n\n    function pullFeeOdometer (uint256 poolIdx, int24 mid, int24 bid, int24 ask,\n                              uint64 feeGlobal)\n        public view returns (uint64) {\n        return clockFeeOdometer(bytes32(poolIdx), mid, bid, ask, feeGlobal);\n    }\n\n    function testCrossLevel (uint256 poolIdx, int24 tick, bool isBuy,\n                             uint64 feeGlobal) public {\n        (liqDelta, knockoutFlag) = crossLevel(bytes32(poolIdx), tick, isBuy, feeGlobal);\n    }\n\n    function testAdd (uint256 poolIdx, int24 midTick, int24 bidTick, int24 askTick,\n                      uint96 lots, uint64 globalFee) public {\n        odometer = addBookLiq(bytes32(poolIdx), midTick, bidTick, askTick,\n                              lots, globalFee);\n    }\n\n    function testRemove (uint256 poolIdx, int24 midTick, int24 bidTick, int24 askTick,\n                         uint96 lots, uint64 globalFee) public {\n        odometer = removeBookLiq(bytes32(poolIdx), midTick, bidTick, askTick,\n                                 lots, globalFee);\n    }\n\n    function hasTickBump (uint256 poolIdx, int24 tick) public view returns (bool) {\n        return hasTickBookmark(bytes32(poolIdx), tick);\n    }\n\n}\n\ncontract TestLevelBook72Bit is LevelBook {\n    using TickMath for uint160;\n\n    int256 public liqDelta;\n    bool public knockoutFlag;\n    uint256 public odometer;\n\n    function getLevelState (uint256 poolIdx, int24 tick) public view returns\n        (BookLevel memory) {\n        return levelState(bytes32(poolIdx), tick);\n    }\n\n    function pullFeeOdometer (uint256 poolIdx, int24 mid, int24 bid, int24 ask,\n                              uint64 feeGlobal)\n        public view returns (uint72) {\n        return clockFeeOdometer72(bytes32(poolIdx), mid, bid, ask, feeGlobal);\n    }\n\n    function testCrossLevel (uint256 poolIdx, int24 tick, bool isBuy,\n                             uint64 feeGlobal) public {\n        (liqDelta, knockoutFlag) = crossLevel(bytes32(poolIdx), tick, isBuy, feeGlobal);\n    }\n\n    function testAdd (uint256 poolIdx, int24 midTick, int24 bidTick, int24 askTick,\n                      uint96 lots, uint64 globalFee) public {\n        odometer = addBookLiq72(bytes32(poolIdx), midTick, bidTick, askTick,\n                                lots, globalFee);\n    }\n\n    function testRemove (uint256 poolIdx, int24 midTick, int24 bidTick, int24 askTick,\n                         uint96 lots, uint64 globalFee) public {\n        odometer = removeBookLiq72(bytes32(poolIdx), midTick, bidTick, askTick,\n                                   lots, globalFee);\n    }\n\n    function hasTickBump (uint256 poolIdx, int24 tick) public view returns (bool) {\n        return hasTickBookmark(bytes32(poolIdx), tick);\n    }\n\n}\n"
    },
    "contracts/test/TestLiquidityCurve.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport \"../mixins/LiquidityCurve.sol\";\nimport \"../libraries/SwapCurve.sol\";\n\ncontract TestLiquidityCurve is LiquidityCurve {\n    using TickMath for uint128;\n    using CurveMath for CurveMath.CurveState;\n    \n    uint256 public baseFlow;\n    uint256 public quoteFlow;\n\n    struct SwapFrame {\n        bool isBuy_;\n        bool inBaseQty_;\n        uint16 feeRate_;\n        uint8 protoCut_;\n    }\n\n     struct SwapAccum {\n        uint128 qtyLeft_;\n        int128 paidBase_;\n        int128 paidQuote_;\n        uint128 paidProto_;\n        SwapFrame cntx_;\n    }\n    \n    SwapAccum public lastSwap;\n\n    function liquidityReceivable (bytes32 poolIdx,\n                                  uint128 liq, int24 lower, int24 upper)\n        internal returns (uint128 base, uint128 flow) {\n        CurveMath.CurveState memory curve = snapCurve(poolIdx);\n        (base, flow) = liquidityReceivable(curve, liq, lower, upper);\n        commitCurve(poolIdx, curve);\n    }\n\n    function liquidityReceivable (bytes32 poolIdx, uint128 liq)\n        internal returns (uint128 base, uint128 flow) {\n        CurveMath.CurveState memory curve = snapCurve(poolIdx);\n        (base, flow) = liquidityReceivable(curve, liq);\n        commitCurve(poolIdx, curve);\n    }\n\n    function liquidityPayable (bytes32 poolIdx,\n                               uint128 liq, int24 lower, int24 upper)\n        internal returns (uint128 base, uint128 flow) {\n        CurveMath.CurveState memory curve = snapCurve(poolIdx);\n        (base, flow) = liquidityPayable(curve, liq, lower, upper);\n        commitCurve(poolIdx, curve);\n    }\n\n    function liquidityPayable (bytes32 poolIdx, uint128 liq, uint64 rewards,\n                               int24 lower, int24 upper)\n        internal returns (uint128 base, uint128 flow) {\n        CurveMath.CurveState memory curve = snapCurve(poolIdx);\n        (base, flow) = liquidityPayable(curve, liq, rewards, lower, upper);\n        commitCurve(poolIdx, curve);\n    }\n\n    function liquidityPayable (bytes32 poolIdx, uint128 liq)\n        internal returns (uint128 base, uint128 flow) {\n        CurveMath.CurveState memory curve = snapCurve(poolIdx);\n        (base, flow) = liquidityPayable(curve, liq);\n        commitCurve(poolIdx, curve);\n    }\n\n    function testLiqRecConc (uint256 poolIdx, uint128 liq,\n                             uint128 lower, uint128 upper) public {\n        (baseFlow, quoteFlow) = liquidityReceivable\n            (bytes32(poolIdx), liq, lower.getTickAtSqrtRatio(),\n             upper.getTickAtSqrtRatio());\n    }\n    \n    function testLiqRecTicks (uint256 poolIdx, uint128 liq,\n                              int24 lower, int24 upper) public {\n        (baseFlow, quoteFlow) = liquidityReceivable(bytes32(poolIdx), liq, lower, upper);\n    }\n\n    function testLiqRecAmb (uint256 poolIdx, uint128 liqSeed) public {\n        (baseFlow, quoteFlow) = liquidityReceivable(bytes32(poolIdx), liqSeed);\n    }\n\n    function testLiqPayConc (uint256 poolIdx, uint128 liq, uint128 lower, uint128 upper,\n                             uint64 rewards) public {\n        (baseFlow, quoteFlow) = liquidityPayable\n            (bytes32(poolIdx), liq, rewards,\n             lower.getTickAtSqrtRatio(), upper.getTickAtSqrtRatio());\n    }\n\n    function testLiqPayTicks (uint256 poolIdx, uint128 liq,\n                              int24 lower, int24 upper) public {\n        (baseFlow, quoteFlow) = liquidityPayable(bytes32(poolIdx), liq, lower, upper);\n    }\n    \n    function testLiqPayAmb (uint256 poolIdx, uint128 liqSeed) public {\n        (baseFlow, quoteFlow) = liquidityPayable(bytes32(poolIdx), liqSeed);\n    }\n\n    function testSwap (uint256 poolIdx,\n                       SwapAccum memory accum,\n                       uint128 bumpPrice, uint128 swapLimit) public {\n        int24 bumpTick = TickMath.getTickAtSqrtRatio(bumpPrice);\n        testSwapTick(poolIdx, accum, bumpTick, swapLimit);\n    }\n\n    function testSwapTick (uint256 poolIdx, SwapAccum memory accum,\n                           int24 bumpTick, uint128 swapLimit) public {\n        Chaining.PairFlow memory flow;\n        Directives.SwapDirective memory swap;\n        PoolSpecs.Pool memory pool;\n\n        flow.baseFlow_ = accum.paidBase_;\n        flow.quoteFlow_ = accum.paidQuote_;\n        if (accum.cntx_.inBaseQty_) {\n            flow.quoteProto_ = accum.paidProto_;\n        } else {\n            flow.baseProto_ = accum.paidProto_;\n        }\n\n        swap.isBuy_ = accum.cntx_.isBuy_;\n        swap.inBaseQty_ = accum.cntx_.inBaseQty_;\n        swap.qty_ = accum.qtyLeft_;\n        swap.limitPrice_ = swapLimit;\n\n        pool.feeRate_ = accum.cntx_.feeRate_;\n        pool.protocolTake_ = accum.cntx_.protoCut_;\n        \n        CurveMath.CurveState memory curve = snapCurve(bytes32(poolIdx));\n        SwapCurve.swapToLimit(curve, flow, swap, pool, bumpTick);\n        commitCurve(bytes32(poolIdx), curve);\n\n        accum.paidBase_ = flow.baseFlow_;\n        accum.paidQuote_ = flow.quoteFlow_;\n        accum.paidProto_ = !swap.inBaseQty_ ? flow.baseProto_ : flow.quoteProto_;\n        accum.qtyLeft_ = swap.qty_;\n        lastSwap = accum;\n    }\n\n    function testSwapBumpInf (uint256 poolIdx, SwapAccum memory accum,\n                              uint128 swapLimit) public {\n        int24 tick = accum.cntx_.isBuy_ ? TickMath.MAX_TICK : TickMath.MIN_TICK;\n        testSwapTick(poolIdx, accum, tick, swapLimit);\n    }\n    \n    function testSwapLimitInf (uint256 poolIdx, SwapAccum memory accum) public {\n        int24 tick = accum.cntx_.isBuy_ ? TickMath.MAX_TICK : TickMath.MIN_TICK;\n        uint128 limit = accum.cntx_.isBuy_ ? TickMath.MAX_SQRT_RATIO+1 :\n            TickMath.MIN_SQRT_RATIO-1;\n        testSwapTick(poolIdx, accum, tick, limit);\n    }\n\n    function fixCurve (uint256 poolIdx, uint128 price,\n                       uint128 ambientLiq, uint128 concLiq) public {\n        CurveMath.CurveState memory curve = snapCurveInit(bytes32(poolIdx));\n        curve.priceRoot_ = price;\n        curve.ambientSeeds_ = ambientLiq;\n        curve.concLiq_ = concLiq;\n        curve.priceRoot_ = price;\n        commitCurve(bytes32(poolIdx), curve);\n    }\n\n    function fixAccum (uint256 poolIdx, uint64 ambient, uint64 conc) public {\n        CurveMath.CurveState memory curve = snapCurve(bytes32(poolIdx));\n        curve.seedDeflator_ = ambient;\n        curve.concGrowth_ = conc;\n        commitCurve(bytes32(poolIdx), curve);\n    }\n\n    function pullCurve (uint256 poolIdx) public view returns\n        (CurveMath.CurveState memory) {\n        return snapCurve(bytes32(poolIdx));\n    }\n\n    function pullTotalLiq (uint256 poolIdx) public view returns (uint128) {\n        return snapCurve(bytes32(poolIdx)).activeLiquidity();\n    }\n}\n"
    },
    "contracts/test/TestLiquidityMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n    \nimport \"../libraries/LiquidityMath.sol\";\n\ncontract TestLiquidityMath {\n    using LiquidityMath for uint128;\n    \n    function testAddSigned (uint128 x, int128 y) public pure returns (uint128) {\n        return x.addDelta(y);        \n    }\n\n    function testAddUnsigned (uint128 x, int128 y) public pure returns (uint128) {\n        return x.addDelta(y);        \n    }\n\n    function testMinus (uint128 x, uint128 y) public pure returns (uint128) {\n        return x.minusDelta(y);\n    }\n\n    function testDeltaRewards (uint64 x, uint64 y) public pure returns (uint64) {\n        return LiquidityMath.deltaRewardsRate(x, y);\n    }\n\n    function testDeltaRewards72 (uint72 x, uint72 y) public pure returns (uint64) {\n        return LiquidityMath.deltaRewardsRate72(x, y);\n    }\n\n    function testBlendMileage (uint64 mileageX, uint128 liqX, \n        uint64 mileageY, uint128 liqY) public pure returns (uint64) {\n        return LiquidityMath.blendMileage(mileageX, liqX, mileageY, liqY);\n    }\n\n    function testBlendMileage72 (uint72 mileageX, uint128 liqX, \n        uint72 mileageY, uint128 liqY) public pure returns (uint72) {\n        return LiquidityMath.blendMileage72(mileageX, liqX, mileageY, liqY);\n    }\n}\n"
    },
    "contracts/test/TestPositionRegistrar.sol": {
      "content": "\n// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n    \nimport \"../mixins/PositionRegistrar.sol\";\n\ncontract TestPositionRegistrar is PositionRegistrar {\n    uint256 public lastRewards;\n    \n    function testAdd (address owner, uint256 poolIdx, int24 lower, int24 upper,\n                      uint128 liq, uint64 mileage) public {\n        mintPosLiq(owner, bytes32(poolIdx),\n                   lower, upper, liq, mileage);\n    }\n\n    function testBurn (address owner, uint256 poolIdx, int24 lower, int24 upper,\n                       uint128 liq, uint64 mileage) public {\n        lastRewards = burnPosLiq(owner, bytes32(poolIdx),\n                                 lower, upper, liq, mileage);\n    }\n\n    function getPos (address owner, uint256 poolIdx, int24 lower, int24 upper)\n        public view returns (uint128, uint256) {\n        RangePosition72 storage pos = lookupPosition(owner, bytes32(poolIdx),\n                                                   lower, upper);\n        return (pos.liquidity_, pos.feeMileage_);\n    }\n}\n"
    },
    "contracts/test/TestPriceGrid.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n    \nimport \"../libraries/PriceGrid.sol\";\nimport \"../libraries/Directives.sol\";\n\ncontract TestPriceGrid {\n\n    function testThresh (bool inBase, uint128 unit, uint16 awayTicks,\n                         int8[] calldata, uint16 tickSize,\n                         int24 priceTick, int24 bidTick, int24 askTick)\n        public pure returns (uint128) {\n        return PriceGrid.improveThresh\n            (PriceGrid.ImproveSettings(inBase, unit, awayTicks),\n             tickSize, priceTick, bidTick, askTick);\n    }\n\n    function testClipInside (uint16 tickSize, int24 bidTick, int24 askTick)\n        public pure returns (uint24) {\n        return PriceGrid.clipInside(tickSize, bidTick, askTick);\n    }\n\n    function testClipBelow (uint16 tickSize, int24 bidTick)\n        public pure returns (uint24) {\n        return PriceGrid.clipBelow(tickSize, bidTick);\n    }\n\n    function testClipAbove (uint16 tickSize, int24 askTick)\n        public pure returns (uint24) {\n        return PriceGrid.clipAbove(tickSize, askTick);\n    }\n\n\n    function testOnGrid (int24 lowerTick, int24 upperTick, uint16 gridSize)\n        public pure returns (bool) {\n        return PriceGrid.isOnGrid(lowerTick, upperTick, gridSize);\n    }\n\n    function testVerify (bool inBase, uint128 unit, uint16 awayTicks,\n                         int8[] calldata, uint16 tickSize,\n                         int24 priceTick, int24 bidTick, int24 askTick,\n                         uint128 liq) public pure returns (bool) {\n        return PriceGrid.verifyFit(\n            PriceGrid.ImproveSettings(inBase, unit, awayTicks),\n            bidTick, askTick, liq, tickSize, priceTick);\n    }\n                            \n}\n"
    },
    "contracts/test/TestProtocolAcct.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\npragma experimental ABIEncoderV2;\n\nimport \"../libraries/CurveMath.sol\";\nimport \"../mixins/ProtocolAccount.sol\";\nimport \"../mixins/DepositDesk.sol\";\n\ncontract TestProtocolAccount is ProtocolAccount {\n    using TokenFlow for TokenFlow.PairSeq;\n        \n    constructor (address auth) {\n        authority_ = auth;\n    }\n    \n    function testAccum (address base, address quote,\n                        uint128 baseFees, uint128 quoteFees) public {\n        TokenFlow.PairSeq memory pair;\n        pair.nextHop(base, quote);\n        pair.flow_.baseProto_ = baseFees;\n        pair.flow_.quoteProto_ = quoteFees;\n        accumProtocolFees(pair);\n    }\n\n    function noop() payable public { }\n\n    function etherBalance (address x) public view returns (uint256) {\n        return x.balance;\n    }\n\n    function protoFeeAccum (address token) public view returns (uint128) {\n        return feesAccum_[token];\n    }\n\n    function disburseProtocol (address recv, address token) public {\n        disburseProtocolFees(recv, token);\n    }\n\n    function getPaidFees (address recv, address token) public view returns (uint128) {\n        return userBals_[keccak256(abi.encode(recv, token))].surplusCollateral_;\n    }\n}\n"
    },
    "contracts/test/TestSettle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n    \nimport \"../mixins/DepositDesk.sol\";\n\ncontract TestSettleLayer is DepositDesk {\n\n    address private recv_;\n    address private send_;\n    int128 public ethFlow;\n    bool public isFinal_;\n    \n    constructor (address recv) {\n        recv_ = recv;\n        send_ = recv;\n    }\n    \n    function fund() public payable { }\n\n    function setFinal (bool isFinal) public {\n        isFinal_ = isFinal;\n    }\n\n    function testQuerySurplus (address recv, address token) public\n        view returns (uint128) {\n        return super.querySurplus(recv, token);\n    }\n    \n    function testSettleFlow (int128 flow, address token) reEntrantLock public payable {\n        testSettleInner(flow, token, type(int128).max, 0, false);\n    }\n\n    function testSettleFlowTwo (int128 flowOne, int128 flowTwo,\n                                address token) reEntrantLock public payable {\n        testSettleInner(flowOne, token, type(int128).max, 0, false);\n        testSettleInner(flowTwo, token, type(int128).max, 0, false);\n    }\n\n    function testSettleLimit (int128 flow, address token, int128 limitQty)\n        reEntrantLock public payable {\n        testSettleInner(flow, token, limitQty, 0, false);\n    }\n\n    function testSettleDust (int128 flow, address token, uint128 dustThresh)\n        reEntrantLock public payable {\n        testSettleInner(flow, token, type(int128).max, dustThresh, false);  \n    }\n\n    function testSettleReserves (int128 flow, address token) reEntrantLock public payable {\n        testSettleInner(flow, token, type(int128).max, 0, true);\n    }\n\n    function testSettle (int128 flow, address token, int128 limitQty,\n                         uint128 dustThresh, bool useSurplus) reEntrantLock public payable {\n        testSettleInner(flow, token, limitQty, dustThresh, useSurplus);\n    }\n\n    function testSettleInner (int128 flow, address token, int128 limitQty,\n                              uint128 dustThresh, bool useSurplus) public payable {\n        Directives.SettlementChannel memory dir = Directives.SettlementChannel\n            ({token_: token, limitQty_: limitQty, dustThresh_: dustThresh,\n                    useSurplus_: useSurplus});\n        if (isFinal_) {\n            settleFinal(recv_, send_, flow, dir, ethFlow);\n        } else {\n            ethFlow += settleLeg(recv_, send_, flow, dir);\n        }\n    }\n\n    function testDesposit (address owner, uint128 value,\n                           address token) reEntrantLock internal {\n        depositSurplus(owner, value, token);\n    }\n\n    function testDepositTwice (address owner, uint128 valueOne, uint128 valueTwo,\n                               address token) reEntrantLock internal {\n        depositSurplus(owner, valueOne, token);\n        depositSurplus(owner, valueTwo, token);\n    }\n\n    function testDisburse (address owner, address recv, int128 value,\n                           address token) internal {\n        lockHolder_ = owner;\n        disburseSurplus(recv, value, token);\n    }\n\n    function getMyBalance() public view returns (uint256) {\n        return getBalance(address(this));\n    }\n\n    function getBalance (address tgt) public view returns (uint256) {\n        return tgt.balance;\n    }\n\n}\n"
    },
    "contracts/test/TestTickCensus.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n    \nimport \"../mixins/TickCensus.sol\";\n\ncontract TestTickCensus is TickCensus {\n        \n    bytes32 constant poolIdx = bytes32(uint256(1986));\n    \n    function getBitmaps (int24 tick) public view returns\n        (uint256 mezz, uint256 term) {\n        mezz = mezzanineBitmap(poolIdx, tick);\n        term = terminusBitmap(poolIdx, tick);\n    }\n\n    function testPinBuy (int24 tick) public\n        view returns (int24, bool) {\n        return pinBitmap(poolIdx, true, tick);\n    }\n\n    function testPinSell (int24 tick) public\n        view returns (int24, bool) {\n        return pinBitmap(poolIdx, false, tick);\n    }\n\n    function setTermBitmap (int24 tick, uint256 bitmap) public {\n        int24 mezzBase = (tick >> 8) << 8;\n        for (uint24 i = 0; i < 256; i++) {\n            if (bitmap & (0x1 << i) != 0) {\n                bookmarkTick(poolIdx, mezzBase + int24(i));\n            }\n        }        \n    }\n\n    function testSeekBuy (int24 tick) public view returns (int24, uint256) {\n        int24 next = seekMezzSpill(poolIdx, tick, true);\n        return (next, terminusBitmap(poolIdx, next));\n    }\n\n    function testSeekSell (int24 tick) public view returns (int24, uint256) {\n        int24 next = seekMezzSpill(poolIdx, tick, false);\n        return (next, terminusBitmap(poolIdx, next));\n    }\n\n    function testBookmark (int24 tick) public {\n        bookmarkTick(poolIdx, tick);\n    }\n\n    function testForget (int24 tick) public {\n        forgetTick(poolIdx, tick);\n    }\n}\n"
    },
    "contracts/test/TestTickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3\npragma solidity 0.8.19;\n    \nimport \"../libraries/TickMath.sol\";\n\ncontract TestTickMath {\n    using TickMath for int24;\n    using TickMath for uint128;\n    \n    function testRatio (int24 tick) public pure returns (uint128) {\n        return tick.getSqrtRatioAtTick();\n    }\n\n    function testTick (uint128 ratio) public pure returns (int24) {\n        return ratio.getTickAtSqrtRatio();\n    }\n\n    function minTick() public pure returns (int24) {\n        return TickMath.MIN_TICK;\n    }\n\n    function maxTick() public pure returns (int24) {\n        return TickMath.MAX_TICK;\n    }\n\n    function minRatio() public pure returns (uint128) {\n        return TickMath.MIN_SQRT_RATIO;\n    }\n\n    function maxRatio() public pure returns (uint128) {\n        return TickMath.MAX_SQRT_RATIO;\n    }\n}\n"
    },
    "contracts/vendor/compound/Timelock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.19;\n\n/* Code is directly ported from Compound Timelock implementation found here:\n *     https://github.com/compound-finance/compound-protocol/blob/master/contracts/Timelock.sol\n */\n\ncontract Timelock {\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 14 days;\n    uint public constant MINIMUM_DELAY = 2 days;\n    uint public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_) {\n        require(admin_ != address(0), \"Timelock::constructor Invalid admin address\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    fallback() external payable { }\n\n    function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp() + delay, \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta + GRACE_PERIOD, \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}